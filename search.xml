<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SASS笔记]]></title>
    <url>%2F2018%2F10%2F02%2FSASS%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[SASS安装npm install sass-loader node-sass --save-dev 变量 所有变量以$开头 如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中 计算功能 sass中可以使用加减乘除百分比计算值 只有第一个数值需要带单位, 后面的都不需要单位 12345body &#123; margin: (14px/2); top: 50px + 100px; right: $var * 10%;&#125; 嵌套 可以选择器嵌套 也可以属性嵌套 123456p &#123; // 注意属性嵌套必须加： border: &#123; color: red; &#125;&#125; 继承class2要继承class1，就要使用@extend命令 1234567.class1 &#123; border: 1px solid #ddd;&#125;.class2 &#123; @extend .class1; font-size:120%;&#125; Mixin使用@mixin命令，定义一个代码块 1234@mixin left &#123; float: left; margin-left: 10px;&#125; 使用@include命令，调用这个mixin 123div &#123; @include left;&#125; 可以指定参数和缺省值 12345678@mixin left($value: 10px) &#123; float: left; margin-right: $value;&#125;div &#123; @include left(20px);&#125; 浏览器兼容混合1234567891011@mixin rounded($vert, $horz, $radius: 10px) &#123; border-#&#123;$vert&#125;-#&#123;$horz&#125;-radius: $radius; -moz-border-radius-#&#123;$vert&#125;#&#123;$horz&#125;: $radius; -webkit-border-#&#123;$vert&#125;-#&#123;$horz&#125;-radius: $radius;&#125;#navbar li &#123; @include rounded(top, left)&#125;#footer &#123; @include rounded(top, left, 5px)&#125; 引入@import &quot;url&quot; 内置颜色函数12lighten(#cc3, 10%) // #d6d65cdarken(#cc3, 10%) // #a3a329 判断@if可以用来判断 1234p &#123; @if 1 + 1 == 2 &#123; border: 1px solid; &#125; @if 5 &lt; 3 &#123; border: 2px dotted; &#125;&#125; 循环12345@for $i from 1 to 10 &#123; .border-#&#123;$i&#125; &#123; border: #&#123;$i&#125;px solid blue; &#125;&#125; 自定义函数1234567@function double($n) &#123; @return $n * 2;&#125;#sidebar &#123; width: double(5px);&#125;]]></content>
      <categories>
        <category>SCSS</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>css</tag>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识点整理]]></title>
    <url>%2F2018%2F09%2F19%2F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[知识点整理变量提升 所有的var/函数定义/形参都会提升 变量提升不管条件是否成立 浏览器不会重复声明变量, 后var的不会覆盖之前的声明的 var的提升优先于函数表达式 作用域 ES5 没有块级作用域, 只有函数作用域和全局作用域 (let才有块级作用域) 闭包就是使用函数作用域来实现块级作用域的效果 函数执行时所在的作用域在函数定义时决定 引用数据类型 函数参数是引用传递 对象属性修改是修改原引用里属性的值, 对象重新赋值是一个新的引用 in检测对象是否有某属性(包括原型链) hasOwnProptoty 检查 对象本身是否有该数 函数 函数执行结果默认值undefined, fun表示函数本身, fun()表示函数执行结果 arguments里面的数据映射关系在传入实参时确定的, 没有赋值的形参没有映射关系 之后无论怎么添加 都无法建立映射关系 它是一个伪数组, 箭头函数没有arguments 执行流程分析 全局变量提升, 函数提升 依次执行(包括var xx = xx可能会覆盖) 遇到函数对象创建堆内存 执行函数 函数变量提升, 形参赋值 执行函数 函数返回 继续执行 构造函数不写return默认返回它的实例 如果return一个基本值则依然返回this对象 如果return一个引用数据, 则会返回该数据 this 所有IIFE中的this都指向window 事件回调里的this指向dom元素 函数中的this一定要确认执行时函数是谁调用的 看函数前是否有.以及.之前的调用对象是谁 如果没有调用对象this指向window 构造函数中的this指向实例对象 数据类型 typeof无法分辨三种对象null object array 特殊检测方法Object.prototype.toString.call(arr) ==&gt; &#39;[Object Array]&#39; 转换布尔值只有undefined null NaN 0 &#39;&#39; 为false + 和 === 运算前需要注意数据类型 原型 每个函数都有prototype属性 每个对象都有__proto__属性 构造函数的prototype === 实例的__proto__ instanceof 判断实例的机制 所有函数的构造函数是Function 没有明确构造函数的实例的构造函数是Object 执行上下文 全局执行上下文 函数执行上下文 执行上下文的内容 变量、函数声明和函数的形参 作用域链 this IIFE 当 JS 解释器在遇到非匿名的立即执行函数时，会创建一个辅助的特定对象 然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 foo 但是这个值又是只读的，所以对它的赋值并不生效 所以打印的结果还是这个函数，并且外部的值也没有发生更改 123456var foo = 1(function foo() &#123; foo = 2 console.log(foo)&#125;())//ƒ foo() &#123; foo = 2 ; console.log(foo) &#125; 闭包 闭包的先决条件 函数嵌套 内部函数引用了外部函数的变量 闭包原理 因为内部函数引用了外部函数作用域中的数据, 所以外部函数执行完毕后并不会销毁 内部函数操作某属性时, 如果自身没有该属性则会去上级作用域中查找 也就是没销毁的外部函数私有作用域 闭包的作用 解决 ES5 没有块级作用域的问题 模块化的基础 形成一个新的命名空间, 保护内部数据 深拷贝 简单方法 JSON.parse(JSON.stringify(object)) 不足: 不能拷贝 undefiend 拷贝循环引用的对象会报错 自己写一个拷贝函数 传入一个对象或数组 判断数据类型 新建一个变量用于储存结果 遍历实参的属性值 如果属性值为引用数据类型则递归调用该方法继续深入, 并将递归返回值保存到结果变量中 如果属性值是基本数据类型则将key: value保存到结果变量中 返回结果 防抖防抖是将多次执行变为一次执行 123456789101112131415161718192021222324252627282930313233343536373839404142// 将一般函数加工为防抖函数// fun ===&gt; 需要加工的函数// time ===&gt; 时间间隔// isNow ===&gt; 触发后立即执行还是延后执行function fd (fun, time, isNow) &#123; // 缓存定时器id var timeOutId = '' return function (...arg) &#123; // 立即执行逻辑 if (isNow) &#123; if (!timeOutId) &#123; fun.apply(this, arg) &#125; else &#123; clearTimeout(timeOutId) &#125; timeOutId = setTimeout(function () &#123; timeOutId = '' &#125;, time) // 延后执行逻辑 &#125; else &#123; if (timeOutId) &#123; clearTimeout(timeOutId) &#125; timeOutId = setTimeout(function () &#123; fun.apply(this, arg) timeOutId = '' &#125;,time) &#125; &#125;&#125;// 测试function fun(a, b, c) &#123; console.log(a) console.log(b) console.log(c)&#125;var fdFun = fd(fun, 500, false)var btn = document.getElementById('btn')btn.onclick = function() &#123; fdFun(1, 2, 3)&#125; 继承12345678910111213141516171819202122function Father (name, age) &#123; this.name = name this.age = age&#125;Father.prototype.sayHi = function () &#123; console.log('hi~')&#125;function Child (name, age, sex) &#123; // 继承父类属性 Father.call(this, name, age) this.sex = sex&#125;// 继承父类方法Child.prototype = new Father()// 修正constructorChild.prototype.constructor = ChildChild.prototype.sayHello = function () &#123; console.log('hello~')&#125;// 测试var f = new Father('dad', 28)var c = new Child('son', 6, 'boy') call, apply, bind 区别call 和 apply 都是为了解决改变 this 的指向。作用都是相同的，只是传参的方式不同。 call 从第二个参数开始一次传递参数, apply 将参数封装成数组传入第二个位置 bind 也用作修改this指向，但是该方法不会立即执行函数而是返回一个函数。 模拟实现思路: 在调用的对象上新建一个属性来保存调用的函数, 调用完后delete该属性 数组取最大值Math.max.apply(Math, arr) 面向对象封装封装就是把数据和操作该数据的方法一起写在函数内部 程序的其它地方只能通过该函数向外暴露的方法才能对内部的数据进行访问或操作 封装有两种状态 实例对象上的属性(公开的) 在函数内部声明的变量(私有的) prototype给实例对象添加的方法不能去访问类的私有变量和方法 继承当多个类存在相同的属性和方法时，可以从这些类中抽象出父类 在父类中定义这些相同的属性和方法 所有的子类不需要重新定义这些属性和方法，只需要通过继承父类中的属性和方法 多态多态是指一个引用类型数据在不同情况下的多种状态 同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果 单例模式 即一个类只有一个实例 当我们创建一个实例时, 先判断其是否已经存在了这个实例 如果已经存在了这个实例, 那么就返回这个已经存在的实例 如果不存在, 则创建实例 实现思路 利用闭包创建私有变量来保存创建的实例, 创建实例前先判断该变量是否有值 将实例保存到构造函数的属性上, 创建前想判断该属性的值是否存在 在实例创建完成后, 重写该构造函数(直接返回实例对象) 观察者模式根据状态的变化主动触发观察者队列的回调行为 1234567891011121314class StateTracker&#123; constructor()&#123; this.observers = []; this.internalState= 10; &#125; // 改变内部状态，触发状态的观察者列表 change(val)&#123; this.internalState= val; this.observers.forEach(observer=&gt;observer(val)); &#125;// 注册观察者 registerObserver(ObserverFn)&#123; this.obserers.push(ObserverFn) &#125;&#125; 订阅发布模式在代码模块的共享访问空间存储hashMap的topic/callback形式 添加on/off/trigger等接口实现挂载、移除、触发等动作 12345678910111213141516171819202122class PubSubHandler&#123; constructor()&#123; this.eventPool = &#123;&#125;; &#125; //移除 off(topicName)&#123; delete this.observers[topicName] &#125; //发布 trigger(topicName,...args)&#123; this.eventPool[topicName] &amp;&amp; this.eventPool[topicName].forEach(callback=&gt;callback(...args)); &#125; //订阅 on(topicName,callback)&#123; let topic = this.eventPool[topicName] ; if(!topic)&#123; this.eventPool[topicName] =[] &#125; this.eventPool[topicName].push(callback) &#125;&#125; Reduce作用是数组中的值组合起来，最终得到一个值 1array.reduce(function(total, Value, Index, arr), initial) total: 必需。计算后的返回值, 作为下一次计算的初始值 Value: 必需。当前元素 Index: 可选。当前元素的索引 arr: 可选。当前元素所属的数组对象 initial: 可选。第一次计算total的初始值 async函数 该函数返回值是一个 Promise 可以看成将函数返回值使用 Promise.resolve() 包裹了下 如果await之后的异步代码并不依赖于前者，但仍然需要等待前者完成，会导致代码失去并发性 async函数会缓存执行时的数据 遇到await时async函数会交出执行权, 让其他同步代码执行完后再继续执行await后的异步代码 definePropertyObject.defineProperty(obj, prop, descriptor) 作用 该方法允许精确添加或修改对象的属性 通过赋值操作添加的普通属性是可枚举、修改、删除 这个方法允许修改属性的配置选项(是否可枚举、修改、删除) 参数 obj: 要定义属性的对象 prop: 定义的属性名称 descriptor: 属性配置描述符 返回值 被传递给函数的对象obj descriptor configurable: 默认为 false, 属性是否可删除 enumerable: 默认为 false, 是否可枚举 writable: 默认为 false, 是否可修改 value: 属性的值, 默认undefined get: 当访问该属性时, 该方法会被执行(没有参数), return值. 默认会传入this set: 当属性值修改时, 触发执行该方法. 该方法将修改值作为唯一参数传入 ProxyES6 中新增的功能, 可以用来自定义对象中的操作, 可以用来实现数据绑定和监听 let p = new Proxy(target, handler) target 需要用Proxy包装的目标对象 (可以是对象, 数组或者另一个代理) handler 配置对象 get() 在读取代理对象的某个属性时触发 set() 在给代理对象的某个属性赋值时触发 apply() 当目标对象为函数，且被调用时触发 解决JS小数不准确的问题1parseFloat((0.1 + 0.2).toFixed(10)) addEventListener第三个参数: 是否在捕获阶段触发, 默认false Event loop 执行顺序 执行同步代码 script属于宏任务, 所以微任务快于宏任务的说法是错误的 当执行栈为空时查询是否有微任务需要执行 执行所有微任务 必要的话渲染 UI 然后开始下一轮 Event loop，执行宏任务中的异步代码 微任务包括 process.nextTick ，promise ，Object.observe ，MutationObserver 宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering 本地存储 特性 cookie localStorage sessionStorage indexDB 数据生命周期 一般由服务器生成，可以设置过期时间 除非被清理，否则一直存在 页面关闭就清理 除非被清理，否则一直存在 数据存储大小 4K 5M 5M 无限 与服务端通信 每次都会携带在header中，对于请求性能有影响 不参与 不参与 不参与 不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储 cookie 安全性 属性 作用 value 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 http-only 不能通过 JS 访问 Cookie，减少 XSS 攻击 secure 只能在协议为 HTTPS 的请求中携带 same-site 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击 渲染机制浏览器的渲染机制一般分为以下几个步骤 处理 HTML 并构建 DOM 树。 处理 CSS 构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，计算每个节点的位置。 调用 GPU 绘制，合成图层，显示在屏幕上。 安全XSSXSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站 防范: 最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义 CSP: 可以通过 HTTP Header 中的 Content-Security-Policy 来开启 CSP CSRFCSRF 就是利用用户的登录态发起恶意请求 防范: Get 请求不对数据进行修改 不让第三方网站访问到用户 Cookie 阻止第三方网站请求接口 请求时附带验证信息，比如验证码或者 toke 验证Referer: 通过验证Referer来判断该请求是否为第三方网站发起的 HTTPHTTP 协议是个无状态协议，不会保存状态 GET和POST区别: Get 请求能缓存，Post 不能 Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会 在抓包的情况下都是一样的 Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术 URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的 Post 支持更多的编码类型且不对数据类型限制 状态码 2XX 成功 200 OK，表示从客户端发来的请求在服务器端被正确处理 204 No content，表示请求成功，但响应报文不含实体的主体部分 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容 206 Partial Content，进行范围请求 3XX 重定向 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL 302 found，临时性重定向，表示资源临时被分配了新的 URL 303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况 307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求 4XX 客服端错误 400 bad request，请求报文存在语法错误 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 403 forbidden，表示对请求资源的访问被服务器拒绝 404 not found，表示在服务器上没有找到请求的资源 5XX 服务端错误 500 internal sever error，表示服务器端在执行请求时发生了错误 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求 HTTP首部 实体字段 作用 Allow 资源的正确请求方式 Content-Encoding 内容的编码格式 Content-Language 内容使用的语言 Content-Length request body 长度 Content-Location 返回数据的备用地址 Content-MD5 Base64加密格式的内容 MD5检验值 Content-Range 内容的位置范围 Content-Type 内容的媒体类型 Expires 内容的过期时间 Last_modified 内容的最后修改时间 从输入 URL 到页面加载完成的过程 首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了 TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件 首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错 浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件 文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。 初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件 CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西 在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了 快排快排的原理如下。随机选取一个数组中的值作为基准值，从左至右取值与基准值对比大小。比基准值小的放数组左边，大的放右边，对比完成后将基准值和第一个比基准值大的值交换位置。然后将数组以基准值的位置分为两部分，继续递归以上操作。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>整理笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2018%2F09%2F16%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git常用命令设置签名 仓库级别: 尽在当前本地库范围内有效 git config user.name setsuna git config user.email setsuna@wo.cn 系统级别: 登录当前操作系统的用户范围git config --global 级别优先级: 必须设置, 仓库级别优先 本地仓库 git init —- 创建仓库 git add * —- 添加到暂缓区 git commit -m &quot;test&quot; —- 提交到分支 (-m “提交说明”) 本地操作 git status —- 查看当前库状态 git diff [HEAD^] test.txt —- 查看文件修改内容 不带参数是和缓存区比较, 在文件名前加入历史版本则和历史版本比较 git log —- 查看之前的版本记录 git log --oneline 简洁显示 git reset --hard HEAD^ —- 退回到上一个版本 HEAD表示当前版本^前一个版本~n前n个版本 git reset --hard 10bh94a —- 回到指定版本 参数为commit哈希前几位 git reflog —- 查看所有的版本记录 git checkout -- test.txt —- 放弃修改文件 回到最近一次git commit或git add时的状态, 可以找回删除文件 git reset HEAD test.txt —- 从暂缓区去除文件 git rm test.txt —- 从暂缓区删除文件 使用git rm &lt;file&gt;和git add&lt;file&gt;效果是一样的 远程仓库 github上创建新项目 (只填写仓库名称 其他默认) git remote add origin https://github.com/Se7suna/test.git —- 关联远程库 git push -u origin master —- 推送master分支到远程库 第一次推送时-u关联分支 git push origin test —- 推送其他分支 git remote -v —- 查看远程库详情 远程库默认 origin git remote remove &lt;name&gt; —- 删除远程别名 GitHub操作 ssh-keygen -t rsa -C &quot;test@mail.com&quot; —- 创建SSH Key 免密登录 在用户文档文件夹里id_rsa是私钥id_rsa.pub是公钥 在 GitHub 设置中添加 SSH Keys 为 id_rsa.pub 中的内容 推送时需要推送到SSH地址 克隆远程库 创建时勾选 README git clone [Clone or download] —- 克隆远程项目 clone命令会自动初始化仓库, 并且设置origin别名 分支操作 git checkout -b feature —- 创建feature分支 -b并切换到该分支 git checkout xxx —- 切换到指定分支 git branch —- 查看分支 *表示当前分支 git branch feature_test —- 创建feature_test分支 git branch -d xxx —- 删除指定分支 git merge xxx —- 合并指定分支到当前分支 合并冲突 需要去冲突文件手动合并 git status —- 也可以查看合并冲突提示 git merge --no-ff -m &quot;text&quot; test —- 使用普通模式合并分支 合并后保留分支的commit历史 git stash —- 临时储存暂缓区 git stash list —- 查看临时暂缓区 git stash pop —- 还原暂缓区内容, 并清空暂缓区 git branch -D test —- 强行删除未合并的分支 -D 大写 git checkout -b dev origin/dev —- 创建本地dev分支并连接到origin的dev分支 git branch --set-upstream-to master origin/master —- 连接本地dev分支与origin的dev分支 git pull —- 抓取origin上的最新提交 fetch[远程库地址别名][远程分支名] + merge[远程库地址别名/远程分支名] git tag v1.0 —- 给当前commit添加标签(用-a指定标签名-m指定说明文字) git tag —- 查看标签 git tag v0.9 f52c633 —- 给指定commit添加标签 git show v1.0 —- 查看标签信息 git tag -d v0.1 —- 删除标签 git push origin --tags —- 可以推送全部未推送过的本地标签 git push origin :refs/tags/&lt;tagname&gt; —- 可以删除一个远程标签。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue笔记]]></title>
    <url>%2F2018%2F09%2F15%2FVue%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[VueVue基础MVVMMVVM是前端视图层的分层开发思想, 每个页面分成了M V和VM 使用 MVVM 可以使 开发更加便捷, 因为VM提供了数据的双向绑定 Model: 模型, 保存的是每个页面中的数据 ViewModel: 视图模型, Vue的实例. 它是调度者分割了 M 和 V, 每当 V 层想要获取/保存数据的时候都要由 VM 做中间的处理 View: 视图, 每个页面中的HTML结构 模板12345678910111213141516&lt;!-- Vue的实例 控制该元素内部的内容 (V)--&gt;&lt;div id="app"&gt; &lt;!-- 通过Vue指令将数据渲染到页面上 --&gt; &lt;!-- v-cloak 可以解决 插值表达式闪烁问题 它需要样式配合--&gt; &lt;!-- [v-cloak] &#123; display: none &#125; --&gt; &lt;!-- 插值表达式里面的是 js 代码 --&gt; &lt;p v-cloak&gt; &#123; &#123; msg &#125; &#125; &lt;/p&gt; &lt;!-- v-text 默认没有闪烁问题 但数据会完全覆盖标签里的内容 --&gt; &lt;p v-text="msg"&gt;&lt;/p&gt; &lt;!-- v-html 也会覆盖内容 它会将数据当作 html来渲染 --&gt; &lt;h1 v-html="htmlTest"&gt;&lt;/h1&gt; &lt;!-- v-bind 是用于绑定 属性的指令, 绑定后会把属性的值当作js表达式来解析 (简写 : )--&gt; &lt;!-- v-on 是用于绑定 事件的指令, 可以为DOM元素 绑定methods中的事件 (简写 @)--&gt; &lt;input type="button" value="按钮" v-bind:title="mytitle + '简写 :' " v-on:click="show($event)"&gt;&lt;/div&gt; 实例1234567891011121314151617181920// 创建Vue的实例 (当我们导入包后, 在浏览器的内存中就多了一个Vue构造函数) (VM)let vm = new Vue(&#123; // 表示当前实例要控制的DOM元素 el: "#app", // data属性中存放的是 el 中需要用到的数据 (M) // vm 实例中使用内部的数据或方法 通过 this.属性名(方法名) 来使用 data: &#123; msg: "hello word", htmlTest: "&lt;i&gt;把数据当作html来渲染&lt;/i&gt;", mytitle: "v-bind绑定属性" &#125;, // methods属性中设置 el 中可用的方法 methods: &#123; // $evnet 代表事件对象 show(event) &#123; // $event.target 代表触发事件的 DOM 元素 console.log(event.target) &#125; &#125;&#125;) 事件修饰符 .capture 使事件在 捕获阶段触发 .stop 停止事件冒泡 .prevent 阻止事件的默认行为 .once 表示该事件只触发一次 .self 只有绑定的元素才触发该事件 .native 将组件还原为原生DOM执行原生的事件 给Vue组件绑定事件 需要加.native才能生效 因为Vue的组件默认执行自定义事件 双向数据绑定使用v-model可以实现表单数据双向绑定, 实现表单数据自动搜集 v-model 收集的值 1234567891011121314151617181920212223242526272829&lt;!-- 阻止默认行为, 手动提交表单 --&gt;&lt;form action="/xxx" @submit.prevent="handleSubmit()"&gt; &lt;!-- v-model 绑定 value 属性的值 --&gt; &lt;label&gt;用户名:&lt;input type="text" v-model="userName"&gt;&lt;/label&gt;&lt;br&gt; &lt;label&gt;密码:&lt;input type="password" v-model="pwd"&gt;&lt;/label&gt;&lt;br&gt; 性别: &lt;!-- v-model 绑定 name 属性 值为 value 的值 --&gt; &lt;label&gt;&lt;input type="radio" value="boy" v-model="sex"&gt;男&lt;/label&gt; &lt;label&gt;&lt;input type="radio" value="girl" v-model="sex"&gt;女&lt;/label&gt;&lt;br&gt; 爱好: &lt;!-- v-model 绑定选中项目, 绑定它的 value 值 --&gt; &lt;label&gt;&lt;input type="checkbox" value="zuqiu" v-model="likes"&gt;足球&lt;/label&gt; &lt;label&gt;&lt;input type="checkbox" value="lanqiu" v-model="likes"&gt;篮球&lt;/label&gt; &lt;label&gt;&lt;input type="checkbox" value="pingpang" v-model="likes"&gt;乒乓球&lt;/label&gt; &lt;label&gt;&lt;input type="checkbox" value="yumaoqiu" v-model="likes"&gt;羽毛球&lt;/label&gt;&lt;br&gt; &lt;label&gt; 城市: &lt;!-- 下拉框 v-model 绑定给 select, 值为选中 option 的value --&gt; &lt;select v-model="city"&gt; &lt;!-- 为动态生成的 option 绑定 key 和 value --&gt; &lt;option v-for="(item, index) in allCity" :key="index" :value="item.id"&gt; &#123; &#123; item.name &#125; &#125; &lt;/option&gt; &lt;/select&gt; &lt;/label&gt;&lt;br&gt; &lt;label&gt; &lt;!-- textarea 的 v-model 绑定它的 value 值 --&gt; 签名:&lt;textarea rows=10 v-model="inf"&gt;&lt;/textarea&gt;&lt;br&gt; &lt;/label&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 可以在data里设置绑定数据的默认值 v-for 循环在 2.2.0+ 的版本里, 当在组件里使用v-for时, key是必须的 以便Vue能跟踪每个节点的身份从而重用和重新排序现有元素 使用v-bind绑定key属性的值(它的值只能使用数字或者字符串) 注意: Vue只是监视了data上数据自身的变化没有监视其内部的变化 Vue重写了数组中一系列改变数组内部数据的方法 (先调用原生方法更新数据, 再更新页面) 例如: 使用下标更改数组内部数据, 没有调用数组的变异方法界面就不会更新 (使用splice进行增删改) 优先级: v-for和v-if同时存在时v-for优先渲染 如果想要先判断需要在外层用template标签包裹 template不会渲染到页面中 常用循环 123456789&lt;!-- v-for 遍历数组 --&gt;&lt;p v-for="item in list"&gt; &#123; &#123; item &#125; &#125; &lt;/p&gt;&lt;p v-for="(item, i) in list" :key="i"&gt; &#123; &#123; item &#125; &#125; === &#123; &#123; i &#125; &#125; &lt;/p&gt;&lt;!-- v-for 遍历对象 --&gt;&lt;p v-for="(value, key, i) in obj" :key="i"&gt; &#123; &#123; value &#125; &#125; --- &#123; &#123; key &#125; &#125; --- &#123; &#123; i &#125; &#125; &lt;/p&gt;&lt;!-- v-for 迭代数字 (从1开始) --&gt;&lt;p v-for="count in 10"&gt; &#123; &#123; count &#125; &#125; &lt;/p&gt; v-if和v-show v-if: 每次重新删除或创建元素, 有较高的元素切换消耗 适合根据实际情况 生成/删除的元素 v-show: 只是控制元素的 display 样式，有较高的初始渲染消耗 适合经常切换显示状态的元素 Vue设置stylehtml 12345&lt;div id="app"&gt; &lt;p :style="&#123;color: 'red', 'font-width': 800&#125;"&gt; &#123; &#123; msg &#125; &#125; &lt;/p&gt; &lt;p :style="styleObj"&gt; &#123; &#123; msg &#125; &#125; &lt;/p&gt; &lt;p :style="[styleObj, styleObj2]"&gt; &#123; &#123; msg &#125; &#125; &lt;/p&gt;&lt;/div&gt; script 12345678910111213let vm = new Vue(&#123; el: "#app", data: &#123; msg: "内联style", styleObj: &#123; color: 'blue', 'font-size': '20px' &#125;, styleObj2: &#123; 'background-color': "green" &#125; &#125;&#125;) Vue设置class12345678910&lt;!-- 通过 v-bind 绑定 class 属性, 传入一个包含多个字符串类名的数组 --&gt;&lt;!-- 可以在 数组中使用三元表达式 使class更加智能 --&gt;&lt;p :class="['red', 'b', flag? 'big' : '']" v-text="msg"&gt;&lt;/p&gt;&lt;!-- 可以将 数组中类名改为对象 --&gt;&lt;p :class="['red', &#123;big : true&#125;]" v-text="msg"&gt;&lt;/p&gt;&lt;!-- 直接传入 对象 来配置class类 --&gt;&lt;p :class="&#123;b: true, big: true&#125;" v-text="msg"&gt;&lt;/p&gt;&lt;p :class="classObj" v-text="msg"&gt;&lt;/p&gt; 自定义过滤器Vue中的过滤器可被用作常见的文本格式化, 用于插值表达式和v-bind表达式 过滤器应该被添加在 JavaScript 表达式的尾部由|符号提示 html 123&lt;p&gt; &#123; &#123; msg &#125; &#125; &lt;/p&gt;&lt;p&gt; &#123; &#123; msg | msgFilter("实参") | test &#125; &#125; &lt;/p&gt;&lt;input type="button" value="title" :title="msg | msgFilter('替换内容')"&gt; 全局过滤器 (必须写在前面, 第一个参数data默认为|前的数据) 1234Vue.filter("msgFilter", function(data, option) &#123; return data.replace(/test/g, option)&#125;)Vue.filter("test", msg =&gt;"===" + msg + "===") 过滤器可以多次过滤 (从左往右) 123456789vm = new Vue(&#123; el: "#app", data: &#123; msg: "test 我是要 test 过滤 的 内容 test", &#125;, filters: &#123; //实例定义私有过滤器 (重名优先使用私有) &#125;&#125;) 自定义指令 参数 指令名称 (定义的时候不需要在前面加v-, 使用的时候需要加v-) 一个对象, 这个对象上有一些指令相关的函数, 这些函数可以在特定阶段触发,执行相关操作 1234567891011121314151617181920212223242526272829303132Vue.directive("focus", &#123; // bind 参数: // el: 表示被绑定指令的那个 DOM 元素 // bingding &#123; // name: 指令名称 == "focus" // value: 绑定值表达式 == 2 (1 + 1) // expression: 绑定值的字符串形式 == "1 + 1" // arg: 传给指令的参数 (例如 v-mytest : foo, arg的值就是foo) // oldValue: 指令绑定的前一个值 (仅在 update 和 componentUpdated 钩子中可用) // modifiers: 包含一个修饰符的对象 // &#125; // vnode: Vue编译生成的虚拟节点 // oldVnode: 上一个虚拟节点 // 钩子函数: bind(el, binding, vnode, oldVnode) &#123; // 当指令绑定到元素上的时候, 触发执行 (只能触发一次) el.style.color = binding.value &#125;, inserted(el) &#123; // 元素插入到 DOM 中的时候, 触发执行 el.focus() &#125;, updated() &#123; // 当 VNode 更新的时候, 触发执行 (可能触发多次) &#125;, componentUpdated() &#123; // 所在组件的 VNode 及其孩子的 VNode 全部更新时调用 &#125;, unbind() &#123; // 元素解绑时触发调用 (只触发一次) &#125;&#125;) 如果只想在bind和update钩子上做重复动作, 可以简写 el是被绑定的dom元素 bingding是配置对象 123Vue.directive("color-swatch", (el, binding) =&gt; &#123; el.style.backgroundColor = binding.value&#125;) 实例私有 12345678910vm = new Vue(&#123; el: "#app", directives: &#123; // 自定义私有指令 // 简写相当于把该函数同时写到了 bind 和 update 中去 fontsize: (el, binding) =&gt; &#123; el.style.fontSize = parseInt(binding.value) + "px" &#125; &#125;&#125;) Vue生命周期生命周期: 从Vue实例创建、运行、到销毁期间, 总是伴随着各种各样的事件, 这些事件统称为生命周期 生命周期钩子 = 生命周期函数 = 生命周期事件 生命周期三大阶段: 创建期间的生命周期函数(创建, 初始化阶段) 运行期间的生命周期函数(运行, 更新阶段) 销毁期间的生命周期函数(死亡, 销毁阶段) 生命周期流程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748let vm = new Vue(&#123; // 第一个生命周期函数, 表示实例完全被创建出来之前, 会执行它 beforeCreate() &#123; // 注意: 这时候 data 和 methods 里的数据 都还没有初始化 &#125;, data: &#123; // 初始化数据 &#125;, methods: &#123; // 初始化方法 &#125;, // 在第二个生命周期函数时, data 和 methods 里的数据才初始化完成 created() &#123; &#125;, // 编译模版, 把Vue代码中的指令执行, 在内存中生成编译好的最终模版字符串 // 然后把该模版字符串渲染为内存中的 DOM ,此时 DOM 已经渲染 但还在内存中 并未挂载到页面 el: "#app", // 第三个生命周期函数. 此时模版已经在内存中编译完成了, 但尚未把模版渲染到页面中 beforeMount() &#123; &#125;, // 将内存中编译好的模版替换到页面中去 // 第四个生命周期函数, 此时 DOM 挂载完成, 它是实例创建生命周期的最后一个函数 mounted() &#123; // 该函数执行完毕 则表示 整个Vue实例已经创建完毕, 并已渲染到页面 // 此时已经脱离创建阶段, 进入运行阶段 // 如果要操作页面中的 DOM 元素最早只能在这里进行 &#125;, // 运行阶段, data 里的数据改变时候触发以下两个函数 (最少触发0次, 最多触发无限次) // 表示 data 数据已经改变, 但是还未渲染到页面中去 beforeUpdate() &#123; &#125;, // 根据 data 中最新的数据, 在内存中重新渲染出一份新的 DOM 树, 然后 将其渲染到页面中去 updated() &#123; // 此时 页面中的数据 已经更新 和 data 中的最新数据相同 &#125;, // vm.$destroy() 实例调用 $destory() 方法时, 进入销毁阶段 // 当执行该函数时, Vue 实例就已经从运行阶段 进入销毁阶段 beforeDestroy() &#123; // 此时实例上的所有数据、方法、过滤器、指令依然可用 &#125;, // Vue 实例已销毁, 此时组件上的所有数据、方法、过滤器、指令都不再可用 destroyed() &#123; &#125;,&#125;) 过渡动画 使用 Vue 定义的transition元素 将动画元素包裹起来 1234567&lt;transition&gt; &lt;h3 v-if="flag1"&gt;动画效果&lt;/h3&gt;&lt;/transition&gt;&lt;transition name="my"&gt; &lt;h3 v-if="flag2"&gt;自定义V前缀&lt;/h3&gt;&lt;/transition&gt; 自定义两组样式, 来控制 transition 内部元素实现的动画 12345678910/* 初始和结束状态的样式 */.v-enter,.v-leave-to&#123; opacity: 0;&#125;/* 进入/离开 动画效果设置 */.v-enter-active,.v-leave-active&#123; transition: all 0.4s ease;&#125; 自定义动画效果 transition 的 name 属性控制前缀 12345678910.my-enter,.my-leave-to&#123; opacity: 0; transform: translateX(100px)&#125;.my-enter-active,.my-leave-active&#123; transition: all 0.4s ease;&#125; 展开收起效果 1234567891011121314151617&lt;!-- 设置初始和结束高度 --&gt;.div-enter,.div-leave-to &#123; max-height: 0; overflow: hidden;&#125;&lt;!-- 设置展开后高度 --&gt;.div-enter-to,.div-leave &#123; max-height: 2000px; overflow: hidden;&#125;&lt;!-- 动画效果 --&gt;.div-enter-active,.div-leave-active&#123; transition: all 0.4s linear;&#125; 动画流程 123 ENTER LEAVEv-enter | v-enter-to --- v-leave | v-leave-to v-enter-active v-leave-active 钩子函数动画 入场钩子函数事件绑定 动画元素初始状态， 此时动画还未执行 v-on: before-enter = &quot;beforeEnter&quot; 动画执行后元素的状态 v-on: enter = &quot;enter&quot; v-on: after-enter = &quot;afterEnter&quot; v-on: enter-cancelled = &quot;enterCancelled&quot; 出场钩子函数事件绑定 v-on: before-leave = &quot;beforeLeave&quot; v-on: leave = &quot;leave&quot; v-on: after-leave = &quot;afterLeave&quot; v-on: leave-cancelled = &quot;leaveCancelled&quot; html模板 1234567&lt;transition @before-enter="beforeEnter" @enter="enter" @after-enter="afterEnter"&gt; &lt;div class="ball" v-show="flag"&gt;&lt;/div&gt; &lt;/transition&gt; 实例 12345678910111213141516171819202122232425let vm = new Vue(&#123; el: "#app", data: &#123; flag: false, &#125;, // 动画钩子函数的第一个参数 表示要执行动画的那个 DOM 元素 methods: &#123; beforeEnter(el) &#123; el.style.transform = "translate(0, 0)" &#125;, enter(el, done) &#123; // 没有实际作用, 如果不写 动画效果显示不出来 // 可以认为 el.offsetTop 会强制动画刷新 el.offsetTop el.style.transform = "translate(150px, 450px)" el.style.transition = "all 1s ease" // done 就是 afterEnter 函数的引用, 表示动画完成立即执行 动画结束的函数 // 使用 js 钩子函数动画 done 是必须的 done() &#125;, afterEnter(el) &#123; this.flag = !this.flag &#125; &#125;&#125;) 列表动画效果 html 如果是v-for渲染出来的多个元素, 实现动画需要用transition-group包裹 如果要为v-for循环创建的元素设置动画, 必须为每一个元素绑定key属性 appear实现页面载入入场效果 tag指定transition渲染成的HTML元素, 如果不指定默认渲染为span元素 123&lt;transition-group appear tag="div"&gt; &lt;p v-for="(item, i) in list" :key="item.id" @click="del(i)"&gt; &#123; &#123; item.id &#125; &#125; ++ &#123; &#123; item.name &#125; &#125; &lt;/p&gt;&lt;/transition-group&gt; css 1234567891011121314151617.v-enter,.v-leave-to&#123; opacity: 0; transform: translateY(80px)&#125;.v-enter-active,.v-leave-active&#123; transition: all 0.6s ease;&#125;/* .v-move 和 .v-leave-active 可以实现列表元素后续移动的动画效果 */.v-move&#123; transition: all 0.6s ease;&#125;.v-leave-active&#123; position: absolute;&#125; 组件化 什么是组件: 组件是为了拆分 Vue 实例的代码量, 能够让我们以不同组件来划分不同的功能模块 将来我们需要什么样的功能就可以去调用对应的组件即可 模块化: 从代码逻辑的角度进行划分 方便代码分层开发, 保证每一个功能模块的职能单一 组件化: 从UI界面的角度进行划分 前端的组件化, 方便UI组件的复用 使用组件 要使用组件直接把组件的名称 以 HTML 标签的形式引入页面 如果使用驼峰命名法则需要在引用的时候把字母改为小写单词间用-连接 使用Vue.component(&quot;组件的名称&quot;, 创建出来的组件模版对象) 全局组件 12345Vue.component("myComponent", Vue.extend(&#123; // 使用 Vue.extend 来创建全局的 Vue 组件 // 通过 template 属性来指定组件展示的HTML结构 template: "&lt;h1&gt;这是使用 Vue.extend 创建的组件&lt;/h1&gt;"&#125;)) 全局简写 12345678910111213141516171819// 简写1Vue.component("mycom", &#123; template: "&lt;h1&gt;简写形式 + &#123; &#123; msg &#125; &#125; &lt;/h1&gt;", // 组件自己的 data 是一个函数 必须返回一个对象 data() &#123; return &#123; msg: "这是组件的msg", &#125; &#125;, methods: &#123; &#125;&#125;)// 简写2Vue.component("mycom2", &#123; // 模板写在html里, 使用 template包裹 id标识 // &lt;template id="tmp"&gt; 模板 &lt;/template&gt; template: "#tmp"&#125;) 私有组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647let vm = new Vue(&#123; el: '#app', data: &#123; //自定义私有数据 &#125;, methods: &#123; //自定义私有方法 &#125;, filters: &#123; //自定义私有过滤器 &#125;, directives: &#123; //自定义私有指令 &#125;, components: &#123; //自定义私有组件 myCom: &#123; template: "&lt;h1&gt;私有组件&lt;/h1&gt;" &#125; &#125;, //生命周期钩子函数 beforeCreate() &#123; //Vue实例创建之前 &#125;, created() &#123; //数据初始化完成 &#125;, beforeMount() &#123; //模版渲染前, 已编译完成 &#125;, mounted() &#123; //模版渲染完成, Vue实例创建完毕 &#125;, beforeUpdate() &#123; // data 数据更新, 页面未同步 &#125;, updated() &#123; // 页面同步 data 数据 &#125;, beforeDestroy() &#123; // Vue实例销毁之前, 数据还可用 &#125;, destroyed() &#123; // Vue实例完全销毁, 不可用 &#125;,&#125;) 组件切换 Vue提供了component来展示对应名称的组件 component是一个占位符is属性可以用来指定要展示的组件名称 切换动画效果: 通过mode属性来设置组件切换模式 123&lt;transition mode="out-in"&gt; &lt;component :is="flag"&gt;&lt;/component&gt;&lt;/transition&gt; 123456789.v-enter,.v-leave-to&#123; opacity: 0; transform: translateX(100px)&#125;.v-enter-active,.v-leave-active&#123; transition: all 0.3s ease;&#125; propsprops 主要用于父组件向子组件传递数据 父组件可以在引用子组件的时候, 通过属性绑定:的形式将数据传入子组件 1&lt;myCom :parent="msg" @fun="show"&gt;子组件&lt;/myCom&gt; 实例 123456789101112131415161718192021222324252627282930313233let vm = new Vue(&#123; el: '#app', data: &#123; msg: "父组件的私有数据" &#125;, methods: &#123; show(arg) &#123; console.log("父组件方法调用! data:" + arg) &#125; &#125;, components: &#123; myCom: &#123; // 子组件里的私有数据 data() &#123; // 子组件 data 需要 return 一个对象 return &#123; msg: "子组件私有数据" &#125; &#125;, template: "#tem", // 使用父组件传入的数据 需要在 props 数组里定义该属性才能使用 // props 里的数据是父组件传入的 , 只读 props: ["parent"], methods: &#123; // 子组件私有方法 childFun() &#123; // 使用 this.$emit() 方法来调用 父组件传入的方法 , 实参从第二个位置开始 this.$emit("fun", "arg") &#125; &#125; &#125; &#125;&#125;) 自定义事件 自定义事件: 主要用于子组件向父组件传递数据 每个Vue实例都实现了事件接口Events interface 使用vm.$on(eventName)监听当前实例上的自定义事件 使用vm.$emit(eventName)触发事件 1234vm.$on('test', function (msg) &#123; console.log(msg)&#125;)vm.$emit('test', 'hi') 命名约定: 因为html忽略大小写所以使用-命名法 数据传递: 子组件通过$emit可以触发事件 第一个参数为要触发的事件名称 第二个事件为要传递的数据 流程 子组触发事件调用事件函数 在事件函数中使用this.$emit (事件名, 参数)触发自定义事件 在父组件上设置监听子组件是否触发自定义事件 触发则调用响应函数 &lt;child @emitName=&quot;callBack()&quot;&gt;&lt;/child&gt; ref获取DOM元素 html 1&lt;test ref="myCOM"&gt;&lt;/test&gt; 相关属性 this.$refs.myCom 既是我们获取到的DOM元素 this.$refs.myCOM.$el.innerHTML 模板的innerHTML需要.$el this.$refs.myCOM.xxx 模板的数据/方法可以直接使用 计算属性在computed中可以定义一些属性, 这些属性叫做计算属性 计算属性的本质就是一个方法, 我们在使用这些计算属性的时候把它们的名称直接当做属性来使用 计算属性使用的时候不要加(), 只要计算属性内部的数据发生了变化 计算属性就会立即重新计算 计算属性的求值结果会被缓存起来, 之后可直接使用, 只有数据变化时才会调用该函数重新计算 将计算属性配置为一个对象, 使其可以双向计算 12345678910111213fullName: &#123; // get方法 在获取属性值的时候回调 get() &#123; return this.firstName + this.lastName &#125;, // set方法 在属性值发生改变的时候回调, 更新相关的属性数据 set(value) &#123; // value 就是 fullName 修改后的值 const arr = value.split(" ") this.firstName = arr[0] this.lastName = arr[1] &#125;&#125; watch监视watch这个属性可以监视data中的数据变化 , 当数据变化时触发相应回调函数 123456789101112watch: &#123; // 监视属性名 如果有 - 则需要用 "" 包裹 // watch 回调函数不能使用箭头函数 watchName: function (newVal, oldVal) &#123; console.log (newVal, oldVal) &#125;, // 它主要用来监视 路由地址 的变化 "$route.path": function (value) &#123; // $route对象里保存有当前路由对象的信息 console.console.log(this.$route) &#125;&#125; deep: true 深度监视对象内部数据变化 (数组不需要深度监视) 为数据绑定的对象 添加新属性 需要使用Vue.set(object, key, value) 通过watch + this.$nextTick(callback)确保在异步完成, DOM更新后执行回调函数 solt插槽 作用 主要用于复用较多的组件, slot占位的位置有对应插入则显示没有则忽略 传递的是制作好的标签, props和自定义事件传递数据 使用流程 子组件写slot标签占位, 用name属性标识 1234&lt;div&gt; &lt;slot name="text1"&gt;&lt;/slot&gt; &lt;slot name="text2"&gt;&lt;/slot&gt;&lt;/div&gt; 父组件中写好替换标签插入子组件中替换对应内容 子组件不能用自结束标签 替换标签的slot属性与name对应 123456&lt;template id="parent"&gt; &lt;child&gt; &lt;span slot="text1"&gt;&lt;/span&gt; &lt;span slot="text2"&gt;&lt;/span&gt; &lt;/child&gt;&lt;/template&gt; 原理分析数据代理 数据代理: 通过一个对象代理对另一个对象中属性的操作(读/写) Vue数据代理: 通过vm实例来代理data中所有的属性 好处: 方便操作data中的数据 实现: 通过Object.defineProperty()给vm添加与data的属性对应的属性描述符 所有添加的属性都包含getter/setter 在getter/setter内部去操作data中对应的属性数据 模块解析 模板解析基本流程: 将el的所有子节点取出, 添加到一个新建的fragment对象中 对fragment中的所有层次的子节点递归进行编译解析处理 对插值表达式{ { } }文本节点进行解析 对元素节点的指令属性进行解析 对事件指令解析 一般指令解析 将解析后的 fragment 插入 el 中显示到页面上 插值表达式解析: 根据正则对象得到匹配出的表达式字符串 从data中取出表达式对应的属性值 将属性值设置为文本节点的textContent 事件指令解析: 从指令名中取出事件名 根据指令的值(表达式)从methods里取出对应的事件处理函数 给当前元素节点绑定指定事件名和回调函数的dom事件监听 (bind绑定this) 指令解析完毕后移除指令属性 一般指令解析: 得到指令名和指令值(表达式) 从data中根据表达式得到对应的值 根据指令名确定需要操作元素节点的什么属性 v-text ==&gt; textContent v-html ==&gt; innerHTML v-class ==&gt; class 将得到的表达式的值设置到对应的属性上 移除元素的指令属性 数据绑定 数据绑定: 一旦更新了data中的某个属性数据, 界面上跟该属性相关的节点都会跟着更新 数据劫持: 数据劫持是 Vue 中用来实现数据绑定的一种技术 基本思路: 通过defineProperty()来监视data中所有属性(任意层次)数据的变化, 一旦变化就去更新界面 数据代理是在vm实例上添加data中数据的getter和setter 数据绑定是在data里给每个数据添加getter和setter 流程: vm.name = &quot;newStr&quot; data中的name属性值变化 name属性的set()函数调用 Dep 相关的所有Watcher 调用更新界面的回调函数 Dep与Wathcer之间的关系: 多对多 name属性 ==&gt; 一个Dep ==&gt; n个Watcher (name属性在模板中使用了n次) 表达式 ==&gt; 一个Watcher ==&gt; n个Dep (多层表达式n层, 例如: item.info.name) 如何建立关系: 在data中的属性的get()中建立 什么时候建立关系: 初始化解析模块中的表达式创建Watcher对象时建立关系 双向数据绑定: 建立在单向数据绑定的基础上 双向数据绑定的实现流程: 在解析v-model指令时, 给当前元素添加input监听 当input的value发生改变时, 将最新的值赋值给当前表达式所对应的data属性 data属性改变从而触发 model ==&gt; View 页面更新 原理代码注释注: 代码来源与Github本人只是根据自己的理解进行注释 mvvm12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function MVVM(options) &#123; // MVVM 是一个构造函数, this 指向它 new 出来的实例 // 配置对象默认值 &#123;&#125; 并将其保存在实例的 $options 属性上 this.$options = options || &#123;&#125;; // 保存 data 和 this var data = this._data = this.$options.data; var me = this; // 数据代理 // 实现 vm.xxx -&gt; vm._data.xxx // Object.keys(data) 返回包含data对象上所有可枚举属性名的数组 // arr.forEach(callback(value, index, arr)) 遍历数组 依次取出 数组中的每个元素 来执行回调函数 Object.keys(data).forEach(function(key) &#123; // 对该属性实现 数据代理 me._proxyData(key); &#125;); // 实现计算属性 this._initComputed(); // 对data中所有层次的属性通过数据劫持实现数据绑定 observe(data, this); // new 一个编译对象, 解析模板 this.$compile = new Compile(options.el || document.body, this)&#125;MVVM.prototype = &#123; $watch: function(key, cb, options) &#123; new Watcher(this, key, cb); &#125;, _proxyData: function(key, setter, getter) &#123; var me = this; setter = setter || // Object.defineProperty(要操作的对象, 需要操作的属性名, 属性描述符&#123;&#125;) // 给vm实例对象添加 data上的属性的描述符 Object.defineProperty(me, key, &#123; // 是否可以重新定义 configurable: false, // 是否可以枚举 enumerable: true, // 动态计算 该属性的值 get: function proxyGetter() &#123; return me._data[key]; &#125;, // 该属性被修改时触发的回调函数, 修改值作为实参传入 set: function proxySetter(newVal) &#123; me._data[key] = newVal; &#125; &#125;); &#125;, _initComputed: function() &#123; var me = this; var computed = this.$options.computed; if (typeof computed === 'object') &#123; Object.keys(computed).forEach(function(key) &#123; Object.defineProperty(me, key, &#123; get: typeof computed[key] === 'function' ? computed[key] : computed[key].get, set: function() &#123;&#125; &#125;); &#125;); &#125; &#125;&#125;; compile123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239function Compile(el, vm) &#123; // Compile实例的$vm属性保存 vm实例对象 this.$vm = vm; // 对el参数进行判断是元素节点还是css选择器, 将对应的元素节点保存到 Compile实例的 $el 中 this.$el = this.isElementNode(el) ? el : document.querySelector(el); // 如果 $el 属性不为空 执行以下语句 if (this.$el) &#123; // 将 el 中的所有子节点转移到 $fragment 中 this.$fragment = this.node2Fragment(this.$el); // 调用初始化函数 编译 $fragment 中所有层次的子节点 this.init(); // 将编译好的模板 插入 el 标签中 使其显示到页面上 this.$el.appendChild(this.$fragment); &#125;&#125;Compile.prototype = &#123; node2Fragment: function(el) &#123; // 新建一个 fragment 并将其作为最终返回结果 // DocumentFragment 是Node接口的实现. document element等都是 Node接口的实现(Node节点) // documnet: 对应html页面, 包含多个element, 只要其中某一个element更新 页面就会跟着更新 // DocumentFragment: 内存中保存多个element的容器对象(不显示在页面上, 内存中的DOM树) var fragment = document.createDocumentFragment(); var child; // 将原生el节点所有的子节点依次移动到内存中的DocumentFragment容器中 // 先赋值再判断, 只要 child 不为空就一直循环执行 while (child = el.firstChild) &#123; // 因为一个元素节点只能有一个父节点 // 将 child 添加到 fragment 节点下时, 会先将该元素从原来的父节点中移除 fragment.appendChild(child); &#125; // 返回 内存中的 DocumentFragment容器 return fragment; &#125;, init: function() &#123; // 对 $fragment 进行编译 this.compileElement(this.$fragment); &#125;, compileElement: function(el) &#123; // 将 $fragment 中的所有子节点保存到一个伪数组childNodes中 var childNodes = el.childNodes; var me = this; // 指定childNodes伪数组去调用数组的slice方法,返回childNodes的真数组, 再调用数组的forEach方法进行遍历 [].slice.call(childNodes).forEach(function(node) &#123; // text 为遍历 node 的文本内容 var text = node.textContent; // reg 为匹配 &#123; &#123; &#125; &#125; 的正则表达式 // ()子匹配, 括号内的内容保存 在RegExp.$1~n中 var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/; // 如果该节点是元素节点 if (me.isElementNode(node)) &#123; // 则编译元素节点的指令 me.compile(node); // 如果该节点是文本节点 并且符合正则表达式 &#125; else if (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123; // 则编译 &#123; &#123; &#125; &#125; 的文本节点 me.compileText(node, RegExp.$1); &#125; // 再判断 该节点是否还有子节点并且不为空 if (node.childNodes &amp;&amp; node.childNodes.length) &#123; // 则递归调用这个函数 深入编译该节点的子节点 me.compileElement(node); &#125; &#125;); &#125;, compile: function(node) &#123; // Element.attributes 属性返回该元素所有属性节点的伪数组 var nodeAttrs = node.attributes; var me = this; // 转换为真数组后 遍历所有的属性节点 [].slice.call(nodeAttrs).forEach(function(attr) &#123; // 保存属性名(v-on:click) var attrName = attr.name; // 判断该属性是否为指令属性 if (me.isDirective(attrName)) &#123; // 获取指令的值 (exp = show) var exp = attr.value; // 从下标2开始 截取指令名称(dir = on:click) var dir = attrName.substring(2); // 判断是否为事件指令 if (me.isEventDirective(dir)) &#123; // 在事件处理工具对象上找到处理函数 compileUtil.eventHandler(node, me.$vm, exp, dir); // 否则进入普通指令 &#125; else &#123; // 如果指令处理工具对象上有处理指令对应的方法 则调用该方法 compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp); &#125; // 将元素上的指令属性移除 node.removeAttribute(attrName); &#125; &#125;); &#125;, compileText: function(node, exp) &#123; // 使用指令处理结合中的text方法解析 // node 为文本节点 exp 为正则匹配到的 &#123; &#123; &#125; &#125; 中的内容 compileUtil.text(node, this.$vm, exp); &#125;, isDirective: function(attr) &#123; // 通过 'v-' 判断属性节点是否是指令属性 return attr.indexOf('v-') == 0; &#125;, isEventDirective: function(dir) &#123; // 通过 'on' 判断指令属性是否是事件指令 return dir.indexOf('on') === 0; &#125;, isElementNode: function(node) &#123; // 根据节点的nodeType判断节点是否为元素节点 return node.nodeType == 1; &#125;, isTextNode: function(node) &#123; return node.nodeType == 3; &#125;&#125;;// 包含多个指令处理方法的工具对象var compileUtil = &#123; text: function(node, vm, exp) &#123; this.bind(node, vm, exp, 'text'); &#125;, html: function(node, vm, exp) &#123; this.bind(node, vm, exp, 'html'); &#125;, // 解析 v-model 指令 model: function(node, vm, exp) &#123; // 实现初始化显示和创建对应watcher this.bind(node, vm, exp, 'model'); var me = this; // 得到表达式的值 var val = this._getVMVal(vm, exp); // 给节点绑定input监听 (输入时触发) node.addEventListener('input', function(e) &#123; // 得到输入的最新值 var newValue = e.target.value; // 如果没有变化则直接返回 if (val === newValue) &#123; return; &#125; // 将最新的值保存到表达式对应的data中的属性中 me._setVMVal(vm, exp, newValue); // 保存最新值 以便下次输入时验证 val = newValue; &#125;); &#125;, class: function(node, vm, exp) &#123; this.bind(node, vm, exp, 'class'); &#125;, // node 待操作的节点, vm MVVM的实例对象, exp &#123; &#123; &#125; &#125; 中的内容, dir 指令名称 bind: function(node, vm, exp, dir) &#123; // 拼接[ ]内的字符串 从而在 updataer 中找到对应指令操作的方法保存到 updaterFn 中 var updaterFn = updater[dir + 'Updater']; // &amp;&amp; 操作符 如果前面为 false 直接跳过, 如果都为 ture 则执行后面的语句 // 使用 node 节点 和 vm实例上找到的属性的值 调用上面保存的函数 updaterFn &amp;&amp; updaterFn(node, this._getVMVal(vm, exp)); // 为表达式创建一个对应的watcher, 实现节点的更新显示 new Watcher(vm, exp, function(value, oldValue) &#123; // 当表达式对应的一个属性值变化时 更新页面中的相关节点 updaterFn &amp;&amp; updaterFn(node, value, oldValue); &#125;); &#125;, // 事件处理 eventHandler: function(node, vm, exp, dir) &#123; // 用 : 分割指令字符串,取下标1部分 (click) var eventType = dir.split(':')[1]; // 如果 vm实例上 methods 不为空 则取出方法名为[show]的方法 保存在 fn 上 var fn = vm.$options.methods &amp;&amp; vm.$options.methods[exp]; // 如果指令和函数都存在 则绑定事件监听 if (eventType &amp;&amp; fn) &#123; // 指定 vm 调用 fn 函数, 与call apply不同的是 bind 绑定不会立即执行 node.addEventListener(eventType, fn.bind(vm), false); &#125; &#125;, // 在 vm 实例里取出对应数据的值 _getVMVal: function(vm, exp) &#123; var val = vm; // &#123; &#123; &#125; &#125; 中的内容可能存在 a.b.c 的写法 所以需要先拆分该字符串 exp = exp.split('.'); // 遍历拆分后的数组 exp.forEach(function(k) &#123; // 遍历完毕后 val 的值相当于 vm[a][b][c] val = val[k]; &#125;); // 返回最后找到的属性的值 return val; &#125;, _setVMVal: function(vm, exp, value) &#123; var val = vm; exp = exp.split('.'); exp.forEach(function(k, i) &#123; // 非最后一个key，更新val的值 if (i &lt; exp.length - 1) &#123; val = val[k]; &#125; else &#123; val[k] = value; &#125; &#125;); &#125;&#125;;// 更节点的方法对象var updater = &#123; // 用找到的属性值替换节点的文本内容 textUpdater: function(node, value) &#123; // 如果值为 undefined 则显示为 '' node.textContent = typeof value == 'undefined' ? '' : value; &#125;, // 用找到的属性值替换节点的 innerHTML htmlUpdater: function(node, value) &#123; node.innerHTML = typeof value == 'undefined' ? '' : value; &#125;, // 用找到的属性值替换节点的 class classUpdater: function(node, value, oldValue) &#123; // 先取出原有的 class 保存 var className = node.className; // 用空串替换掉 undefined 和 结尾的空格 className = className.replace(oldValue, '').replace(/\s$/, ''); // 根据 原本的class 和 表达式的class 决定是否需要空格 var space = className &amp;&amp; String(value) ? ' ' : ''; // 给节点设置新的 class 值 node.className = className + space + value; &#125;, modelUpdater: function(node, value, oldValue) &#123; node.value = typeof value == 'undefined' ? '' : value; &#125;&#125;; observer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103function Observer(data) &#123; // 将 data 保存在实例的data属性中 this.data = data; // 调用该构造函数的walk方法, 开始监视data this.walk(data);&#125;Observer.prototype = &#123; // 传入 data对象 walk: function(data) &#123; // 保存 observer对象 var me = this; // 取出data中所有的属性名组成一个数组,然后遍历 Object.keys(data).forEach(function(key) &#123; // 使用遍历出的 属性名 和 属性值 调用 转换方法 me.convert(key, data[key]); &#125;); &#125;, convert: function(key, val) &#123; // 对指定数据实现响应式数据绑定 this.defineReactive(this.data, key, val); &#125;, // 实现数据绑定 (data对象, 对象里数据的key 和 value) defineReactive: function(data, key, val) &#123; // 创建属性对应的 dep (dependency依赖) var dep = new Dep(); // 间接递归调用实现对data中的数据的所有层次的属性进行数据绑定 var childObj = observe(val); // 给 data 对象重新定义当前属性 (为了给这个属性添加 get 和 set) Object.defineProperty(data, key, &#123; enumerable: true, // 可枚举 configurable: false, // 不能再重新定义 get: function() &#123; if (Dep.target) &#123; // 建立关系 dep.depend(); &#125; // 返回值 return val; &#125;, // set 监视属性的变化 然后更新界面 set: function(newVal) &#123; if (newVal === val) &#123; return; &#125; val = newVal; // 新的值是object的话，进行监听 childObj = observe(newVal); // 通知所有相关的订阅者(watcher) dep.notify(); &#125; &#125;); &#125;&#125;;// 传入 data对象 和 vm实例对象function observe(value, vm) &#123; // 判断data对象是否存在, 类型是否为对象 (被观察的必须是一个对象) if (!value || typeof value !== 'object') &#123; return; &#125; // 返回 data 对象传入Observer构造函数 生成的实例对象 (创建观察者) return new Observer(value);&#125;;var uid = 0;// 1. 创建时机: 初始化 data 的属性进行数据劫持时创建的// 2. 数量: 与 data 中的属性一一对应function Dep() &#123; // Dep里面有一个唯一id this.id = uid++; // 订阅者容器数组(里面存的Watcher) this.subs = [];&#125;Dep.prototype = &#123; addSub: function(sub) &#123; // 添加 watcher到 dep 中 this.subs.push(sub); &#125;, depend: function() &#123; // 建立 dep 与 watcher 之间的关系 Dep.target.addDep(this); &#125;, removeSub: function(sub) &#123; var index = this.subs.indexOf(sub); if (index != -1) &#123; this.subs.splice(index, 1); &#125; &#125;, notify: function() &#123; // 遍历所有的 watcher 通知它更新 this.subs.forEach(function(sub) &#123; sub.update(); &#125;); &#125;&#125;;Dep.target = null; watcher1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 1. 创建时机: 初始化的解析大括号表达式/一般指令// 2. 数量: 与模板中 表达式数量一一对应 (不包含事件指令)function Watcher(vm, expOrFn, cb) &#123; // cb 更新界面的回调函数 this.cb = cb; // vm 实例对象 this.vm = vm; // expOrFn 插值表达式的值 this.expOrFn = expOrFn; // 包含多个相关 Dep 的容器对象 this.depIds = &#123;&#125;; // 判断 插值表达式的类型 if (typeof expOrFn === 'function') &#123; this.getter = expOrFn; &#125; else &#123; this.getter = this.parseGetter(expOrFn); &#125; // 得到表达式的初始值保存 this.value = this.get();&#125;Watcher.prototype = &#123; update: function() &#123; this.run(); &#125;, run: function() &#123; var value = this.get(); var oldVal = this.value; if (value !== oldVal) &#123; this.value = value; // 调用回调函数 更新界面 this.cb.call(this.vm, value, oldVal); &#125; &#125;, addDep: function(dep) &#123; // 根据pep的ID在depIds里是否存在 来判断关系是否已经建立 if (!this.depIds.hasOwnProperty(dep.id)) &#123; // 将watcher添加到dep中去 (用于更新) dep.addSub(this); // 根据dep的id在watcher里保存dep (用于防止反复建立关系) this.depIds[dep.id] = dep; &#125; &#125;, get: function() &#123; // 给dep指定当前的watcher Dep.target = this; // 获取表达式的值, 内部调用get建立dep与watcher的关系 var value = this.getter.call(this.vm, this.vm); // 出去dep中指定的当前watcher Dep.target = null; return value; &#125;, parseGetter: function(exp) &#123; if (/[^\w.$]/.test(exp)) return; var exps = exp.split('.'); return function(obj) &#123; for (var i = 0, len = exps.length; i &lt; len; i++) &#123; if (!obj) return; obj = obj[exps[i]]; &#125; return obj; &#125; &#125;&#125;; @vue/clinpm install -g @vue/cli 安装 vue create hello-world 新建项目 npm install 安装依赖 npm run serve 开发环境运行 (在内存中 编译 打包 运行) npm run build 生产环境打包 npm run lint 一键格式化 快速原型开发 使用vue serve和vue build命令对单个*.vue文件进行快速原型开发 Vuex Vuex 是什么 简单来说就是对Vue应用中多个组件的共享状态进行集中式的管理 (读/写) 它采用集中式存储管理应用的所有组件的状态 并以相应的规则保证状态以一种可预测的方式发生变化 状态自管理应用 state: 驱动应用的数据源 (data) view: 以声明方式将state映射到视图 actions: 响应在view上用户驶入导致的状态变化(包n个更新状态的方法) 多组件共享状态的问题 多个视图依赖同一状态 来自不同视图的行为需要变更同一状态 以前的办法: 将数据以及操作数据的行为都定义在父组件 将其传递给需要的各个子组件 (可能需要多级传递) vuex就是用来解决这些问题 vuex API state: vuex管理的状态对象 (对象, 唯一) mutations: 包含多个直接更新state的方法(回调函数)的对象 在action使用commit(mutation名称)触发 只能包含同步的代码, 不能异步 actions: 包含多个事件回调函数的对象 在实例中通过this.$store.dispatch(&#39;actionName&#39;, &#39;参数&#39;)分发调用action 通过执行commit()来触发mutation的调用间接更新state 异步代码在此执行 getters: 包含多个计算属性(get)的对象 使用方法this.$store.getters.xxx getter计算属性 第一个参数为state modules: 包含多个module 一个module是一个store的配置对象 与一个组件(包含有共享数据)对应 使用: Vue.use(Vuex) 使用插件 配置对象 1234567891011121314151617181920212223242526272829303132// 对应dataconst state = &#123; count: 0, msg: 'test'&#125;// 对应methodsconst mutations = &#123; [MUTATIONSNAME1] (state) &#123; state.count++ &#125;, [MUTATIONSNAME2] (state) &#123; state.count-- &#125;&#125;// 用 $store.dipatch()分发 action// 用 &#123;commit&#125; 来调用对应的 mutation()const actions = &#123; // 可以使用 state 里面的数据 // 可以直接写异步代码 increment (&#123;commit, state&#125;) &#123; commit('INCREMENT', 'mutation的实参') &#125;&#125;// 对应Vue中的computedconst getters = &#123; evenShow (state) &#123; return 'vuex自动寻找state' + state.msg &#125; &#125; 暴露 store 对象 123456export default new Vuex.Store(&#123; state, //初始状态 mutations, //包含多个更新state函数的对象 actions, //包含多个事件回调函数的对象 getters //包含多个getter计算属性函数的对象&#125;) 在实例中映射store 123new Vue(&#123; store&#125;) vue-router 后端路由 对于普通网站所有的超链接都是URL地址, 所有的URL地址在服务器上有对应的资源 前端路由 对于单页应用来说, 主要通过URL中的hash (#)来实现不同页面之间的切换 同时hash有一个特点http请求中不会包含hash相关内容 所以单页应用中的页面跳转主要用hash来实现切换页面的方式叫做前端路由 $router: 路由器对象, 包含一些操作路由的功能函数, 来实现编程式导航(跳转路由) $route: 当前路由对象, 一些当前路由信息数据的容器(path/meta/query/params) 路由传参: 在路由中使用 查询字符串 不影响路由匹配 query查询: ?开始 &amp;连接多个查询内容 参数保存在$router.query params查询: 在路由路径中提前用:占位 参数保存在$route.params html 12345678910&lt;!-- vue-router 提供的组件展示的占位符 --&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;!-- router-link 默认渲染为一个 a 标签 --&gt;&lt;!-- router-link 上加点击事件 @click.native --&gt;&lt;!-- 在路由地址相对的位置写入的参数 就能传递给提前配置好的占位符 --&gt;&lt;!-- 也可以使用 tag 设置标签 replace设置替换跳转--&gt;&lt;router-link to="/login/lululu" replace&gt;登录&lt;/router-link&gt;&lt;router-link to="/reg?id=10&amp;name=test" tag="span"&gt;注册&lt;/router-link&gt; 路由组件懒加载 引入方法 const componentName = () =&gt; import(&#39;路径&#39;) 创建一个路由对象 123456789101112131415let routerObj = new VueRouter(&#123; // 配置对象中的 route 表示 路由匹配规则 routes: [ // path: 表示监听的路由地址 // component: 表示该地址需要展示的组件 (里面放的是组件模板对象, 不能放模板名称) // redirect 重定向 用重定向地址替换 path 地址 &#123;path: "/", redirect: "/login"&#125;, // 路由params查询 // 使用 :xxx 来占位, 由 $route.params.xxx 接收路由上该位置的字符串 &#123;path: "/login/:xxx", component: login&#125;, &#123;path: "/reg", component: reg&#125;, ], // 自定义 激活组件的 class 类名 linkActiveClass: "myclass"&#125;) 映射到实例 123new Vue(&#123; router: routerObj&#125;) 路由嵌套 123456&lt;!-- 命名视图 default --&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;!-- 匹配命名视图里的配置 --&gt;&lt;router-view name="leftView"&gt;&lt;/router-view&gt;&lt;router-view name="mainView"&gt;&lt;/router-view&gt; 123456789101112131415161718192021222324252627282930313233let router = new VueRouter(&#123; routes: [ &#123; path: "/", // components 配置命名视图(注意有s) // 属性名是标签中的 name标识 // 属性值对应显示的模板名称 components: &#123; default: head, leftView: left, mainView: main &#125; &#125;, // 常规路由 component 后面不加s &#123; path: "/children", component: children &#125;, // 嵌套路由 在 children : [] 里配置子路由 &#123; path: "/main", component: main, children: [ &#123; // 子路由嵌套 path 不加 / // / 代表根路径 path: "children", component: children &#125; ] &#125; ]&#125;) axios123456789101112131415161718192021222324252627282930import axios from 'axios';export default function ajax(data = &#123;&#125;, url, type) &#123; return new Promise(function(resolve, reject) &#123; let promise; if (type === 'GET') &#123; let dataStr = ''; Object.keys(data).forEach(key =&gt; &#123; dataStr += key + '=' + data[key] + '&amp;'; &#125;); if (dataStr !== '') &#123; dataStr = dataStr.substring(0, dataStr.lastIndexOf('&amp;')); url = url + '?' + dataStr; &#125; promise = axios.get(url); &#125; else &#123; // 设置 content-type 解决 options 问题 promise = axios(&#123; method: 'post', url: url, data: data, headers: &#123;'Content-Type': 'application/x-www-form-urlencoded'&#125;, &#125;); &#125; promise.then(response =&gt; &#123; resolve(response.data); &#125;).catch(error =&gt; &#123; reject(error); &#125;); &#125;);&#125; UI组件库 Mint UI 饿了么开源移动端UI组件库 Elment 饿了么开源PC端UI组件库 引入需要的组件 import {Button, Toast} from &#39;mint-ui&#39; 注册成标签 (全局注册, 所有组件都能使用) Vue.component(&#39;标签名&#39;, 模板) vue-lazyload npm install --save vue-lazyload 使用v-lazy指令代替src指定路径, 可使图片懒加载 123456import VueLazyload from 'vue-lazyload'// 内部自定义一个指令 v-lazyVue.use(VueLazyload, &#123; // 图片加载时显示图片 loading: 'dist/loading.gif'&#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript笔记]]></title>
    <url>%2F2018%2F09%2F12%2FJavaScript%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JavaScriptJS 规范 空格 逗号 前不加空格 , 后加空格 关键词 1234if () &#123; // 关键字后面加空格 // &#123; 之前加空格&#125; 对象 123ojb = &#123; a: "前不加空格 : 后加空格"&#125; 函数 1234function() &#123; //函数的 () 前不加空格 arguments[] = "函数的[]也不加空格"&#125; 运算符处换行时, 运算符必须在新行的行首 变量: 使用驼峰命名法 常量全部使用字母大写, 单词间下划线分隔 构造函数(类)单词首字母大写 命名: 类名 使用名词 函数名 使用动宾短语 布尔值 使用 is 或 has 开头 Promise对象 使用动宾短语的进行时表达 类型检测: 优先使用typeof 对象类型检测使用instanceof null或undefined的检测使用 == null 字符串: JS内使用&#39;&#39; 字符串内使用&quot;&quot; 新建: 使用字面量 对象 = {} 数组 = [] 事件: 优先使用addEventListener绑定事件, 第三个参数使用false(冒泡时触发) HelloWorld JS中严格区分大小写 JS中每条语句以;结尾 也可以不加; 注意当语句以()或[]开头时则需要在前面加上; JS中会忽略多个空格和换行 我们以空格和缩进对代码进行格式化 123alert("弹出警告窗口")document.write("页面中写入内容")console.log("在控制台输出") 123&lt;!--不建议这样写!他们属于结构与行为耦合,不方便维护--&gt;&lt;button onclick="alert('JS代码可以编写到按钮的onclick事件中')"&gt;test&lt;/button&gt;&lt;a href="javascript:alert('JS代码编写到超链接href属性中')"&gt;test&lt;/a&gt; 字面量和变量 常量: 都是一些不可改变的值 常量都可以直接使用 变量: 变量的值是可以任意改变的 声明变量: 在es5中使用var关键字来声明一个变量 var a 为变量赋值 a = 123 声明+赋值 var a = 456 标识符: 在JS中所有可以由我们自主命名的都可以称为标识符 命名规则: 可以包含字母 数字 _ $ 不能以数字开头 不能是ES中的关键字和保留字 驼峰命名法 JS底层保存标识符实际上是用的unicode编码, 理论上所有utf-8中的所有内容都可以当作标识符 数据类型 在es5中只有6种数据类型 基本数据类型 String 字符串 Number 数值 Boolean 布尔值 Null 空值 Undefined 未定义 引用数据类型 Object 对象 只要不是基本数据类型的都是对象 特殊对象: Function 封装可执行代码, 并可以调用执行 Array 使用索引有序的保存数据 判断方法 typeof 注意返回数据类型的字符串表达,所以对比时要加&#39;&#39; 该方法不能用来判断null object function instanceof 判断a是否是b的实例,判断对象的具体类型,返回布尔值 === 三等会先判断数据类型, 双等则不会判断数据类型直接比较值 类型详情 String 字符串 在JS中字符串需要用引号引起来 引号或双引号都行, 但是不能混用 在字符串中用\作为转义符\n换行 Number 数值 JS中所有数值都是Number类型 包括整数和浮点数(小数) Number.MAX_VALUE表示JS中的最大数值 Number.MIN_VALUE表示JS中最小的小数 超过最大值Infinity表示正无穷 NaN 特殊数字 Not A Number 使用JS进行浮点数计算 会得到一个不精确的结果 12var a = 0.1 + 0.2;0.30000000000000004 Boolean 布尔值: true 真 false 假 Null 空值 表示: 定义了,并且值为空&#39;&#39; null空的对象 所以typeof null返回&#39;Object&#39; 初始值为null表示该变量是个对象 对象不再使用时, 赋值null可使浏览器对其进行垃圾回收 Undefined 未定义: 未定义类型,其实就是没赋值的意思 当声明一个变量但未赋值时, 变量的值就是 undefined 变量的类型 基本类型: 保存的是在栈内存中的基本类型数据 引用类型: 是在栈内存中保存对象在堆能存中的储存地址 JS在调用函数时传递变量参数时是引用传递(基本数值/引用地址) 注意函数的形参是新建一个局部变量, 并复制实参的数值或者引用地址(浅拷贝) 强制类型转换 转换String 调用被转换数据类型的toString()方法 a.toString() 该方法不会影响原变量, 它会将转换结果返回 null和undefined没有toString方法, 调用会报错 调用String()函数 调用函数String(a)将被转换的数据作为参数传递给函数 该方法也不会影响变量, 也是将结果返回 对于Number和Boolean实际上还是调用的toString()方法 对于null和undefined则不会调用toString()方法, 直接转换 简便方法: + &#39;&#39; 转换Number 调用Number()函数 字符串 ==&gt; 数字 纯数字直接转 有非数字转为NaN 空字符串或空格转换为0 布尔值 ==&gt; 数字 true == 1 false == 0 null == 0 undefined NaN parse方法: parseInt() 把字符串转换为一个整数 取出字符串中的连续数字,从左往右 遇到非数字立即结束 parseFloat() 把字符串转为浮点数 对非String使用为NaN 简便方法: + 转换Boolean 使用Boolean()函数 数字 ==&gt; 布尔: 除了0和NaN是false其余为true 字符串 ==&gt;布尔: 除了空串是false其余为true null和undefined都是false 任何对象都为true包括空对象/空数组 简便方法: !! 算数运算符运算符也叫操作符, 通过运算符可以对一个值或多个值进行运算, 并获取结果 比如typeof就是运算符, 用来获取一个值的类型 算术运算符 +加法: 对非Number运算会先转换城Number再进行运算 任何值和字符串相加都会转换成字符串再进行拼串 数字 + NaN = NaN / 数字 + null = 0 -:减法 *:乘法 /:除法 %:取模 String会转换为Number再进行计算 一元运算符 +正号 -负号(取反) 自增 / 自减 ++: 原变量会立刻在原来得基础上自增1 自增分两种i++ / ++i 无论哪种都会立即使 原变量 +1 不同的是表达式 i++显示原值 ++i显示+值 自减分两种i-- / --i 无论哪种都会立即使 原变量 -1 不同的是表达式i--显示原值 --i显示-值 逻辑运算符 !非: 布尔值取反 &amp;&amp;与: 两边都满足 如果第一个值为false则不会检查第二个值 ||或: 两边只需要满足一边 如果第一个值为true则不会检查第二个值 var a = a||0 设置默认值 非布尔值运算: &amp;&amp;: 优先返回false` ||: 优先返回true 赋值运算 =赋值: 将等号右边的原始值或引用地址赋值给左边的变量 ==相等运算: 对于非数值情况 会先转换成数字 然后再比较 任何值和NaN比较都是false 如果符号两边都是字符串则不会转换数字, 直接比较unicode编码 !=: 不全等运算, 会转换成同一数据类型再比较 ===全等: 先比较类型, 如果类型不同直接返回false 注意: 比较时需要注意数据是字符串数字还是数值 !==: 全不等, 如果数据类型相同直接返回 false +=加等: a += b 等同于 a = a + b 条件运算符条件运算符也叫三元运算符 条件表达式 ? 语句1 : 语句2 执行流程: 条件运算符在执行时, 首先对条件表达式求值 如果为true执行语句1返回结果 如果为false执行语句2返回结果 ,运算符 可以分割多个语句, 一般可以在声明多个变量时使用 流程控制语句 流程控制语句分类 条件判断语句 .条件分支语句 循环语句 条件判断语句 使用条件判断语句可以在执行某个语句前进行判断 如果条件成立才会执行语句, 条件不成立则不执行 123456789if (条件表达式) &#123; 语句...&#125; else if (条件表达式) &#123; 语句...&#125; else if (条件表达式) &#123; 语句...&#125; else &#123; 语句...&#125; 该语句从上到下依次对条件表达式求值判断 如果为true则执行当前语句 如果为false则继续向下判断 该语句中只有一个代码块会被执行 一旦代码块执行了则直接结束语句, 不会向下判断 条件分支语句 也叫 switch 语句 1234567891011switch (条件表达式) &#123; case 表达式: 语句... break; case 表达式: 语句... break; default: 语句... break;&#125; 在执行时会依次将switch的条件表达式的值和case的表达式值进行全等比较 如果结果为true则执行该case后面的语句 如果结果为false则继续向下比较 如果所有结果都为false则执行default后的语句 循环语句 while循环 通过循环语句可以反复的执行一段代码多次 123while (条件表达式) &#123; 语句...&#125; while语句在执行时先对条件表达式求值判断 如果结果为true则执行语句 执行完毕后再次回到判断 当结果为false则终止循环 可以用break来终止循环 1.初始化一个变量var i=0 2.在循环中设置一个条件表达式i&lt;10 3.定义一个表达式更新i++ do…while循环 123do &#123; 语句...&#125; while (条件表达式); 区别: while先判断后执行do...while先执行后判断, 至少执行一次 for循环 123for (初始化表达式; 条件表达式; 更新表达式) &#123; 语句...&#125; 初始化表达式 执行条件表达式判断 每次执行会重新计算然后判断里面的值 所以为了追求性能 应将计算放到初始化表达式中去) 如果为 true 执行语句 如果为 false 终止循环 更新表达式 回到第二部 再次判断 执行 break和continue break关键字可以用来退出整个switch或循环 if语句不能使用break和continue break关键字会立即终止离他最近的那个循环语句 可以为循环语句创建一个label来标识当前的循环 语法: label名 : 循环语句 `break` `label名`; continue关键字可以用来跳过当次循环, 只对最近循环起作用 continue要写在代码语句之前才能起作用 耗时测试 console.time(&#39;txt&#39;) + console.timeEnd(&#39;txt&#39;) 对象 对象是一种复合的数据类型, 在对象中可以保存多个不同数据类型的属性 对象的分类 内建对象: 由ES标准中定义的对象,在任何的ES的实现中都可以使用 例如: Array Function Object … 宿主对象: 由JS的运行坏境提供的对象, 目前来讲主要指由浏览器提供的对象 例如: BOM浏览器对象模型 DOM文档对象模型 自定义对象: 由开发人员自己创建的对象 创建对象 var obj = new Object() 使用 new 关键字调用的函数是构造函数 构造函数是专门用来创建实例对象的函数 属性: 在对象中保存的值称为属性 向对象中添加属性 对象.属性名 = 属性值 读取对象中的属性 对象.属性名 删除对象的属性 delete 对象.属性名 属性名 读取变量属性名或者特殊属性名 对象[属性名] = 属性值 属性值 JS对象的属性值 可以是任意数据类型 in运算符可以检查一个对象中是否含有指定属性(包括原型上的属性) 只检查自身使用hasOwnProperty “属性名” in 对象 有则返回true没有则返回false 引用数据类型 基本数据类型保存在栈内存中,变量的值直接保存相互独立 引用数据类型保存在堆内存中, 对象的值是保存的对象的**内存地址 如果两个保存的是同一个对象引用, 通过一个变量修改属性时另一个也会受到影响 引用数据类型比较值的时候它是比较的对象的内存地址 对象字面量 1234var obj = &#123; 属性名: 属性值, 属性名: 属性值...&#125; 函数函数也是一个对象, 用于提高相同代码(功能)可复用性 函数中可以封装一些功能 在需要时调用 可以执行这些功能 fun表示函数对象本身, fun()表示函数执行后的返回值 如果函数没有return返回值默认undefiend 创建函数 var fun = new Function() 可以将要封装的代码以字符串的形式传递给构造函数 封装的代码不会立即执行 函数中的代码会在函数被调用时执行 调用语法: 函数名() 当函数被调用时, 函数中封装的代码会按顺序依次执行 函数声明: 一般使用这种方式来创建函数 123function 函数名(形参1, 形参2, ...) &#123; 语句...&#125; 函数表达式 123var 函数名 = function(形参1, 形参2, ...) &#123; 语句...&#125; 形参(形式参数) 多个形参用 , 分割 声明形参就相当于在函数内部声明了对应的变量, 但并不赋值 实参(实际参数) 在调用函数时在()中指定实参, 相当于把实参的值赋值给形参 调用函数时解析器不会检查实参的数据类型和数量 有可能会接收到非法参数, 需要对参数的数据类型进行检查 如果实参的数量少于形参,则没有对应实参的形参的值是 undefined 实参可以是任意数据类型,也可以是对象或者函数 当我们的参数过多时,可以将参数封装到一个对象中,然后通过对象传递 函数返回值 使用return来设置函数的返回值 return后的值,将作为函数执行后的结果 return返回值后结束整个函数, 之后的语句都不会执行 如果不写return或者return后没有值则返回undefined 调用函数函数名()相当于使用函数的返回值, 函数名相当于使用函数对象 立即执行函数 (IIFE) 123(function() &#123; alert("这是一个匿名函数自调用");&#125;)() 整个函数加上括号表示一个整体代码才能正确识别 最后加一个()表示立即调用该函数 作用: 隐藏实现, 不会污染全局命名空间, 函数执行完后会立即销毁函数及里面的内容 JS 模块化的基础 回调函数 由开发者定义,但没有调用 (在满足某些条件后)最终执行了的函数 就是回调函数 DOM事件回调函数 定时器回调函数 AJAX 请求回调函数 生命周期回调函数 递归调用 在函数内部自己调用自己就是递归调用 递归调用首先要设置递归条件和retrun条件 否则这个函数将成为一个死循环 方法 方法 对象的属性可以是任何数据类型, 也可以是函数 如果一个函数作为一个对象的属性保存, 那么我们称这个函数是这个对象的方法 调用函数就说调用对象的方法 但是他们只是叫法上的区别, 本质没变 枚举对象中的属性 123for(var key in obj)&#123; obj[key]&#125; for ... in语句对象中有几个属性, 循环就会执行几次 包括原型上的属性和方法 每次会把对象的属性名赋值给变量 提取对象信息: 因为属性名是赋值给了变量所以提取属性信息必须用 obj[key] 作用域作用域用来隔离变量, 不同作用域下的同名变量不会冲突 作用域的范围是在编写代码时确定, 并非在函数执行时确定 调用函数是直接在函数原来的作用域里执行, 并非将函数复制到调用的作用域里执行 全局作用域 直接编写在script标签中的JS代码都在全局作用域中 全局作用域在页面打开时创建,页面关闭时销毁 在全局作用域中有一个全局对象window我们可以直接使用 它代表我们浏览器的窗口,由浏览器创建 我们创建的变量都会作为window对象的属性保存 我们创建的函数都会作为window对象的方法保存 全局作用域中的变量都是全局变量, 在页面任意部分都可以访问到 函数作用域 调用函数时函数作用域创建, 函数执行完毕后函数作用域销毁 闭包时不会销毁 每调用一次函数就会创建一个新的函数作用域 他们是相互独立的 在函数作用域中可以访问到全局作用域的变量 在全局作用域中无法访问到函数作用域的变量 当在函数作用域中操作一个变量时会先在自身作用域中寻找,如果没有则向上一级作用域中寻找 如果全局作用域中依然没有找到 则会报错ReferenceError 在函数中想要访问全局中的同名变量可以借用window对象 函数作用域中, 函数也会声明提前 在函数中不使用var声明的变量 都是全局变量 定义形参就相当于在函数中声明了一个变量 声明提前 浏览器加载 浏览器在加载一个页面时,时按照自上向下的顺序加载的 读取到一行就运行一行, 需要注意代码顺序和JS代码的位置 全局里的所有var和function ()都会提升到顶部执行 如果声明时没有使用var关键字, 则不会被提前 变量提前 &gt; 函数提前 函数表达式var只会提前声明变量, 函数不会提前所以不能在声明前调用函数 全局执行上下文 在执行全局代码前将window确定为全局执行上下文对象 对全局数据进行预处理 var定义的全局变量值设置为undefined并将其添加为window的属性 function声明的全局函数赋值, 并将其添加为window的方法 this指向window 开始执行全局代码 函数执行上下文 每当调用函数时, 准备执行函数体前, 创建对应的函数执行上下文对象 将实参值赋值给形参, 并将其添加为执行上下文对象的属性 arguments赋值实参列表, 并将其添加为执行上下文对象的属性 var定义的局部变量值设置为undefined并将其添加为执行上下文对象的属性 function声明的函数, 并将其添加为执行上下文对象的方法 this指向调用函数的对象 执行上下文栈 栈:像一个”柱”状 容器, 先放进去的执行上下文对象在下面后进去的在上面 只能操作在最上面的上下文对象, 在上面的执行上下文对象先执行先销毁 全局执行上下文对象window永远在最下面 闭包 闭包Closure 当一个嵌套的内部函数引用了嵌套的外部函数的变量或函数时就会产生闭包 闭包产生在外部函数调用时且内部函数已定义, 跟内部函数是否调用无关 在没有变量引用闭包的函数时闭包销毁 闭包的作用 使外部函数的变量在函数执行完后,仍保存在内存中 延长局部变量的生命周期 在函数外面可以操作到函数内部的数据 (变量/函数) JS模块 JS 模块就是具有特定功能的JS文件 将所有的数据和功能都封装在一个函数内部(私有的) 只向外暴露return一个包含n个方法的对象或函数 模块的使用者就可以通过模块暴露的对象来调用方法实现对应功能 将数据或功能写在IIFE中, 为暴露对象添加属性或方法, 并将向外暴露的对象设置为window的属性 闭包的缺点 函数执行完毕后, 函数内部的局部变量没有释放, 占用内存 容易造成内存泄漏 解决: 及时释放 (将不再使用的函数引用赋值null) 内存溢出: 当程序运行需要的内存超过剩余内存时就会抛出内存溢出的错误 内存泄露: 占用的内存没有及时释放,积少成多后容易导致内存溢出 常见的内存泄漏: 意外的全局变量 没有及时清理的计时器或回调函数 闭包 this解析器在每次调用函数时都会传递一个隐含的参数this this会指向调用函数的对象 根据函数调用方式的不同this会指向不同的对象 以函数的形式调用this(或未指定调用对象)则指向window 以方法的形式调用this则指向调用的对象 DOM 事件回调函数中的this一般指向 DOM 元素 其他回调函数中的this一般指向window 当以构造函数调用时, this则是构造函数中新建的对象 以call(调用对象,函数形参1,形参2,...)和apply(调用对象,形参数组)方法调用时this是指定的那个对象 构造函数构造函数是专门用来创建某种类型的对象的函数 构造函数就是一个普通的函数, 创建方式和普通函数没有区别 构造函数首字母大写 构造函数和普通函数的区别是调用方式的不同 普通函数是直接调用 构造函数需要使用new关键字来调用 构造函数的执行流程 new立刻在堆内存创建一个新对象 将新建的对象设置为函数中的this 用 this 来选择新建的对象 逐行执行函数中的代码 将新建对象返回 类 使用同一个构造函数创建的对象我们称为一类对象, 也将这个构造函数称为一个类 我们将通过一个构造函数创建的对象称为是该类的实例 使用instanceof可以检查一个对象是否是某一个类的实例 所有的对象都是Object的实例, 用instanceof检查返回true Object.prototype 除外 原型我们所创建的每一个函数, 解析器都会向函数中添加一个属性prototype显式原型 这个属性对应着一个Object对象, 这个对象就是原型对象 原型对象中有个constructor属性指向该对象的构造函数 如果作为普通函数调用prototype没有任何作用 当函数以构造函数的形式调用时, 它所创建的实例对象中都会有一个隐含的属性 该属性指向该构造函数的原型对象, 我们可以通过__proto__隐式原型来访问该属性 原型链 当我们访问对象的一个属性或方法时, 他会现在对象自身中寻找 如果有则直接使用, 如果没有则会去原型对象中寻找 原型对象也是对象,所以它也有原型 所以如果原型中没有找到, 则去原型的原型中寻找 (也就是Object对象的原型) Object.prototype.__proto__的值是null它是原型链的尽头 使用in检查对象中是否含有某个属性时, 如果对象中没有, 原型中有也会返回true 使用对象.hasOwnProperty(&quot;属性名&quot;)来检查对象自身中是否含有该属性 所有函数(主要是构造函数)都有显示原型 所有对象(包括函数, 数组)都有隐式原型 函数实例的隐式原型 等于 构造函数的显示原型 继承 原型继承 构造函数的实例对象自动拥有构造函数原型对象的属性和方法 (利用原型链继承) 当修改对象属性的常规值的时候就是修改属性名对应的值本身 对象重新赋值相当于修改变量名/属性名保存的引用地址 原型链继承 (为了继承父类型的方法) 定义父类型构造函数 给父类型的原型添加方法 定义子类型构造函数 关键: 创建父类型的实例对象赋值给子类型的原型对象 将子类型原型的构造constructor属性修正为子类型函数 给子类型添加方法 创建子类型的实例 (可以调用父类型的方法) 借用构造函数继承 (假借, 为了构建相同属性) 定义父类型构造函数 定义子类型构造函数 在子类型构造函数中通过Fun.call(this, a, b)调用父类型构造函数 组合继承 利用原型链实现对父类型对象的方法继承 利用call()方法假借父类型构建函数初始化相同属性 数组数组也是一个对象 (内建对象) 他和我们普通对象功能类似, 也是用来储存一些值的 不同的是普通对象是使用字符串作为属性名, 且无序 而数组是使用数字作为索引来操作元素, 有序 索引: 0 开始的整数 数组的储存性能要比普通对象好, 在开发中我们经常使用数组来储存一些数据 添加/修改元素: 数组名[索引] = 值 获取数组长度: 使用数组的length方法 语法: 数组.length 会获取到数组最大索引 +1 设置数组长度: 语法: 数组.length = 值 如果大于原长度, 多出的值会空出来 如果小于原长度, 多出的值会被删除 向数组最后一个位置添加元素: 数组名[数组名.length] = 值 字面量创建数组: var 数组名 = [值, 值, 值...] 使用构造函数创建数组: var 数组名 = new Array(值, 值, 值...) 使用这种方法如果只传一个整数值则表示创建一个长度为n的空数组 数组方法 push() 该法方法可以向数组的末尾添加一个或多个元素, 并返回新数组的长度 将要添加的元素作为参数传递, 这样这些元素会自动添加到数组末尾 该方法会将数组的新长度作为返回值返回 pop() 该方法可以立即删除数组中的最后一个元素 该方法的返回值是删除的那个元素 unshift() 向数组的开头添加一个或多个元素, 并返回新的长度 向最前面插入元素, 其他元素的索引会依次调整 shift() 删除数组第一个元素, 并将删除的元素作为返回值返回 slice() 可以用来从数组中提取出指定元素 该方法不会影响原数组, 会将截取到的数组返回 语法: 数组名.slice(参数1, 参数2) 参数: 截取开始位置索引(包含) 截取结束位置索引(不包含,省略则是到末尾) 参数可以传递负值,如果传递一个负数则从后往前计算 (-1 倒数第一个元素) splice() 可以用来替换/删除/添加数组中的指定元素 使用splice()会影响原数组 它会将指定元素从原数组中删除, 并将被删除的元素作为返回值返回 语法: 数组名.splice(参数1, 参数2, 参数3...) 参数: 表示开始位置的索引(包含) 表示删除元素的数量 可以传递一些新元素,这些元素会插入到开始位置索引的 前面 concat() 可以拼接多个数组, 并将新的数组返回 该方法不会对原数组产生影响 语法: var arr = arr1.concat(arr2,arr3...) join() 该方法可以将数组转换成一个字符串 该方法不会对原数组产生影响, 而是将转换后的字符串作为结果返回 在join()中可以指定一个字符串作为参数, 这个字符串将会称为数组中元素的连接符(默认 ,) 语法: var str = arr.join(&quot;连接符&quot;) reverse() 该方法用来反转数组,该方法会直接修改原数组 sort() 可以用来对数组元素按unicode编码进行排序, 它也直接修改原数组 我们可以自己指定排序规则在sort()添加一个回调函数, 来指定排序规则 回调函数中需要定义两个形参 浏览器会分别使用数组中的元素作为实参去调用回调函数 使用那个元素调用不确定, 但可以肯定 数组中的a一定在b之前 浏览器会根据回调函数的返回值决定元素的顺序 返回值大于0元素交换位置, 小于0则不换位, 等于0认为两个元素相等依然不变 1234arr.sort(function(a, b)&#123; return a - b; //升序 return b - a; //降序&#125;) filter() filter使用数组中的每个元素去调用callback函数 如果callback返回true则将该元素添加到新数组里面 1var newArray = arr.filter(callback(element, index, arr)) forEach() IE 8及以下不支持 方法遍历数组需要一个函数作为参数 数组中有几个元素则调用函数几次 每次执行浏览器会将遍历到的元素以实参形式传递进函数 123数组名.forEach(function(元素值, 索引, 数组本身) &#123; 操作语句...&#125;) 函数的方法 call()和apply() 这两个方法都是函数对象的方法, 需要通过函数对象来调用 当对函数调用call()和apply()方法时都会执行函数 在调用call()和apply()时可以将一个对象指定为第一个参数 此时这个对象将会成为函数执行时的`this call()方法实参在对象之后依次传递 apply()方法需要将实参封装到一个数组里 arguments 在调用函数时,浏览器每次都会传递进两个隐含的参数: 函数的上下文对象this 封装实参的对象arguments arguments是一个伪数组对象, 它也可以通过索引来操作数据, 也可以获取长度 在函数调用时我们所传递的实参都会在arguments中保存 arguments.length可以用来获取传入实参的数量 我们即使不定义形参, 我们也可以通过arguments[i]来使用实参 它里面有一个属性叫callee这个属性对应一个函数对象, 就是当前这个函数本身 时间对象 创建一个Date对象 直接使用构造函数创建一个Date对象,则会封装当前执行代码的时间 语法: var d = new Date() 创建一个指定的时间对象 需要在构造函数中传递一个表示时间的字符串作为参数 日期格式&quot; 月份 / 日 / 年 时 : 分 : 秒 &quot; 相关方法 getDate() 获取当前日期对象是几号 getDay() 获取当前日期对象是周几 (0 表示周日) getMonth() 获取当前日期对象的月份 (返回值 0 - 11) getFullYear() 获取当前日期对象的年份 getTime() 获取当前日期对象的时间戳 时间戳是指格林威治标准时间到当前时间经过的毫秒数 计算机底层在保存时间使用的都是时间戳 获取当前代码执行时的时间戳 var time = Date.now() Math对象Math和其他对象不同, 它不是一个构造函数 它属于一个工具类不用创建对象, 它里面封装了数学运算相关的属性和方法 Math.PI 圆周率 (全大写表示常量) Math.abs() 求绝对值 Math.ceil() 向上取整 Math.floor() 向下取整 Math.round() 四舍五入 Math.random() 生成一个0-1之间的随机数 Math.floor(Math.random()*10) 0-9 之间的整数 Math.max() 返回值是传入参数中的最大值 Math.min() 返回值是传入参数中的最小值 Math.pow(x,y) 返回 x 的 y 次幂 Math.sqrt() 返回值是参数的开方 包装类在JS中为我们提供了三个包装类,通过这三个包装类可以将基本数据类型转换为对象 String() 可以将一个基本数据类型的字符串转换为 String 对象 Number() 可以将一个基本数据类型的数字转换为 Number 对象 Boolean() 可以将一个基本数据类型的布尔值转换为 Boolean 对象 但是在实际应用中 我们不会使用基本数据类型的对象 如果使用会带来一些不可预期的结果 方法和属性只能添加给对象, 不能添加给基本数据类型 当我们对一些基本数据类型的值去调用属性或方法时 浏览器会临时使用包装类将其转换为对象, 然后去它的原型上寻找对应的方法 字符串的方法 系统底层字符串是以字符数组形式保存的 length属性 获取字符串长度 (属性不用加括号) charCodeAt() 获取指定位置字符的Unicode编码 concat() 连接一个或多个字符串 indexOf(&quot;查找内容&quot;, 查找起始位置索引) 检索一个字符串里是否有指定内容 如果字符串中含有该内容则返回该内容第一次出现的位置的索引 如果没有则返回 -1 lastIndexOf() 同上, 反向查找 slice(包括起始位置,不包括结束位置) 可以从字符串中截取指定内容, 负数表示倒数 substr(包括起始位置,截取数量) 截取字符串,该方法ES中没有定义,但是所有浏览器都支持 split(分割字符串) 根据分割字符串把一个字符串拆分成一个数组 如果传递一个空串 则将字符串中的每一个字符都拆分成一个元素 toUpperCase() 转换大写 toLowerCase() 转换小写 正则表达式正则表达式用于定义一些字符串的规则 计算机可以根据正则表达式 来检查一个字符串是否符合规则 或者将字符串中符合规则的内容提取出来 创建正则表达式的对象 var 变量名 = new RegExp(&quot;正则表达式&quot;,匹配模式) test()用于检查一个字符串是否符合正则表达式规则 符合返回true 不符合返回false 匹配模式 i忽略大小写 g全局匹配模式 字面量创建正则表达式 var 变量名 = /正则表达式/匹配模式 注意 // 里不能有空格 正则表达式语法 | [] 或 [a-z] 小写字母 [A-Z] 大写字母 [A-z] 任意字母 [^ ] 除了括号以内的任意内容 [0-9] 任意数字 ^ 表示x开头 $ 表示x结尾 ^$ 开始立即结束 . 表示任意字符 \ 转义符 使用 \ 则需要写 \ \w 任意 字母 数字 _ 相当于[A-z_0-9] \W 除了字母 数字 _ 相当于[^A-z_0-9] \d 任意数字 相当于[0-9] \D 除了数字 相当于[^0-9] \s 空格 \S 除了空格 \b 单词边界 (前后各加一个\b表示中间的内容是独立的单词) \B 除了单词边界 量词 (注意不要加空格) {n} 之前的第一个内容出现n次 {m,n} 之前的内容出现 m 至 n 次 (n不写表示无限制) + 至少一个 相当于{1,} * 零个或多个 相当于{0,} ? 零个或一个 相当于{0,1} 相关方法 split() 可以将字符串拆分成一个数组 (默认全局匹配) search() 所搜字符串中是否含有指定内容 不能全局匹配,只能查找第一个 如果所搜到指定内容返回第一次出现的位置, 没有索搜到则返回 -1 match() 根据正则表达式从一个字符串中将符合条件的内容提取出来 默认情况下match()只会找到第一个符合要求的内容就会停止检索 我们可以设置正则表达式为全局匹配模式这样就会匹配到所有的内容 match()会将匹配到的内容封装到一个数组中返回, 即使只匹配到一个结果 replace(被替换内容,新的内容) 将字符串中指定内容替换为新的内容 默认只会替换第一个内容, 被替换内容可以使用正则表达式来匹配 DOMD Document 网页 O Object 标签转换为对象 M Model 标签之间的关系模型 常用节点 nodeName nodeType nodeValue 文档节点: 整个 HTML 文档 #document 9 null 元素节点: HTML 文档中的标签 标签名 1 null 属性节点: 标签的属性 属性名 2 属性值 文本节点: 标签的内容 #text 3 文本内容 浏览器为我们提供 文档节点对象 这个对象是window 可以在页面中直接使用, 文档节点代表整个网页document 事件 就是用户和浏览器之间的交互行为 比如:点击按钮,移动鼠标,关闭窗口… 事件响应函数最后 return false 可以取消元素默认行为 confirm(&quot;提示字符串&quot;)可以弹出一个提示框, 根据用户操作返回一个布尔值 注意: 事件的代码是在触发后执行(异步执行), 而其他代码是在加载时执行, 所以要特别注意事件里的变量 为window绑定一个onload事件, 函数中的代码会在页面加载完成后执行 这样可以确保我们代码执行时 DOM 对象已经加载完毕 123window.onload = function () &#123; 语句...&#125; 通过document调用, 获取元素节点 getElementById() 通过ID获取一个元素节点对象 getElementsByTagName() 通过标签名获取一组元素节点对象 getElementsByName() 通过NAME属性获取一组节点对象 读取元素节点属性 语法: 元素.属性名 class属性需要用className 通过具体节点调用, 获取元素节点的子节点 getElementsByTagName() 返回当前节点的指定标签名后代节点 childNodes 表示当前节点的所有子节点(包括空白文本节点) children 表示当前节点的所有子元素 firstChild 表示当前节点的第一个子节点(包括空白文本节点) firstElementChild 表示当前节点的第一个子元素(不支持IE8及以下) lastChild 表示当前节点的最后一个子节点(包括空白文本节点) lastElementChild 表示当前节点的第一个子元素(不支持IE8及以下) 通过具体节点调用, 获取父节点和兄弟节点 parentNode 表示当前节点的父节点 (父元素唯一) previousSibling 表示当前节点的前一个兄弟节点(包括空白文本节点) previousElementSibling 表示当前节点的前一个兄弟元素(不支持IE8及以下) nextSibling 表示当前节点的后一个兄弟节点(包括空白文本节点) nextElementSibling 表示当前节点的后一个兄弟元素(不支持IE8及以下) 其他查询方法 document.body 表示Body标签 document.all 页面中的所有标签document.getElementsByTagName(&quot;*&quot;) document.getElementsByClassName() 根据 class 获取元素 (不支持IE8及以下) document.querySelector(&quot;CSS选择器&quot;) 根据 CSS 选择器来获取元素(它只会返回第一个结果) document.querySelectorAll(&quot;CSS选择器&quot;) 同上, 支持IE8及以上, 返回多个结果保存在数组里 DOM 操作 document.createElement(&#39;标签名&#39;) 根据标签名创建一个相应的元素节点对象 document.createTextNode(&#39;文本内容&#39;) 根据文本内容创建一个文本节点 父节点对象.appendChild(子节点对象) 向父节点中添加一个子节点 父节点对象.insertBefore(新节点对象, 指定节点对象) 在指定的子节点前添加新的节点 父节点对象.replaceChild(新节点对象, 指定节点对象) 用新节点替换掉指定节点 父节点对象.removeChild(子节点对象) 删除一个子节点 节点对象.innerHTML = &#39;内容&#39; 给节点对象的 HTML 内容赋值 ( += 替换 少用) 内联样式操作修改值 通过DOM对象style属性设置或读取内联样式 语法: DOM对象.style.样式名 = &quot;值&quot; 数值注意要 + px 如果CSS样式名中含有 - 号需要将样式名修改为驼峰命名法 获取元素当前显示的样式 语法: 元素名.currentStyle.样式名 可以用来读取当前元素正在显示的样式的值(只支持IE,其他浏览器不支持) 语法: getComputedStyle(要获取样式的元素对象 , null) 该方法可以将元素对象的所有样式封装到一个对象里返回(支持IE9及以上) 通过以上两种方法获取到的样式都是只读属性修改需要用style属性来修改 其他样式属性操作(返回值不带 px 只读属性, 无法修改) clientWidth\clientHeight 返回元素的可见宽度\高度 返回值(内容区+ padding) offsetWidth\offsetHeight 返回元素的整个宽度\高度 返回值(内容区 + padding + 边框) offsetParent 可以获取当前元素定位的父元素(标签postion属性 定位的父元素) offsetLeft\offsetTop 当前元素对于定位父元素的偏移量 scrollWidth\scrollHeight 获取元素整个滚动区域的宽度\高度 scrollLeft\scrollTop 滚动条 水平\垂直 滚动距离 scrollHeight - scrollTop == clientHeight 表示垂直滚动条滚动到底 自定义 getStyle() 方法 1234567function getStyle(obj , stylename)&#123; if(window.getComputedStyle)&#123; return getComputedStyle(obj , null)[stylename]; &#125;else&#123; return obj.currentStyle.stylename; &#125;&#125; 注意 返回值当中有 px 用parseInt()来取值, 注意 IE 中没有默认参数则返回auto需要设置默认参数 BOMB Browser 浏览器 O Object 对象 M Model 模型 BOM 可以使我们通过JS来操作浏览器, 它为我们提供了一组对象, 用来完成对浏览器的操作 BOM 对象 Window 代表的是整个浏览器的窗口,同时 window 也是网页中的全局对象 Navigator 代表的当前浏览器的信息,该对象可以用来识别不同的浏览器 Location 代表当前浏览器的地址栏信息,通过它可以获取地址栏信息或者跳转页面 History 代表浏览器的历史记录,可以通过该对象来操作浏览器的历史纪录 由于隐私原因 ,该对象不能浏览到具体的历史纪录,只能操作浏览器 向前或者向后 而且该操作只对档次访问有效 Screen 代表用户的屏幕的信息,通过该对象可以获取到用户的显示器相关的信息 BOM 对象在浏览器中都是作为window对象的属性保存的, 可以通过window对象调用, 也可以直接使用 navigator 由于历史原因navigator对象中的大部分属性都不能帮助我们识别浏览器了 一般我们只会使用navigator.userAgent来判断浏览器的信息 123456789if(/firefox/i.test(navigator.userAgent))&#123; firefox&#125;else if(/chrome/i.test(navigator.userAgent))&#123; chrome&#125;else if(/msie/i.test(navigator.userAgent))&#123; ie(Edge除外)&#125;else if("ActiveXObject" in window)&#123; Edge&#125; location 直接将 location属性的值修改为 绝对路径或相对路径 可以使页面跳转到该地址 并生成相应的历史记录 location.reload() 相当于刷新如果在方法中传递一个true作为参数, 则会强制清空缓存 location.replace() 该方法传入一个地址, 跳转页面但是不会生成历史纪录 location.reload() 相当于刷新 如果在方法中传递一个 true 作为参数,则会强制清空缓存 location.replace() 该方法传入一个地址,跳转页面 但是不会生成历史纪录 history length 可以获取到当前访问链接的数量 back() 可以用来退回到上一个页面 作用和浏览器上的回退按钮一样 forward() 可以跳转到下一个页面 作用和浏览器的前进按钮一样 go(整数) 可以用来跳转到指定数目的页面,正数表示向前跳转 负数向后跳转 screen 主要用于移动端 window对象的方法 setInterval(回调函数, 调用间隔 单位ms) 定时调用, 可以设置一个函数每隔一段时间执行一次 这个方法有个返回值, 该数字 是定时器的唯一 标识 clearInterval(定时器标识) 可以接收任意参数, 用来关闭指定的定时器 同一元素开启定时器时, 需要先关闭当前元素的其他定时器 定时器和键盘操作配合起来可以实现连贯流畅的动态效果 setTimeout(回调函数, 调用延时 单位ms) 定时调用会执行多次, 延时调用只调用1次 clearTimeout(timer) 用来关闭延时调用 事件对象 事件对象 当事件的响应函数被触发时,浏览器每次都会将一个事件对象作为实参传递进响应函数event 在事件对象中封装了当前事件相关的一切信息(比如: 鼠标坐标 键盘操作 等等..) IE 8及以下 将事件对象 保存在window.event属性中, 用event = event || window.event来兼容 事件对象的属性 事件对象.clientX \ Y 可以获取鼠标指针在当前可见窗口的横纵坐标 事件对象.pageX \ Y 可以获取鼠标指针在整个页面中的横纵坐标(不支持IE8及以下) 事件冒泡(Bubble) 所谓的事件冒泡指的就是事件的向上传导 当后代元素上的事件被触发时, 其祖先元素上的相同事件也会被触发 取消冒泡 可以通过事件对象来取消冒泡 语法: event.cancelBubble = true 事件委派 当我们希望只绑定一次事件即可应用到多个元素上, 即使元素是后添加的 我们可以尝试将其绑定给元素的共有的祖先元素 将事件统一绑定给元素的共同的祖先元素 这样当后代元素上的事件触发时会一直冒泡到祖先元素 从而通过祖先元素的响应函数来处理事件这就是事件委派 事件委派是利用了冒泡, 通过委派可以减少事件绑定次数, 提高程序性能 检测事件的触发对象 event.target 返回值是触发对象(可配合 if 语句使用) 事件绑定 DOM0: 对象.on事件 = 响应函数` 他只能为一个元素的一个事件绑定一个响应函数 不能绑定多个事件, 绑定多个相当于赋值后面的语句会覆盖掉前面的语句 DOM2: 我们可以通过addEventListener()为元素添加事件监听器来绑定多个响应函数 该语法支持 IE 9 及以上和其他浏览器, this指向调用的元素 元素对象.addEventListener(&quot;事件名称,不要on&quot;, 回调函数, 是否在捕获阶段触发一般false) IE 8及以下使用 元素对象.attachEvent(&quot;事件名称&quot;, 回调函数) 该语法的执行顺序是: 后绑定的先执行, 该语法中的this指向window 自定义事件兼容函数 123456789101112function bind (obj, evenStr, callBack)&#123; if(obj.addEventListener)&#123; //现代浏览器 obj.addEventListener(evenStr, callBack, false); &#125;else&#123; //IE8及以下, this指向window是因为回调函数是浏览器直接以函数形式调用 obj.attachEvent("on"+evenStr, function () &#123; //我们将匿名函数包裹回调函数再传递给浏览器, 由自己控制函数调用 callBack.call(obj); //当函数以call方法调用时 this指向指定对象; &#125;); &#125; &#125; 事件传播 微软公司认为事件应该是由内向外传播, 先触发当前元素上的事件(事件在冒泡阶段执行) 网景公司认为事件应该是由外向内传播, 先触发祖先元素上的事件(事件在捕获阶段执行) W3C标准: ​ 1.捕获阶段 ​ 在捕获阶段时,从最外层的祖先元素向目标元素进行事件捕获,默认此时不会触发事件 ​ 2.目标阶段 ​ 事件捕获到目标元素,捕获结束,开始执行目标元素上的事件 ​ 3.冒泡阶段 ​ 事件从目标元素开始向他的祖先元素上传递,依次触发祖先元素上的相同事件 浏览器默认行为 当我们拖拽网页中的内容时,浏览器默认回去搜索相关内容 此时会导致拖拽功能异常, 这个时浏览器的默认行为可以在事件函数中return false来取消 IE 8 及以下无效 鼠标事件 onclick 鼠标单击时触发 onmousemove 该事件将会在鼠标再元素中移动时触发 mouseover 不论鼠标指针穿过被选元素或其子元素都会触发 mouseenter 只有在鼠标指针穿过被选元素时才会触发 mouseout 不论鼠标指针离开被选元素还是任何子元素都会触发 mouseleave 只有在鼠标指针离开被选元素时才会触发 强制捕获鼠标按下操作 (IE8 取消拖拽搜索) 捕获鼠标操作的对象.setCapture() 当调用setCapture()方法以后元素会将下一次所有的鼠标按下操作捕获到自身上来 捕获鼠标操作的对象.releaseCapture() 取消对象对鼠标按下操作的强制捕获 以上2种方法 chrome 里会报错, 兼容方法: 对象.setCapture &amp;&amp; 对象.setCapture() &amp;&amp; 如果两边都为 true 则返回后面一个值 鼠标滚轮事件 onmousewheel 会在滚轮滚动时触发 但火狐浏览器不支持该属性 在火狐中需要使用DOMMouseScroll来绑定滚动事件 注意该事件需要通过自定义事件绑定兼容函数 来绑定 event.wheelDelta返回值是正值向上, 负值向下(多数浏览器) event.detail返回值是负值向上, 正值向下(火狐浏览器) 12345if( event.wheelDelta &gt; 0 || event.detail &lt; 0 )&#123; 向上滚动&#125;else&#123; 向下滚动&#125; 当我们滚动滚轮时, 如果浏览器有滚动条, 滚动条会随之滚动 如果不需要可以用return false来取消 火狐使用addEventListener()方法来绑定的函数取消默认行为时不能使用return false 需要使用event.preventDefault()来取消默认行为 但是 IE8 不支持, 调用时需要检测是否具有该方法 键盘事件 onkeydown 按键被按下 对于它来说如果按住不放 事件会连续触发 当onkeydown连续触发时 前两次间隔会长一点,之后间隔非常短) onkeyup 按键被松开 键盘事件一般都会绑定给可以获取到焦点的对象或者是document onkeypress 事件在所有浏览器中不能触发所有按键(例如：ALT, CTRL, SHIFT, ESC) oninput 该事件在&lt;input&gt;或&lt;textarea&gt;元素的值发生改变时触发 我们可以通过event.keyCode来获取按键的unicode编码 除了keyCode事件对象中还提供了几个其他属性 altKey ctrlKey shiftKey 这三个用来判断 相对的按键是否按下 按下返回 true 否则返回 false 在文本编辑框的键盘事件的响应函数中return false可以取消默认行为 按下的字母或数字不会打印到文本框上 CSS类我们希望一行代码可以同时修改多个样式时, 可以通过修改元素的class属性来间接修改样式 我们只需要修改一次,即可同时修改多个样式, 浏览器只需要重新渲染一次性能更好并且结构和行为进一步分离 自定义class函数 检查元素中是否含有某个className 1234function hasClass(obj, classname) &#123; var reg = new RegExp("\\b"+classname+"\\b"); return reg.test(obj.className);&#125; 向一个元素中添加指定的className 12345function addClass(obj, classname) &#123; if(!hasClass(obj, classname)) &#123; obj.className += " "+classname; &#125;&#125; 删除元素中指定的className 1234function removeClass(obj,classname)&#123; var reg = new RegExp("\\b"+classname+"\\b"); obj.className = obj.className.replace(reg,"");&#125; 切换一个类(有则删除,没有则添加) 1234567function toggleClass(obj,classname)&#123; if(hasClass(obj.classname))&#123; removeClass(obj,classname); &#125;else&#123; addClass(obj,classname); &#125;&#125; JSONJS中的对象只有自己认识, 其他语言都不认识 JSON就是一个特殊格式的字符串, 这个字符串可以被任何语言所识别 并可以转换为任意语言中的对象,JSON 在开发中主要用来交互数据 JavaScript Object Notation JS对象表示法 JSON和JS对象的格式一样, 只不过 JSON字符串中的”属性名”必须加双引号 JSON 中允许的值 字符串 数值 布尔值 null 普通对象 数组 不能储存函数 JSON 分类: 对象{} 数组[] 将 JSON 字符串转换为 JS 对象 在JS中为我们提供了一个工具类, 就叫 JSON 这个对象可以帮助我们将一个JSON对象转换为JS对象, 也可以将 JS 对象转换为 JSON JSON ==&gt; JS JSON.parse() JS ==&gt; JSON JSON.stringify() eval() 这个函数可以用来执行一段字符串形式的JS代码, 并将结果返回 如果eval()执行的字符串中含有{}他会将{}当成一个代码块 如果不希望将其当成代码块解析, 需要在字符串前后加一个() eval()这个函数的功能很强大, 可以直接执行一个字符串中的JS代码 但是在开发中尽量不要使用, 因为它的执行性能差, 具有安全隐患 如果需要兼容 IE 7 及以下的 JSON 操作, 可以通过引入一个外部的JS文件来处理 Event Loop 浏览器内核 Chrome Safari: webkit FireFox: Gecko IE: Trident 内核组成 主线程 js引擎模块: 负责js程序的编译和运行 html/css文档解析模块: 负责页面文本的解析 dom/css模块: 负责dom&amp;css在内存中的相关处理 布局和渲染模块: 负责页面的布局和效果的绘制 分线程 定时器模块 : 负责定时器的管理 事件响应模块 : 负责事件的管理 网络请求模块 : 负责ajax请求 JS代码分类 初始化执行代码 (同步代码) 回调执行代码 (异步代码) JS引擎执行代码的基本流程 先执行初始化代码:包括一些特别的代码 设定定时器 绑定监听 发送ajax请求 后面在某一个时刻才会执行会调代码 回调函数里面的代码是异步执行的 JS是单线程执行的, 初始代码依次执行完毕后再依次执行回调代码 事件循环 (event loop) 12345678 JS(浏览器主线程模块执行) heap stack →→→ WebAPIs(浏览器分线程模块执行)堆内存数据 栈内存数据 →→→ DOM(事件响应) 对象... 初始化代码执行 ajax(网络请求) setTimeout(定时器) 循环执行 ↓↓↓event loop: callback queue ( 任务队列/消息队列/事件队列 ) 待执行回调队列依次执行 Web Workers HTML5提供的一个JS多线程解决方案 我们可以将一些大计算量的代码交由Web Worker运行而不冻结用户界面 但是子线程完全受主线程控制且不得操作DOM 所以这个新标准并没有改变 JS 单线程的本质 面向对象所谓的面向对象, 就是在编程的时候尽可能的去模拟真实的现实世界按照现实世界中的逻辑去处理一个问题, 分析问题中参与其中的有哪些实体, 这些实体应该有什么属性和方法，我们如何通过调用这些实体的属性和方法去解决问题 实体就是动作的支配者 没有实体, 就肯定没有动作发生 分析那些动作是由哪些实体发出的 定义这些实体，为其增加相应的属性和功能 让实体去执行相应的功能或动作]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery笔记]]></title>
    <url>%2F2018%2F09%2F10%2FjQuery%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[jQuery基础了解jQuery 封装简化DOM操作 它有强大选择器 : 方便查找 DOM 元素 它能隐式便利 : 一次操作所有查找到的元素 它能链式调用 : jQ方法都会返回jQ对象 它可以读写合一 : 不传值则读取 传值则写入 事件处理 , DOM操作 , CSS操作 , 动画效果 , 浏览器兼容 引入jQuery 开发测试的时候使用未压缩的版本方便调试 (服务器本地引入) 正式上线的时候使用压缩版本加载速度快 (CDN远程引入) jQuery两把利器 jQuery(核心)函数 $()使用()调用时是当作函数使用 参数为函数 : 当DOM加载完成后,执行此回调函数 参数为选择器字符串 : 查找所有匹配的标签,并将他们封装为jQuery对象 参数为DOM对象 : 将DOM对象封装成为 jQuery对象 参数为HTML标签字符串 : 创建标签对象并封装成jQuery对象 $.xxx() 使用 . 来使用方法时当作对象来使用 123$.each(arr, function(index, item) &#123;&#125;)$.trim(str) jQuery(核心)对象 执行jQuery核心函数返回的对象(函数名前加 $) jQuery对象内部包含的是 DOM 元素对象的伪数组(即使只有一个元素) jQuery对象拥有很多有用的属性和方法,让程序员能方便的操作 DOM 语法: $obj.xxx()或者$(&quot;选择器&quot;).xxx() 基本用法 .length 获取jQuery对象里面包含的 DOM 元素的个数 [index] 返回index下标对应的 DOM 元素 .each() 遍历jQuery对象里面的 DOM 元素 .index() 得到 DOM 元素在其兄弟元素中的下标 选择器jQuery选择器jQ选择器基于css选择器, 并对其进行了扩展 作用: 根据选择器规则在整个文档中查找所有匹配的标签, 并封装成jQuery对象返回 选择器分类 基本选择器: 和css选择器规则相同 #id / element / .class / * / s1,s2(并集) / s1s2(交集) 层次选择器: 查找子元素 / 后代元素 / 兄弟元素 s1 s2 匹配s1后代所有的s2元素 parent&gt;child 匹配parent的子元素child prev+next 匹配prev后紧接的兄弟元素next prev~siblings 匹配prev之后的所有兄弟元素siblings 过滤选择器: 在原有选择器匹配的元素中进行进一步的筛选 多个过滤选择器是依次执行的, 需要注意index值的变化 基本 :first 选择第一个元素 :last 选择最后一个元素 :not(selector) 不匹配selector的元素 :even 索引值为偶数的元素 :odd 索引值为奇数的元素 :eq(index) 指定索引值的元素 :gt(index) 大于指定索引值的元素 :lt(index) 小于指定索引值的元素 :animated 正在执行动画效果的元素 :focus 当前获取焦点的元素 内容 :contains(text) 匹配包含给定文本的元素 :has(selector) 配含有选择器所匹配的元素的元素 可见 :hidden 匹配所有不可见元素 :visible 匹配所有的可见元素 属性 : [attribute=value] 匹配给定的属性是某个特定值的元素 [attribute!=value] 匹配所有不含有指定的属性 子元素 :nth-child(n) 匹配其父元素下的第N个子或奇偶元素 表单 :checkbox 匹配所有复选框 :button 匹配所有按钮 工具方法将 $ 当作对象来使用 $.each(function(&quot;属性名/索引&quot;,&quot;属性值&quot;){}): 遍历数组或对象中的数据 $.trim(str): 去除字符串两边的空格 $.type(obj): 得到数据的类型 $.isArray(obj): 判断是否是数组 $.isFunction(obj): 判断是否是函数 $.parseJSON(json): 解析json字符串转换为js对象/数组 属性操作 读取/设置任意属性 attr(&quot;属性名&quot;,&quot;属性值&quot;) 单个属性直接传入”属性名”,”属性值” 多个属性封装为对象传入 “属性名”:”属性值” removeAttr(&quot;属性名&quot;) prop(&quot;属性名&quot;,true/false) 操作属性值为布尔值的属性 操作class类名 addClass(&quot;类名&quot;) 为元素添加CSS类名，多个请用空格分开 removeClass(&quot;类名&quot;) 删除元素的CSS类名，多个请用空格分开 操作HTML html() 获取元素的内容,传参则设定HTML的内容 val() 获得匹配元素的当前值,传参则设定值 CSS .css() 传入”属性名” 则读取该属性 传入”属性名”,”值” 设置该属性 设置多个属性 封装为一个对象传入 位置属性 offset() 获取匹配元素相对页面左上角的偏移,只对可见元素有效 返回的对象包含两个整型属性：top 和 left 写入参数传入对象 {top:123,left:456} position() 获取匹配元素相对父元素的偏移 scrollTop([val]) 获取匹配元素相对滚动条顶部的偏移 scrollLeft([val]) 获取匹配元素相对滚动条左侧的偏移 尺寸 height() 内容高度 width() 内容宽度 innerHeight() height + padding innerWidth() width + padding outerHeight(true) height + padding + border + margin outerWidth(false) width + padding + border 对象筛选过滤在已匹配的元素对象中筛选出一个或多个组成新的jQuery对象返回 eq(index|-index) 获取第N个jQuery对象，参数为负数时为反向选取 first() last() 获取第一个或最后一个元素 filter(selector) 筛选出当前元素中与选择器匹配的元素集合 not(selector) 删除与选择器匹配的元素 has(selector) 包含特定后代的元素，去掉那些不含有指定后代的元素 查找通过已匹配的对象找到一个或多个新的元素对象封装为新的jQuery对象 children(selector) 子标签中匹配 find(selector) 后代标签中匹配 parent(selector) 父标签中匹配 prevAll(selector) 前面所有的兄弟标签中匹配 nextAll(selector) 后面所有的兄弟标签中匹配 siblings(selector) 前后所有的兄弟标签中匹配 文档处理 添加 append(content) / appendTo() 向当前匹配的所有元素内部的最后插入指定内容 prepend(content) / prependTo() 向当前匹配的所有元素内部的最前面插入指定内容 before(content) 将指定内容插入到当前所有匹配元素的前面 after(content) 将指定内容插入到当前所有匹配元素的后面 替换 replaceWith(content) 用指定内容替换所有匹配的标签删除节点 删除 empty() 删除所有匹配元素的子元素 remove() 删除所有匹配的元素 事件处理 事件绑定 eventName(function(){}) 绑定对应事件名的监听, 例如：$(‘#div’).click(function(){}) on(eventName, funcion(){}) 通用的绑定事件监听, 例如：$(‘#div’).on(‘click’,”a”, function(){}) 常用事件 click / mouseenter / mouseleave / focus / blur / hover 区别 eventName: 编码时绑定元素必须存在,不能给后添加的元素绑定该事件 on: 可以利用事件委派,将事件绑定在父元素上,事件可以冒泡到目标元素上 事件解绑 off(eventName) 事件的坐标 event.clientX,event.clientY 相对于浏览器窗口的左上角 event.pageX,event.pageY 相对于当前页面的左上角 event.offsetX, event.offsetY 相对于事件元素左上角 事件处理 event.stopPropagation() 停止事件冒泡 event.preventDefault() 阻止事件默认行为 事件委托 事件委托(委派/代理) 将多个子元素的事件监听委托给父辈元素处理 事件监听绑定在父辈元素上 当操作子元素时, 事件会冒泡到父辈元素 父辈元素不会直接处理事件, 而是根据event.target得到发生事件的子元素, 通过这个子元素调用事件回调函数 事件委托的两方 委托方: 子元素 被委托方: 父元素 使用事件委托的好处 添加新的子元素, 自动有事件响应处理 减少事件监听的数量: n==&gt;1 jQuery的事件委托API 设置事件委托: $(parentSelector).delegate(childrenSelector, eventName, callback) 移除事件委托: $(parentSelector).undelegate(eventName) 动画效果 淡入淡出: 不断改变元素的透明度opacity来实现的 fadeIn(&quot;speed&quot;): 带动画的显示 fadeOut(&quot;normal&quot;): 带动画隐藏 fadeToggle(): 带动画切换显示/隐藏 滑动动画: 不断改变元素的高度width来实现的 slideDown(&quot;speed&quot;): 带动画的展开 slideUp(&quot;slow&quot;): 带动画的收缩 slideToggle(): 带动画的切换展开/收缩 显示隐藏，默认没有动画 通过同时改变宽 高 透明度来实现 show(&quot;speed&quot;): 不带动画的显示 hide(&quot;fast&quot;): 不带动画的隐藏 toggle(): 不带动画的切换显示/隐藏 jQuery动画本质 : 在指定时间内不断改变元素样式值来实现的 animate(params,[speed]): 自定义动画效果的动画 params: 包含一个或多个需要操作属性和最终值的对象 移动指定距离 可以用{left : &#39;+=100&#39;} , {top : &#39;-=50&#39;} stop(): 停止动画 多库共存和插件多库共存 问题: 如果有2个库都有$, 就存在冲突 解决: jQuery库可以释放$的使用权, 让另一个库可以正常使用, 此时jQuery库只能使用jQuery了 API: jQuery.noConflict() window.onload与$(document).ready()的区别: window.onload 包括页面的图片加载完后才会回调(晚) 只能有一个监听回调 $(document).ready() 等同于: $(function(){}) 页面加载完就回调(早) 可以有多个监听回调 插件 扩展jQuery的工具方法 $.extend(object) 扩展jQuery对象的方法 $.fn.extend(object) 将需要扩展的一个或多个方法封装成对象传入 方法名: function(){}]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>jq</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML笔记]]></title>
    <url>%2F2018%2F09%2F09%2FHTML%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[HTMLHTML标签head123456789&lt;!DOCTYPE html&gt;&lt;head lang="zh-CN"&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;标题必须在charset之后&lt;/title&gt; &lt;meta name="keywords" content="HTML5,CSS3,JAVASCRIPT"&gt; &lt;meta name="description" content="描述网页信息"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0"&gt; &lt;link rel="shortcut icon" href="favicon.ico必须放在根目录"&gt;&lt;/head&gt; body123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;h1&gt; h1表示网页中的主要内容 对于搜索引擎来说h1重要性仅次于title 页面中只能写一个h1 一般在页面中只使用h1 2 3&lt;/h1&gt;&lt;div class="box"&gt;块级盒子多用于布局&lt;/div&gt;&lt;p&gt;段落,承载文字&lt;/p&gt;换行&lt;br&gt;水平线&lt;hr&gt;实体符 &amp;lt; &amp;gt; &amp;nbsp;&lt;img src="路径" title="多余的 title 影响看图体验，并且增加了页面尺寸" alt="提高图片加载失败时的用户体验"&gt;&lt;!-- 产品 logo、用户头像、用户产生的图片等有潜在下载需求的图片，以 img 形式实现，能方便用户下载。 无下载需求的图片，比如：icon、背景、代码使用的图片等，尽可能采用 CSS 背景图实现。--&gt;&lt;iframe src="#" name="flag"&gt;内联框架&lt;/iframe&gt;&lt;a target="_blank" href="#" title="悬停提示"&gt;target="flag"在内联框架中打开&lt;/a&gt;&lt;a href="#id"&gt;跳转到指定ID位置&lt;/a&gt;&lt;h1 title="鼠标悬停提示文字"&gt;&lt;/h1&gt;&lt;em&gt;斜体/语气强调&lt;/em&gt;&lt;strong&gt;加粗/内容强调&lt;/strong&gt;&lt;small&gt;细则内容/合同中的小字或版权内容等&lt;/small&gt;&lt;cite&gt;引用内容/书名歌名电影等&lt;/cite&gt; &lt;q&gt;短引用/引用别人说的话&lt;/q&gt;&lt;blockquote&gt;长引用/块引用&lt;/blockquote&gt;&lt;sup&gt;上标&lt;/sup&gt;&lt;sub&gt;下标&lt;/sub&gt;&lt;del&gt;删除&lt;/del&gt;&lt;ins&gt;插入&lt;/ins&gt;&lt;abbr&gt;缩写&lt;/abbr&gt;&lt;pre&gt;预格式/保留格式&lt;/pre&gt;&lt;code&gt;文本为代码&lt;/code&gt;&lt;ul type="设置样式"&gt; &lt;li&gt;无&lt;/li&gt; &lt;li&gt;序&lt;/li&gt; &lt;li&gt;列&lt;/li&gt; &lt;li&gt;表&lt;/li&gt;&lt;/ul&gt;&lt;ol type="设置样式"&gt; &lt;li&gt;有&lt;/li&gt; &lt;li&gt;序&lt;/li&gt; &lt;li&gt;列&lt;/li&gt; &lt;li&gt;表&lt;/li&gt;&lt;/ol&gt;&lt;dl&gt; &lt;dt&gt;自定义内容&lt;/dt&gt; &lt;dd&gt;内容描述&lt;/dd&gt;&lt;/dl&gt;&lt;table border="1px"&gt; &lt;thead&gt; &lt;th&gt;表&lt;/th&gt; &lt;th&gt;头&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td colspan="2"&gt;左右合并&lt;/td&gt; &lt;td rowspan="2"&gt;上下合并&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;tr行&lt;/td&gt; &lt;td&gt;td列&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;/tfoot&gt;&lt;/table&gt;&lt;form action="index.html" method="get"&gt; &lt;!--有文本标题的控件必须使用 label 标签将其与其标题相关联--&gt; &lt;label for="id"&gt;嵌套或者 for 属性指向控件的 id&lt;/label&gt; &lt;label&gt;文本:&lt;input type="text" name="username" placeholder="提示信息"&gt;&lt;/label&gt; &lt;label&gt;密码:&lt;input type="password"&gt;&lt;/label&gt; &lt;label&gt;邮件:&lt;input type="email"&gt;&lt;/label&gt; &lt;label&gt;单选框:&lt;input type="radio" name="gender" value="boy" checked="checked"&gt; &lt;input type="radio" name="gender" value="girl"&gt;&lt;/label&gt; &lt;label&gt;多选框:&lt;input type="checkbox" name="like" value="football"&gt; &lt;input type="checkbox" name="like" value="pingpang"&gt;&lt;/label&gt; &lt;label&gt; 下拉列表: &lt;select name="love" &gt;&lt;!--multiple="multiple" 可多选--&gt; &lt;option value="one"&gt;1&lt;/option&gt; &lt;optgroup label="分组"&gt; &lt;option value="two" selected="selected"&gt;2&lt;/option&gt; &lt;/optgroup&gt; &lt;option value="three"&gt;3&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; &lt;label&gt;文本域:&lt;textarea name="info" style="resize: none"&gt;&lt;/textarea&gt;&lt;/label&gt; &lt;label&gt;提交:&lt;input type="submit" value="YES"&gt;&lt;/label&gt; &lt;label&gt;重置:&lt;input type="reset"&gt;&lt;/label&gt; &lt;input type="button" value="按钮"&gt; &lt;!--button必须指定type 尽量不要使用name属性--&gt; &lt;button type="button"&gt;按钮2&lt;/button&gt; &lt;button type="submit"&gt;提交2&lt;/button&gt; &lt;button type="reset"&gt;重置2&lt;/button&gt; &lt;fieldset&gt; &lt;legend&gt;组名&lt;/legend&gt; &lt;/fieldset&gt;&lt;/form&gt; CSS css 全部在head中引入 常用规则: 选择器 {空格隔开} 属性: 值 (无空格: 有空格) ,并集多个选择器时每个选择器独占一行 ~ + &gt;符号两边使用空格隔开 属性值&quot;&quot;多个属性 , 结尾; 嵌套层级不大于3, 靠后的限定条件应尽可能精确 border/margin/padding尽量不使用缩写,其他属性尽量使用缩写 属性书写顺序: 如果包含 content 属性，放在最前面 Formatting Model 相关属性包括：position / top / right / bottom / left / float / display / overflow 等 Box Model 相关属性包括：border / margin / padding / width / height 等 Typographic 相关属性包括：font / line-height / text-align / word-wrap 等 Visual 相关属性包括：background / color / transition / list-style 等 通过对伪类设置 clear 或触发 BFC 的方式进行clearfixBFC触发 float 非 none position 非 static overflow 非 visible 当数值为 0 - 1 之间的小数时，省略整数部分的 0 例如.5 url()函数中的路径不加引号 RGB颜色值必须使用十六进制记号形式 #rrggbb, rgba()每个逗号后必须保留一个空格 颜色值可以缩写时,必须使用缩写形式, 不允许使用命名色值 font-family使用 字体英文名 字体不小于12px 按「西文字体在前、中文字体在后」「效果佳的字体在前、效果一般的字体在后」的顺序编写，最后必须指定一个通用字体族( serif / sans-serif ) 尽可能在浏览器能高效实现的属性上添加过渡和动画: transform: translate(npx, npx) transform: scale(n) transform: rotate(ndeg) opacity: 0~1 ​ 典型的，可以使用 translate 来代替 left 作为动画属性 选择器1234567891011121314151617181920212223242526272829303132333435363738* 通配选择器# ID选择器 . 类选择器 , 并集选择器(或) "" 交集选择器(与):first-of-type 同一类型的第一个:last-of-type 同一类型的最后一个:nth-of-type(n) 同一类型的第n个 子元素 : &gt; 子元素选择器 " " 后代选择器 :first-child 第一个子元素 :last-child 最后一个子元素 :nth-child(n) 第n个子元素（even偶 odd奇）兄弟元素 : + 紧接着的兄弟元素 ~ 后面的所有兄弟元素伪类 : 特殊状态的元素 :link 正常链接(未访问) :visited 已访问链接(只能设置颜色) :hover 鼠标悬停 :active 点击状态 :focus 获取焦点 ::selection 内容被选中状态否定伪类 : :not(选择器) 从选中的元素中排除伪元素 : 特殊位置的元素 ::first-letter 首字母 ::first-line 首行 ::before 之前 ::after 之后属性选择器 : "[属性名]" 含有指定属性的元素 "[属性名=属性值]" 含有指定属性值的元素 "[属性名^=内容]" 属性值以指定内容开头的元素 "[属性名$=内容]" 属性值以指定内容结尾的元素 "[属性名*=内容]" 属性包含指定内容的元素 权重 !important 10000 内联样式 1000 id选择器 100 类和伪类 10 元素和伪元素 1 通配* 0 继承样式 - 并集选择器分开计算 样式字体 1234567891011121314151617181920212223242526272829font-size: 12px/1;text-decoration: none;letter-spacing: 10px;/* 字符间距 */word-spacing: 5px;/* 单词(空格)间距 */text-align: center;/* 首行缩进 */text-indent: 2em;font-family: 微软雅黑, 宋体;/* 斜体 */font-style: italic;/* 400正常 700加粗 */font-weight: 400;/* 小型大写字母 */font-variant: small-caps/* font: 必须以 字体大小,字体 结尾行间距 = line-height - font-size单行文本 line-height = height 设置垂直居中*/ 显示省略号 1234display: block;white-space: nowrap;text-overflow: ellipsis;overflow: hidden; 表格 12345border-spacing: 5px;/* 合并单元格 */border-collapse: collapse;/*移入鼠标样式*/cursor: pointer; 常用样式 1234567891011121314151617width: 100px;height: 100px;background-color: greenyellow;background-image: url();background-repeat: no-repeat;background-position: 100px center;border: 2px solid red;/*display: none; 不占有空间*//*visibility: hidden; 隐藏但继续占有空间*//*配合绝对定位使用*/z-index: 1;/* opacity 是元素透明度 rgba() 是透明色 */opacity: 0.3;filter: alpha(opacity=30); 定位1234position: 子绝父相absolute 绝对定位 (相对于最近的开启定位的祖先元素位置/脱离文档流/改变元素性质)relative 相对定位 (相对默认位置/不脱离文档流)fixed 固定定位 (相对于浏览器窗口位置/也属于绝对定位) 当子元素浮动时, 子元素脱离文档流无法撑起父元素的高度, 导致父元素高度塌陷 解决方法开启间接BFC, 设置父元素overflow: hidden 外边距塌子元素和父元素相邻的垂直外边距会发生重叠, 子元素的外边距会传递给父元素, 可以使用空的 table 标签来隔断它们 解决父子元素的外边距塌陷方法 border:1px solid transparent padding float:left/right position:absolute display:inline-block overflow:hidden/auto clearfix1234567.clearfix:before,.clearfix:after &#123; content: ""; line-height: 0; display: table; clear: both;&#125; 双飞翼布局1234567&lt;div class="clearfix"&gt; &lt;div id="mid"&gt; &lt;div id="centent"&gt;content&lt;/div&gt; &lt;/div&gt; &lt;div id="left"&gt;&lt;/div&gt; &lt;div id="right"&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627#mid &#123; width: 100%; height: 200px; background-color: greenyellow; float: left; overflow: hidden;&#125;#left &#123; width: 100px; height: 200px; background-color: rosybrown; float: left; margin-left: -100%;&#125;#right &#123; width: 100px; height: 200px; background-color: cornflowerblue; float: left; margin-left: -100px;&#125;#content &#123; margin: 0 100px;&#125; 语义化 什么是语义化 让机器可以读懂内容 (SEO, 屏幕阅读器, 爬虫) ​ 其他程序员能见文知意 (方便维护) 做法 1. 全局只有一个`h1`就是它的logo, 分栏`h2`, 再细分`h3` 2. 尽量少用`div`和`span`, `div`布局`p`显示内容 3. html标签注重语义, css实现样式 4. 表格 标题使用`caption`主体分`thead` `tbody` `tfoot`, 表头用`th`单元格用`td` 5. 表单输入关联`lable`标签 viewportpc端视窗的大小直接根据浏览器窗口的大小来决定 在移动设备中 浏览器和网页之间 有一层虚拟容器 viewport 用来承载网页 该容器默认宽度980px, 可以设置缩放 标准化适配: 网页宽度 = 视窗宽度 = 浏览器宽度(设备屏幕大小) 缩放1 (保持和PC端一致) 不允许用户缩放 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0"&gt; 布局浮动会提升半层 (定位一层) 下层为盒模型, 上层为内容 上面的div浮动, 盒模型层级为1 内容层级为1.5 下面的div不浮动 盒模型为0.5 所以向上填充, 内容层级为1 所以被浮动div的盒模型卡住 所以保持原位不动 三列布局 中间列写在最上面 三列浮动搭建完整的框架 margin 为负值调整旁边两列的位置 (使三列布局到一行上) 使用padding和相对定位调整内容位置(圣杯) 多加一个div来调整内容位置(双飞翼) 伪等高布局123padding-bottom: 2000px 撑开背景margin-bottom: -2000px 收回边界父元素 overflow: hidden 隐藏多余部分 粘连布局(css sticky footer)12345678910&lt;div id="main"&gt;min-height: 100%; &lt;div&gt; padding-bottom: 100px; &lt;/div&gt;&lt;/div&gt;&lt;div class="footer"&gt;height: 100px;margin-top: -100px;&lt;/div&gt; 定位定位参照 相对于最近的 开启了定位的 祖先元素 (子绝父相) 都没有开启定位的父元素 则相对于初始包含块 固定定位参照于视口 包含块浮动元素 包含块为最近的块级祖先元素 定位元素 根元素html的包含块 就是初始包含块, 由用户代理创建, 初始包含块默认和视口的大小及位置相同 初始包含块不等于视口 非根元素position是relative或static包含块则是最近的块级(表单元格或行内块)祖先框的内边界构成 百分比参照 left和top 默认值为 auto(原位置不动) 不是0 margin和padding的百分比 相对于父元素的 width 绝对定位模拟固定定位 html {overflow: hidden}静止系统滚动条 body {overflow: auto}将滚动条添加给body 将body的尺寸设为视口的尺寸 初始包含块固定, body滚动 BFC定义: block formatting context (块级格式化上下文) 它是一个独立的渲染区域, 只管理内部的块级元素布局, 且不会影响BFC外部 BFC布局规则(5种) 内部块级元素独占一行 内部的BFC区域不与浮动盒子重叠 两列布局: 上div 浮动, 下div BFC 内部的Box垂直方向的距离由margin决定, 同一个BFC内.的两个相交的块级盒子的margin会发生重叠 解决方法嵌套一个触发BFC的div或使用padding 计算BFC高度时, 浮动元素也参与计算 清除浮动 BFC是独立容器内外不会相互影响 BFC触发方式(5种) 根元素 float元素 定位元素 overflow元素 display为 inline-block, table-cell, table-caption, flex, inline-flex FLEX布局 注意: 设为 Flex 布局以后, 子元素的float、clear和vertical-align属性将失效 父元素设置为弹性盒子 1display: flex; 设置主轴方向,换行 默认: row水平 nowrap不换行 1flex-flow: column; 设置子元素主轴方向对齐方式 默认 flex-start 沿主轴排列 1234justify-content: centercenter 居中: 向中心靠齐, 多余空间平分到两端space-between 两端对齐: 两端贴边, 多余空间 平局分布在中间space-around 等外边距对齐: 最外侧的边距只有中间的 1/2 设置子元素交叉轴方向对齐方式 默认 stretch 填满交叉轴 设置第一行内每个元素的对齐 所以多行不生效 123align-items: centercenter 居中: 向中心靠齐, 多余空间平分到两端baseline 以第一行文字的基线(底部)对齐 设置内部有多行子元素时的对齐方式 默认 stretch 填满交叉轴 把每一行 当做一个元素来看 所以单行不生效 1234align-content: centercenter 居中: 向中心靠齐, 多余空间平分到两端space-between 两端对齐: 两端贴边, 多余空间 平局分布在中间space-around 等外边距对齐: 最外侧的边距只有中间的 1/2 设置子元素缩放比例 默认为0 1 auto 1230 (空间多余时按设置比例放大. 默认0不放大, n表示占剩余空间的n份) 1 (空间不足时按设置比例缩小. 0的元素不缩小, 都设置为1则等比例缩小) auto (元素的大小) 可以单独配置某个元素的对齐方式 覆盖父元素align-items设置 1align-self: auto 居中 块级元素水平居中 margin: 0 auto; 块级元素垂直居中 vertical-align:middle; position: absolute; top: 50%; transform: translateY(-50%); 内联元素水平居中 text-align: center; 内联元素垂直居中 line-height = height;]]></content>
      <categories>
        <category>Html</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax笔记]]></title>
    <url>%2F2018%2F09%2F07%2FAjax%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[AJAXAJAX请求是异步执行的，也就是说，要通过回调函数获得响应。 在现代浏览器上写AJAX主要依靠XMLHttpRequest对象 AJAX请求AJAX 是一套 API 核心提供的类型 : XMLHttpRequest AJAX 操作的页面 “不能” 使用文件的方式访问 新建用户代理 状态0 初始化请求代理对象 1const xhr = new XMLHttpRequest 设置请求行 状态1 建立一个与服务端特定端口的连接 1xhr.open('GET/POST', URL) 设置请求头/体 携带请求参数 12xhr.setRequestHeader('Content-Type', 'application/x-www-from-urlencoded(/json)')xhr.send(null/'key=value') 等待响应 每当 readyState 改变时触发回调函数 1234567891011121314151617181920xhr.onreadystatechange = function () &#123; // 状态2 表示已经收到响应头 if (this.readyState === 2) &#123; console.log(this.getAllResponseHeaders()) &#125; // 状态3 表示正在下载响应体 if (this.readyState === 3) &#123; console.log('响应体responseText可能不完整') &#125; // 状态4 表示响应报文全部下载完成 if (this.readyState === 4) &#123; // this.status === 200 时表示下载成功 if (this.status === 200) &#123; //响应体数据在 this.responseText 里 var data = JSON.parse(this.responseText) &#125; else &#123; console.log('请求失败') &#125; &#125;&#125; GET和POST对于一个返回数据的地址我们称之为接口(API) GET (一般用于获取数据) POST (一般用于提交数据) 可见性 数据在 URL 中对所有人都是可见的 数据不会显示在 URL 中,但可以开发者工具或者抓包可以看到 后退按钮/刷新 无害 数据会被重新提交（浏览器应该告知用户数据会被重新提交） 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 历史 参数保留在浏览器历史中 参数不会保存在浏览器历史中 对数据长度的限制 受浏览器限制 一般无限制 对数据类型的限制 只允许 ASCII 字符 没有限制 也允许二进制数据 编码类型 /x-www-form-urlencoded /x-www-form-urlencoded 或 multipart/form-data 为二进制数据使用多重编码 安全性 GET 的安全性较差，因为所发送的数据是 URL 的一部分 POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中 请求过程 对于GET方式的请求,浏览器会把http header和data一并发送出去,服务器响应200(返回数据) 对于POST,浏览器先发送header,服务器响应100 continue,浏览器再发送data,服务器响应200(返回数据) jQuery.ajax使用jQuery发送ajax请求 1234567891011121314151617181920212223242526272829$.ajax(&#123; type: 'get', url: 'url', data: &#123; key: value &#125;, dataType: 'json', // 设置响应体类型 success: function (res) &#123; console.log('请求成功' + res) &#125;, error: function (err) &#123; console.log('请求失败') &#125;, complate: function () &#123; console.log('请求完成回调') &#125;&#125;)// get请求简便写法$.get('url', &#123;data&#125;, function (res) &#123;&#125;)// post请求简便写法$.post('url', &#123;data&#125;, function (res) &#123;&#125;)// 请求 + JSON转换$.getJSON('url', &#123;data&#125;, function (res) &#123;&#125;) load方法pjax:jQuery.load方法局部刷新页面 1$('#div').load('url #refresh') 它将检索 url 返回的页面内容获取ID为 #refresh 元素的内容并且插入到ID为 #div 元素而其他未被检索到的元素将被废弃 ajax请求时切换loading状态 123456$(document).ajaxStart(function () &#123; $('#loading').show()&#125;)$(document).ajaxStop(function () &#123; $('#loading').hide()&#125;) 跨域请求同源策略指的就是:不同源地址之间,默认不能相互发送AJAX请求 不同源地址之间如果需要相互请求,必须服务器和客户端配合才能完成 JSONP:借助script标签发送跨域请求 动态设置script标签的src属性 12let randomFun = 'jsonp_' + Date.now()script.src = url + '?' + 参数 + '&amp;callback=' + randomFun 定义回调函数: 1234window[randomFun] = function (data) &#123; delete window[randomFun] document.body.removeChild('script')&#125; 服务端配合: 1header("Content-Type: application/javascript") 返回调用随机函数的代码,并将要传递的数据作为实参: 随机函数名(data) jQuery中使用JSONP调用方法和ajax相同, 只需要设置 dataType: “jsonp” CORS( 跨域资源共享):服务器设置 header(&#39;Access-Control-Allow-Origin: *&#39;)]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>ajax</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6笔记]]></title>
    <url>%2F2018%2F09%2F07%2FES6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ES6ECMA和严格模式ECMA 它是一种由ECMA组织（前身为欧洲计算机制造商协会）制定和发布的脚本语言规范 我们学的JavaScript是ECMA的实现, 但术语ECMAScript和JavaScript平时表达同一个意思 JS包含三个部分： ECMAScript（核心） 扩展 ==&gt; 浏览器端 BOM（浏览器对象模型） DOM（文档对象模型） 扩展 ==&gt; 服务器端 ES的几个重要版本 ES5: 09年发布 * ES6 (ES2015): 15年发布, 也称为ECMA2015 * ES7 (ES2016): 16年发布, 也称为ECMA2016 (变化不大) 严格模式 理解 除了正常运行模式(混杂模式)，ES5添加了第二种运行模式: “严格模式” (strict mode) 顾名思义，这种模式使得Javascript在更严格的语法条件下运行 目的/作用 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 消除代码运行的一些不安全之处，为代码的安全运行保驾护航 为未来新版本的Javascript做好铺垫 使用 在全局或函数的第一条语句定义为: &#39;use strict&#39; 如果浏览器不支持, 只解析为一条简单的语句, 没有任何副作用 语法和行为改变 必须用var声明变量 禁止自定义的函数中的this指向window 创建eval作用域 对象不能有重名的属性 ES5拓展JSON拓展1JSON.stringify(obj/arr) js对象(数组)转换为json对象(数组) 1JSON.parse(json) json对象(数组)转换为js对象(数组) Object拓展ES5给Object扩展了一些静态方法, 常用的2个 Object.create(新创建对象的原型对象, [可选: 新建对象自身属性描述符]) 作用: 以指定对象为原型创建新对象作为返回值返回 可以为新的对象指定自身的属性(一个或多个属性都需要封装成对象传入) 对每个属性的数据属性进行描述(描述也需要封装成对象,包含以下属性) value: 属性的默认值 writable: 属性值是否是可修改 默认为false configurable: 属性是否可重新定义 默认为false enumerable: 属性是否能用for in枚举 默认为false Object.defineProperties(obj, prop, descriptor) 作用: 为指定对象精确添加或修改对象的属性(属性描述符封装成对象传入) 数据描述符: configurable: 该属性是否可重新定义 writable: 该属性值是否是可修改 value: 该属性的默认值 enumerable: 该属性是否能用 for in 枚举 访问描述符: 123get: function ()&#123; return 值&#125; 设置扩展属性的值的回调函数, 在使用扩展属性的时候才调用, 返回动态计算出的该属性的值(惰性求值) 123set: function(newValue)&#123; return 值&#125; 修改扩展属性的值时触发的回调函数, 修改后的值作为实参传入 Array方法拓展12345678910111213141516// 得到值在数组中的第一个下标arr.indexOf(value)// 得到值在数组中的最后一个下标arr.lastIndexOf(value)// 遍历数组arr.forEach(function(item, index)&#123; // 回调函数&#125;)// 遍历数组将加工后的值 作为新数组返回arr.map(function(item, index)&#123; // 回调函数&#125;)// 遍历过滤出一个新的子数组， 返回条件为true的值arr.filter(function(item, index)&#123; // 回调函数&#125;) Function拓展1fun.bind(obj, 参数 ,...) 作用: 将函数内的this绑定为obj, 但并不执行函数,而只将函数返回 面试题: 区别bind()与call()和apply()? 都能指定函数中的this call(obj, 参数,...)/apply(obj, [参数,...])会立即调用函数,传参不一样 bind(obj, 参数 ,...)不执行函数,只将函数返回 Let 和 Constlet 关键字 作用: 与var类似, 用于声明一个变量 特点: 在块作用域内有效 (ES6中添加) 不能重复声明同名变量 不会预处理, 既不存在变量提升 应用: 循环遍历加监听 使用let取代var是趋势 const 关键字 作用: 定义一个常量 (不可改变引用) 特点: 不能修改 对象可以修改它的属性,但是不能重新赋值引用 其它特点同let 应用: 保存不用改变的数据 解构赋值和模板字符串解构赋值 理解: 相当于声明了多个(一个)变量, 变量的值在赋值的对象或数组里取对应的值 对象的解构赋值(属性名必须对应) let {a, b} = {a:&#39;xxx&#39;, b:&quot;yyy&quot;} 数组的解构赋值(根据下标对应取值) let [a, b] = [1, &#39;zzz&#39;] 用途 给多个形参赋值 模板字符串 作用简化字符串的拼接 模板字符串必须用 包裹 变量部分使用 ${xxx} 包裹 对象简写简化写法总结: 属性名和属性值相同可以省略 对象的方法和function同名可以省略方法名 12345678910let x = 1;let y = 2;let obj = &#123; x, yfun()&#123; //语句 &#125;&#125; 箭头函数 作用: 方便定义匿名函数, 调整**this**指向 基本语法: (形参) =&gt; {函数内容} 没有形参时, 需要用括号占位 一个参数时, 括号可以省略 函数体只有一条语句时, 可以不用大括号, 默认return语句执行后的结果 函数体如果有多条语句: 需要用{}包裹, 若有需要返回的内容需要设置return 常用场景: 回调函数 this 箭头函数没有自己的this 它的this不是调用时决定的 它的this指向箭头函数定义时所属的作用域 理解: * 箭头函数的`this`看它的外层是否有其他函数 * 如果有, 箭头函数的`this`和外层函数相同 * 如果没有, 则指向 `window` … 运算符和形参默认值…运算符用途 可变参数 比arguments更灵活, 但只能搜集末尾所有未接收的实参,以数组保存 12345678function fun(n, ...values) &#123; console.log(arguments); // arguments是伪数组,所以无法用forEach遍历 console.log(values); values.forEach(function (item, index) &#123; console.log(item, index); // n 接收了第一个实参,所以只能打印出2,3 &#125;)&#125;fun(1,2,3); 拓展运算符123456// 将arr1插入arr2中let arr1 = [1,3,5];let arr2 = [2,...arr1,6];// 将数组arr1中的元素依次push到arr2中arr2.push(...arr1); 形参默认值当不传入参数的时候使用形参里的默认值 123function fun(x = 1,y = 2) &#123; // 函数传实参则使用实参, 不传则使用默认值&#125; Promisepromise 主要用于处理异步请求 语法 123456789101112131415161718192021222324252627let promise = new Promise(function(resolve, reject) &#123; // pending: 初始状态 // 定义时立即执行 异步操作&#123; if (boolean) &#123; //fulfilled: 操作成功完成 resolve(data) &#125; else &#123; //rejected: 操作失败 reject("失败") &#125; &#125;&#125;)// 定义异步完成后的回调函数// 异步完成后根据结果执行对应的回调函数promise.then(function(resolve) &#123; //成功时执行的函数&#125;, function(reject) &#123; //失败时,执行的函数&#125;)// 也可以用catch捕获失败promise.then(resolve =&gt; &#123; // 只传入成功回调&#125;).catch(reject =&gt; &#123; // 用catch捕获失败&#125;) 注意点 Promise构造函数执行时立即调用传入的函数 resolve 和 reject 两个回调函数作为参数 调用resolve()时修改状态为成功 fulfilled 调用reject()时修改状态为失败 rejected then()最多可传入两个回调函数, 对应异步成功和失败 then()的返回值仍然是个promise对象 Symbol概念: ES6中添加的一种原始数据类型 symbol 已有的6种原始数据类型：String, Number, Boolean, null, undefined, Object 特点: Symbol表示一个唯一的值，解决命名冲突问题 Symbol的值不能与其他数据进行计算，包括同字符串拼串 for in, for of遍历时不会遍历symbol属性 使用: 调用Symbol函数得到symbol值 注意: 不能使用new symbol作为属性名时必须使用属性选择器 [] 1234// 该方法创建的symbol不放入全局Symbol注册表中let symbol = Symbol()let obj = &#123;&#125;obj[symbol] = 'hello' 标识symbol: 1234let symbol = Symbol('one');let symbol2 = Symbol('two');console.log(symbol); // Symbol('one')console.log(symbol2); // Symbol('two') Iterator 概念: iterator是一种接口机制, 为各种不同的数据结构提供统一的访问机制 作用: 为各种数据结构, 提供一个统一的、简便的访问接口 使得数据结构的成员能够按某种次序排列 ES6创造了一种新的遍历命令for...of循环，iterator接口主要供for...of使用 工作原理: 创建一个指针对象(遍历器对象), 指向数据结构的起始位置 第一次调用next()方法, 指针自动指向数据结构的第一个成员 接下来不断调用next()方法, 指针会一直往后移动, 直到指向最后一个成员 每次调用next()方法返回的是一个包含value和done的对象 {value: 当前成员的值, done: 布尔值} value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束 当遍历结束的时候返回的value值是undefined，done值为false 原生具备iterator接口的数据: Array arguments String set map 当使用 for of 去遍历某一个数据结构时 首先在目标上找Symbol.iterator 找到则可以用for of遍历 否则报错 ...运算符 和 解构赋值 默认也是调用iterator接口 123456789101112131415161718function iteratorFun(obj) &#123; let i = 0 return &#123; next() &#123; return &#123; value: obj.data[i++], done: i &gt; obj.data.length &#125; &#125; &#125;&#125; let obj = &#123; data: ["无", "聊", "大", "作", "战"] , [Symbol.iterator]() &#123; return iteratorFun(this) &#125;&#125; Generator 概念 生成器函数在执行时能暂停, 后面又能从暂停处继续执行 调用一个生成器函数并不会马上执行它里面的语句, 而是返回一个这个生成器的迭代器/遍历器(iterator)对象 当这个遍历器的next()方法被调用时, 其内的语句会执行到出现yield的位置为止 包括紧跟yield的语句 yield后紧跟遍历器要返回的值 next()方法返回一个对象, 这个对象包含两个属性: value和done value属性表示本次yield表达式的返回值 done属性为布尔类型, 表示生成器后续是否还有yield语句, 即生成器函数是否已经执行完毕并返回 调用next()方法时，如果传入了参数, 那么这个参数会作为上一条执行的yield的值 用途 ES6提供的解决异步编程的方案之一 Generator函数是一个状态机，内部封装了不同状态的数据 用来生成遍历器对象 特点 function与函数名之间有一个星号 内部用yield表达式来定义不同的状态 可暂停函数(惰性求值) 注意 generator函数返回的是指针对象(iterator)，而不会执行函数内部逻辑 调用next()方法函数内部逻辑开始执行，遇到yield表达式停止，返回{value: yield后的表达式结果/undefined, done: false/true} 再次调用next()方法会从上一次停止时的yield处开始, 到下一个yield为止 yield语句返回结果通常为undefined, 当调用next()方法时传参内容会作为启动时yield的返回值 class`class`声明创建一个基于原型继承的具有给定名称的新类. 类声明**不允许**再次声明已经存在的类，否则将会抛出一个类型错误。 123456789101112131415161718192021222324// class 定义类class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; showName() &#123; console.log(this.name) &#125;&#125;let per = new Person("test", 18)// extends 继承类class extendsPer extends Person &#123; constructor(name, age, salary) &#123; // 调用父类的构造方法 (需要传入参数) super(name, age) this.salary = salary &#125; showName() &#123; console.log(this.name + this.salary) &#125;&#125;let extPer = new extendsPer("extTest", 16, 666) 通过class定义类/实现类的继承 在类中通过constructor定义构造方法 通过new来创建类的实例 通过extends来实现类的继承 通过super调用父类的构造方法 可在子类中重写父类中继承的一般方法 类声明不可以提升 方法必须使用简写 字符串/数值拓展字符串 includes(str): 判断是否包含指定的字符串 startsWith(str): 判断是否以指定字符串开头 endsWith(str): 判断是否以指定字符串结尾 repeat(count): 重复指定次数 String.prototype.padStart(maxLength, fillString = &quot;&quot;)或padEnd: 在字符串的开头或结尾处用fillString将它填充到指定长度 数值 二进制与八进制数值表示法: 二进制用0b, 八进制用`0o Number.isFinite(i): 判断是否是有限大的数 Number.isNaN(i): 判断是否是NaN Number.isInteger(i): 判断是否是整数 Number.parseInt(str): 将字符串转换为对应的数值 Math.trunc(i): 直接去除小数部分 数组/对象拓展数组 Array.from(v): 将伪数组对象或可遍历对象转换为真数组 Array.of(v1, v2, v3): 将一系列值转换成数组 find(function(value, index, arr){return true}): 返回第一个满足条件返回true的元素 findIndex(function(value, index, arr){return true}): 返回第一个满足条件返回true的元素下标 对象 Object.is(v1, v2): 判断2个数据是否完全相等 Object.assign(target, source1, source2..): 将源对象的属性复制到目标对象上 直接操作__proto__属性 之前只能通过 构造函数的prototype来操作实例的___proto___ 深度克隆 浅拷贝数据: 拷贝引用, 操作会影响原数据 直接赋值给另一个变量 Object.assign() Array.prototype.concat() Array.prototype.slice() 深拷贝(深度克隆): 生成新数据, 操作不会影响原数据 JSON.parse(JSON.stringify()) 可以拷贝数组和对象, 不能拷贝函数 深度克隆方法: 递归遍历原对象或数组, 遇到对象或数组继续遍历里面的内容, 直到拿到的是基本数据类型才复制 123456789101112131415161718192021222324function typeCheck(test) &#123; //使用 Object 原型上的 toString 方法检测数据类型, 返回数据类型的字符串 return Object.prototype.toString.call(test).slice(8, -1)&#125;function copy(obj) &#123; let res if (typeCheck(obj) === "Object") &#123; res = &#123;&#125; &#125; else if (typeCheck(obj) === "Array") &#123; res = [] &#125; else &#123; return obj &#125; for (let i in obj) &#123; if (typeCheck(obj[i]) === "Object" || typeCheck(obj[i]) === "Array") &#123; let obj2 = copy(obj[i]) res[i] = obj2 &#125; else &#123; res[i] = obj[i] &#125; &#125; return res&#125; Set和Map容器set**无序**不可重复, 可存储任何数据类型, 无论是原始值或者是对象 语法: let mySet = new Set(xxx) add(value): Set对象尾部添加一个元素, 返回该Set对象 delete(value): 移除Set的中与这个值相等的元素 has(value): 返回一个布尔值, 表示该值在Set中存在与否 clear(): 清空Set对象 size: Set中储存的数据的数量 可以用for...of进行遍历 mySet / mySet.keys() / mySet.values() 数组去重 1234// 用Set构造器将Array转换为Setvar mySet = new Set(myArray)// 用...操作符将Set还原为Arrayconsole.log([...mySet]) map**有序**不可重复, 用于保存键值对, **任何值**(对象或者原始值) 都可以作为一个键或一个值 for...of 循环为每次迭代返回一个[key，value]数组 和Object的区别: Map 的键可以是任意值, 包括函数、对象 Map 中的键值是有序的 size 属性直接获取一个 Map 的键值对个数 Map 是可迭代的 语法: let myMap = new Map([{key1, value1}, {key2, value2}...]) set(key, value): 像Map中添加数据, 返回该Map对象 get(key): 返回键对应的值，如果不存在，则返回undefined delete(key): 移除任何与键相关联的值，并且返回该值 has(key): 返回一个布尔值，表示Map实例是否包含键对应的值 clear(): 移除Map对象的所有键 / 值对 size: 返回Map 的键值对个数 for…of 遍历数组 遍历Set 遍历Map 遍历字符串 遍历伪数组 for...of / for...in / forEach 的区别: for...in index索引为字符串型数字, 不能直接进行几何运算 遍历顺序有可能不是按照实际的内部顺序 使用for...in会遍历数组所有的可枚举属性, 包括原型上的 适合遍历对象 index ==&gt; key for...of 遍历的只是数组内的元素, 而不包括数组的原型 不能遍历普通对象, 因为没有 iterator 接口 适合遍历数组 index ==&gt; value forEach(callback(Value, index, arr)) 对数组的每个元素执行一次提供的回调函数 只能遍历数组 无法break或者return中断 async函数async 函数 当调用一个async函数时, 会返回一个Promise对象 当这个async函数返回一个值时, Promise的resolve()方法会负责传递这个值 当async函数抛出异常时, Promise的reject()方法也会传递这个异常值 async函数中可能会有await表达式, 可以使async函数暂停执行 等表达式中的Promise解析完成后继续执行async函数并返回解决结果 await 表达式 会暂停当前async函数的执行, 等待Promise处理完成 若Promise正常处理(fulfilled), 其回调的resolve函数参数作为await表达式的值，继续执行async函数 若Promise处理异常(rejected), await表达式会把Promise的异常原因抛出 如果await操作符后的表达式的值不是一个Promise, 那么该值将被转换为一个已正常处理的Promise 注意: await关键字仅仅在async function中有效 概念: 真正意义上去解决异步回调的问题，同步流程表达异步操作 本质: Generator的语法糖 12345async function fun() &#123; // await后面执行异步操作, 前面保存异步结果 const result = await ajax() console.log(result)&#125; 特点: 不需要像Generator去调用next()方法, 遇到await等待, 当前的异步操作完成就往下执行 返回的总是Promise对象, 可以用then()方法进行下一步操作 async取代 Generator 函数的星号*, await取代 Generator 的yield 语意上更为明确, 使用简单, 暂时没有任何副作用 模块化export暴露数据 1234567891011121314151617export function test() &#123; console.log("暴露test函数")&#125;export let arr = [1, 2, 3]// 可以将要暴露的多函数放到一个对象里function fun1() &#123; console.log("fun1")&#125;function fun2() &#123; console.log("fun2")&#125;export &#123;fun1, fun2&#125;// 默认暴露 --- 可以暴露任意数据类型, 暴露什么类型的数据接收到的就是什么数据// 一个文件只能使用一次 export default 引入直接用一个变量接收即可export default xxx import引入数据 12import &#123;fun1, fun2&#125; from &quot;./路径/文件名&quot;import xxx from &quot;./xxx.js&quot;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
</search>
