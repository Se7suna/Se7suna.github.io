<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTML笔记]]></title>
    <url>%2F2018%2F09%2F09%2FHTML%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[HTMLHTML标签head123456789&lt;!DOCTYPE html&gt;&lt;head lang="zh-CN"&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;标题必须在charset之后&lt;/title&gt; &lt;meta name="keywords" content="HTML5,CSS3,JAVASCRIPT"&gt; &lt;meta name="description" content="描述网页信息"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0"&gt; &lt;link rel="shortcut icon" href="favicon.ico必须放在根目录"&gt;&lt;/head&gt; body123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;h1&gt; h1表示网页中的主要内容 对于搜索引擎来说h1重要性仅次于title 页面中只能写一个h1 一般在页面中只使用h1 2 3&lt;/h1&gt;&lt;div class="box"&gt;块级盒子多用于布局&lt;/div&gt;&lt;p&gt;段落,承载文字&lt;/p&gt;换行&lt;br&gt;水平线&lt;hr&gt;实体符 &amp;lt; &amp;gt; &amp;nbsp;&lt;img src="路径" title="多余的 title 影响看图体验，并且增加了页面尺寸" alt="提高图片加载失败时的用户体验"&gt;&lt;!-- 产品 logo、用户头像、用户产生的图片等有潜在下载需求的图片，以 img 形式实现，能方便用户下载。 无下载需求的图片，比如：icon、背景、代码使用的图片等，尽可能采用 CSS 背景图实现。--&gt;&lt;iframe src="#" name="flag"&gt;内联框架&lt;/iframe&gt;&lt;a target="_blank" href="#" title="悬停提示"&gt;target="flag"在内联框架中打开&lt;/a&gt;&lt;a href="#id"&gt;跳转到指定ID位置&lt;/a&gt;&lt;h1 title="鼠标悬停提示文字"&gt;&lt;/h1&gt;&lt;em&gt;斜体/语气强调&lt;/em&gt;&lt;strong&gt;加粗/内容强调&lt;/strong&gt;&lt;small&gt;细则内容/合同中的小字或版权内容等&lt;/small&gt;&lt;cite&gt;引用内容/书名歌名电影等&lt;/cite&gt; &lt;q&gt;短引用/引用别人说的话&lt;/q&gt;&lt;blockquote&gt;长引用/块引用&lt;/blockquote&gt;&lt;sup&gt;上标&lt;/sup&gt;&lt;sub&gt;下标&lt;/sub&gt;&lt;del&gt;删除&lt;/del&gt;&lt;ins&gt;插入&lt;/ins&gt;&lt;abbr&gt;缩写&lt;/abbr&gt;&lt;pre&gt;预格式/保留格式&lt;/pre&gt;&lt;code&gt;文本为代码&lt;/code&gt;&lt;ul type="设置样式"&gt; &lt;li&gt;无&lt;/li&gt; &lt;li&gt;序&lt;/li&gt; &lt;li&gt;列&lt;/li&gt; &lt;li&gt;表&lt;/li&gt;&lt;/ul&gt;&lt;ol type="设置样式"&gt; &lt;li&gt;有&lt;/li&gt; &lt;li&gt;序&lt;/li&gt; &lt;li&gt;列&lt;/li&gt; &lt;li&gt;表&lt;/li&gt;&lt;/ol&gt;&lt;dl&gt; &lt;dt&gt;自定义内容&lt;/dt&gt; &lt;dd&gt;内容描述&lt;/dd&gt;&lt;/dl&gt;&lt;table border="1px"&gt; &lt;thead&gt; &lt;th&gt;表&lt;/th&gt; &lt;th&gt;头&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td colspan="2"&gt;左右合并&lt;/td&gt; &lt;td rowspan="2"&gt;上下合并&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;tr行&lt;/td&gt; &lt;td&gt;td列&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;/tfoot&gt;&lt;/table&gt;&lt;form action="index.html" method="get"&gt; &lt;!--有文本标题的控件必须使用 label 标签将其与其标题相关联--&gt; &lt;label for="id"&gt;嵌套或者 for 属性指向控件的 id&lt;/label&gt; &lt;label&gt;文本:&lt;input type="text" name="username" placeholder="提示信息"&gt;&lt;/label&gt; &lt;label&gt;密码:&lt;input type="password"&gt;&lt;/label&gt; &lt;label&gt;邮件:&lt;input type="email"&gt;&lt;/label&gt; &lt;label&gt;单选框:&lt;input type="radio" name="gender" value="boy" checked="checked"&gt; &lt;input type="radio" name="gender" value="girl"&gt;&lt;/label&gt; &lt;label&gt;多选框:&lt;input type="checkbox" name="like" value="football"&gt; &lt;input type="checkbox" name="like" value="pingpang"&gt;&lt;/label&gt; &lt;label&gt; 下拉列表: &lt;select name="love" &gt;&lt;!--multiple="multiple" 可多选--&gt; &lt;option value="one"&gt;1&lt;/option&gt; &lt;optgroup label="分组"&gt; &lt;option value="two" selected="selected"&gt;2&lt;/option&gt; &lt;/optgroup&gt; &lt;option value="three"&gt;3&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; &lt;label&gt;文本域:&lt;textarea name="info" style="resize: none"&gt;&lt;/textarea&gt;&lt;/label&gt; &lt;label&gt;提交:&lt;input type="submit" value="YES"&gt;&lt;/label&gt; &lt;label&gt;重置:&lt;input type="reset"&gt;&lt;/label&gt; &lt;input type="button" value="按钮"&gt; &lt;!--button必须指定type 尽量不要使用name属性--&gt; &lt;button type="button"&gt;按钮2&lt;/button&gt; &lt;button type="submit"&gt;提交2&lt;/button&gt; &lt;button type="reset"&gt;重置2&lt;/button&gt; &lt;fieldset&gt; &lt;legend&gt;组名&lt;/legend&gt; &lt;/fieldset&gt;&lt;/form&gt; CSS css 全部在head中引入 常用规则: 选择器 {空格隔开} 属性: 值 (无空格: 有空格) ,并集多个选择器时每个选择器独占一行 ~ + &gt;符号两边使用空格隔开 属性值&quot;&quot;多个属性 , 结尾; 嵌套层级不大于3, 靠后的限定条件应尽可能精确 border/margin/padding尽量不使用缩写,其他属性尽量使用缩写 属性书写顺序: 如果包含 content 属性，放在最前面 Formatting Model 相关属性包括：position / top / right / bottom / left / float / display / overflow 等 Box Model 相关属性包括：border / margin / padding / width / height 等 Typographic 相关属性包括：font / line-height / text-align / word-wrap 等 Visual 相关属性包括：background / color / transition / list-style 等 通过对伪类设置 clear 或触发 BFC 的方式进行clearfixBFC触发 float 非 none position 非 static overflow 非 visible 当数值为 0 - 1 之间的小数时，省略整数部分的 0 例如.5 url()函数中的路径不加引号 RGB颜色值必须使用十六进制记号形式 #rrggbb, rgba()每个逗号后必须保留一个空格 颜色值可以缩写时,必须使用缩写形式, 不允许使用命名色值 font-family使用 字体英文名 字体不小于12px 按「西文字体在前、中文字体在后」「效果佳的字体在前、效果一般的字体在后」的顺序编写，最后必须指定一个通用字体族( serif / sans-serif ) 尽可能在浏览器能高效实现的属性上添加过渡和动画: transform: translate(npx, npx) transform: scale(n) transform: rotate(ndeg) opacity: 0~1 ​ 典型的，可以使用 translate 来代替 left 作为动画属性 选择器1234567891011121314151617181920212223242526272829303132333435363738* 通配选择器# ID选择器 . 类选择器 , 并集选择器(或) "" 交集选择器(与):first-of-type 同一类型的第一个:last-of-type 同一类型的最后一个:nth-of-type(n) 同一类型的第n个 子元素 : &gt; 子元素选择器 " " 后代选择器 :first-child 第一个子元素 :last-child 最后一个子元素 :nth-child(n) 第n个子元素（even偶 odd奇）兄弟元素 : + 紧接着的兄弟元素 ~ 后面的所有兄弟元素伪类 : 特殊状态的元素 :link 正常链接(未访问) :visited 已访问链接(只能设置颜色) :hover 鼠标悬停 :active 点击状态 :focus 获取焦点 ::selection 内容被选中状态否定伪类 : :not(选择器) 从选中的元素中排除伪元素 : 特殊位置的元素 ::first-letter 首字母 ::first-line 首行 ::before 之前 ::after 之后属性选择器 : "[属性名]" 含有指定属性的元素 "[属性名=属性值]" 含有指定属性值的元素 "[属性名^=内容]" 属性值以指定内容开头的元素 "[属性名$=内容]" 属性值以指定内容结尾的元素 "[属性名*=内容]" 属性包含指定内容的元素 权重 !important 10000 内联样式 1000 id选择器 100 类和伪类 10 元素和伪元素 1 通配* 0 继承样式 - 并集选择器分开计算 样式字体 1234567891011121314151617181920212223242526272829font-size: 12px/1;text-decoration: none;letter-spacing: 10px;/* 字符间距 */word-spacing: 5px;/* 单词(空格)间距 */text-align: center;/* 首行缩进 */text-indent: 2em;font-family: 微软雅黑, 宋体;/* 斜体 */font-style: italic;/* 400正常 700加粗 */font-weight: 400;/* 小型大写字母 */font-variant: small-caps/* font: 必须以 字体大小,字体 结尾行间距 = line-height - font-size单行文本 line-height = height 设置垂直居中*/ 显示省略号 1234display: block;white-space: nowrap;text-overflow: ellipsis;overflow: hidden; 表格 12345border-spacing: 5px;/* 合并单元格 */border-collapse: collapse;/*移入鼠标样式*/cursor: pointer; 常用样式 1234567891011121314151617width: 100px;height: 100px;background-color: greenyellow;background-image: url();background-repeat: no-repeat;background-position: 100px center;border: 2px solid red;/*display: none; 不占有空间*//*visibility: hidden; 隐藏但继续占有空间*//*配合绝对定位使用*/z-index: 1;/* opacity 是元素透明度 rgba() 是透明色 */opacity: 0.3;filter: alpha(opacity=30); 定位1234position: 子绝父相absolute 绝对定位 (相对于最近的开启定位的祖先元素位置/脱离文档流/改变元素性质)relative 相对定位 (相对默认位置/不脱离文档流)fixed 固定定位 (相对于浏览器窗口位置/也属于绝对定位) 当子元素浮动时, 子元素脱离文档流无法撑起父元素的高度, 导致父元素高度塌陷 解决方法开启间接BFC, 设置父元素overflow: hidden 外边距塌子元素和父元素相邻的垂直外边距会发生重叠, 子元素的外边距会传递给父元素, 可以使用空的 table 标签来隔断它们 解决父子元素的外边距塌陷方法 border:1px solid transparent padding float:left/right position:absolute display:inline-block overflow:hidden/auto clearfix1234567.clearfix:before,.clearfix:after &#123; content: ""; line-height: 0; display: table; clear: both;&#125; 双飞翼布局1234567&lt;div class="clearfix"&gt; &lt;div id="mid"&gt; &lt;div id="centent"&gt;content&lt;/div&gt; &lt;/div&gt; &lt;div id="left"&gt;&lt;/div&gt; &lt;div id="right"&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627#mid &#123; width: 100%; height: 200px; background-color: greenyellow; float: left; overflow: hidden;&#125;#left &#123; width: 100px; height: 200px; background-color: rosybrown; float: left; margin-left: -100%;&#125;#right &#123; width: 100px; height: 200px; background-color: cornflowerblue; float: left; margin-left: -100px;&#125;#content &#123; margin: 0 100px;&#125; 语义化 什么是语义化 让机器可以读懂内容 (SEO, 屏幕阅读器, 爬虫) ​ 其他程序员能见文知意 (方便维护) 做法 1. 全局只有一个`h1`就是它的logo, 分栏`h2`, 再细分`h3` 2. 尽量少用`div`和`span`, `div`布局`p`显示内容 3. html标签注重语义, css实现样式 4. 表格 标题使用`caption`主体分`thead` `tbody` `tfoot`, 表头用`th`单元格用`td` 5. 表单输入关联`lable`标签 viewportpc端视窗的大小直接根据浏览器窗口的大小来决定 在移动设备中 浏览器和网页之间 有一层虚拟容器 viewport 用来承载网页 该容器默认宽度980px, 可以设置缩放 标准化适配: 网页宽度 = 视窗宽度 = 浏览器宽度(设备屏幕大小) 缩放1 (保持和PC端一致) 不允许用户缩放 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0"&gt; 布局浮动会提升半层 (定位一层) 下层为盒模型, 上层为内容 上面的div浮动, 盒模型层级为1 内容层级为1.5 下面的div不浮动 盒模型为0.5 所以向上填充, 内容层级为1 所以被浮动div的盒模型卡住 所以保持原位不动 三列布局 中间列写在最上面 三列浮动搭建完整的框架 margin 为负值调整旁边两列的位置 (使三列布局到一行上) 使用padding和相对定位调整内容位置(圣杯) 多加一个div来调整内容位置(双飞翼) 伪等高布局123padding-bottom: 2000px 撑开背景margin-bottom: -2000px 收回边界父元素 overflow: hidden 隐藏多余部分 粘连布局(css sticky footer)12345678910&lt;div id="main"&gt;min-height: 100%; &lt;div&gt; padding-bottom: 100px; &lt;/div&gt;&lt;/div&gt;&lt;div class="footer"&gt;height: 100px;margin-top: -100px;&lt;/div&gt; 定位定位参照 相对于最近的 开启了定位的 祖先元素 (子绝父相) 都没有开启定位的父元素 则相对于初始包含块 固定定位参照于视口 包含块浮动元素 包含块为最近的块级祖先元素 定位元素 根元素html的包含块 就是初始包含块, 由用户代理创建, 初始包含块默认和视口的大小及位置相同 初始包含块不等于视口 非根元素position是relative或static包含块则是最近的块级(表单元格或行内块)祖先框的内边界构成 百分比参照 left和top 默认值为 auto(原位置不动) 不是0 margin和padding的百分比 相对于父元素的 width 绝对定位模拟固定定位 html {overflow: hidden}静止系统滚动条 body {overflow: auto}将滚动条添加给body 将body的尺寸设为视口的尺寸 初始包含块固定, body滚动 BFC定义: block formatting context (块级格式化上下文) 它是一个独立的渲染区域, 只管理内部的块级元素布局, 且不会影响BFC外部 BFC布局规则(5种) 内部块级元素独占一行 内部的BFC区域不与浮动盒子重叠 两列布局: 上div 浮动, 下div BFC 内部的Box垂直方向的距离由margin决定, 同一个BFC内.的两个相交的块级盒子的margin会发生重叠 解决方法嵌套一个触发BFC的div或使用padding 计算BFC高度时, 浮动元素也参与计算 清除浮动 BFC是独立容器内外不会相互影响 BFC触发方式(5种) 根元素 float元素 定位元素 overflow元素 display为 inline-block, table-cell, table-caption, flex, inline-flex FLEX布局 注意: 设为 Flex 布局以后, 子元素的float、clear和vertical-align属性将失效 父元素设置为弹性盒子 1display: flex; 设置主轴方向,换行 默认: row水平 nowrap不换行 1flex-flow: column; 设置子元素主轴方向对齐方式 默认 flex-start 沿主轴排列 1234justify-content: centercenter 居中: 向中心靠齐, 多余空间平分到两端space-between 两端对齐: 两端贴边, 多余空间 平局分布在中间space-around 等外边距对齐: 最外侧的边距只有中间的 1/2 设置子元素交叉轴方向对齐方式 默认 stretch 填满交叉轴 设置第一行内每个元素的对齐 所以多行不生效 123align-items: centercenter 居中: 向中心靠齐, 多余空间平分到两端baseline 以第一行文字的基线(底部)对齐 设置内部有多行子元素时的对齐方式 默认 stretch 填满交叉轴 把每一行 当做一个元素来看 所以单行不生效 1234align-content: centercenter 居中: 向中心靠齐, 多余空间平分到两端space-between 两端对齐: 两端贴边, 多余空间 平局分布在中间space-around 等外边距对齐: 最外侧的边距只有中间的 1/2 设置子元素缩放比例 默认为0 1 auto 1230 (空间多余时按设置比例放大. 默认0不放大, n表示占剩余空间的n份) 1 (空间不足时按设置比例缩小. 0的元素不缩小, 都设置为1则等比例缩小) auto (元素的大小) 可以单独配置某个元素的对齐方式 覆盖父元素align-items设置 1align-self: auto 居中 块级元素水平居中 margin: 0 auto; 块级元素垂直居中 vertical-align:middle; position: absolute; top: 50%; transform: translateY(-50%); 内联元素水平居中 text-align: center; 内联元素垂直居中 line-height = height;]]></content>
      <categories>
        <category>Html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax笔记]]></title>
    <url>%2F2018%2F09%2F07%2FAjax%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[AJAXAJAX请求是异步执行的，也就是说，要通过回调函数获得响应。 在现代浏览器上写AJAX主要依靠XMLHttpRequest对象 AJAX请求AJAX 是一套 API 核心提供的类型 : XMLHttpRequest AJAX 操作的页面 “不能” 使用文件的方式访问 新建用户代理 状态0 初始化请求代理对象 1const xhr = new XMLHttpRequest 设置请求行 状态1 建立一个与服务端特定端口的连接 1xhr.open('GET/POST', URL) 设置请求头/体 携带请求参数 12xhr.setRequestHeader('Content-Type', 'application/x-www-from-urlencoded(/json)')xhr.send(null/'key=value') 等待响应 每当 readyState 改变时触发回调函数 1234567891011121314151617181920xhr.onreadystatechange = function () &#123; // 状态2 表示已经收到响应头 if (this.readyState === 2) &#123; console.log(this.getAllResponseHeaders()) &#125; // 状态3 表示正在下载响应体 if (this.readyState === 3) &#123; console.log('响应体responseText可能不完整') &#125; // 状态4 表示响应报文全部下载完成 if (this.readyState === 4) &#123; // this.status === 200 时表示下载成功 if (this.status === 200) &#123; //响应体数据在 this.responseText 里 var data = JSON.parse(this.responseText) &#125; else &#123; console.log('请求失败') &#125; &#125;&#125; GET和POST对于一个返回数据的地址我们称之为接口(API) GET (一般用于获取数据) POST (一般用于提交数据) 可见性 数据在 URL 中对所有人都是可见的 数据不会显示在 URL 中,但可以开发者工具或者抓包可以看到 后退按钮/刷新 无害 数据会被重新提交（浏览器应该告知用户数据会被重新提交） 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 历史 参数保留在浏览器历史中 参数不会保存在浏览器历史中 对数据长度的限制 受浏览器限制 一般无限制 对数据类型的限制 只允许 ASCII 字符 没有限制 也允许二进制数据 编码类型 /x-www-form-urlencoded /x-www-form-urlencoded 或 multipart/form-data 为二进制数据使用多重编码 安全性 GET 的安全性较差，因为所发送的数据是 URL 的一部分 POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中 请求过程 对于GET方式的请求,浏览器会把http header和data一并发送出去,服务器响应200(返回数据) 对于POST,浏览器先发送header,服务器响应100 continue,浏览器再发送data,服务器响应200(返回数据) jQuery.ajax使用jQuery发送ajax请求 1234567891011121314151617181920212223242526272829$.ajax(&#123; type: 'get', url: 'url', data: &#123; key: value &#125;, dataType: 'json', // 设置响应体类型 success: function (res) &#123; console.log('请求成功' + res) &#125;, error: function (err) &#123; console.log('请求失败') &#125;, complate: function () &#123; console.log('请求完成回调') &#125;&#125;)// get请求简便写法$.get('url', &#123;data&#125;, function (res) &#123;&#125;)// post请求简便写法$.post('url', &#123;data&#125;, function (res) &#123;&#125;)// 请求 + JSON转换$.getJSON('url', &#123;data&#125;, function (res) &#123;&#125;) load方法pjax:jQuery.load方法局部刷新页面 1$('#div').load('url #refresh') 它将检索 url 返回的页面内容获取ID为 #refresh 元素的内容并且插入到ID为 #div 元素而其他未被检索到的元素将被废弃 ajax请求时切换loading状态 123456$(document).ajaxStart(function () &#123; $('#loading').show()&#125;)$(document).ajaxStop(function () &#123; $('#loading').hide()&#125;) 跨域请求同源策略指的就是:不同源地址之间,默认不能相互发送AJAX请求 不同源地址之间如果需要相互请求,必须服务器和客户端配合才能完成 JSONP:借助script标签发送跨域请求 动态设置script标签的src属性 12let randomFun = 'jsonp_' + Date.now()script.src = url + '?' + 参数 + '&amp;callback=' + randomFun 定义回调函数: 1234window[randomFun] = function (data) &#123; delete window[randomFun] document.body.removeChild('script')&#125; 服务端配合: 1header("Content-Type: application/javascript") 返回调用随机函数的代码,并将要传递的数据作为实参: 随机函数名(data) jQuery中使用JSONP调用方法和ajax相同, 只需要设置 dataType: “jsonp” CORS( 跨域资源共享):服务器设置 header(&#39;Access-Control-Allow-Origin: *&#39;)]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6笔记]]></title>
    <url>%2F2018%2F09%2F07%2FES6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ES6ECMA和严格模式ECMA 它是一种由ECMA组织（前身为欧洲计算机制造商协会）制定和发布的脚本语言规范 我们学的JavaScript是ECMA的实现, 但术语ECMAScript和JavaScript平时表达同一个意思 JS包含三个部分： ECMAScript（核心） 扩展 ==&gt; 浏览器端 BOM（浏览器对象模型） DOM（文档对象模型） 扩展 ==&gt; 服务器端 ES的几个重要版本 ES5: 09年发布 ES6 (ES2015): 15年发布, 也称为ECMA2015 ES7 (ES2016): 16年发布, 也称为ECMA2016 (变化不大) 严格模式 理解 除了正常运行模式(混杂模式)，ES5添加了第二种运行模式: “严格模式” (strict mode) 顾名思义，这种模式使得Javascript在更严格的语法条件下运行 目的/作用 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 消除代码运行的一些不安全之处，为代码的安全运行保驾护航 为未来新版本的Javascript做好铺垫 使用 在全局或函数的第一条语句定义为: &#39;use strict&#39; 如果浏览器不支持, 只解析为一条简单的语句, 没有任何副作用 语法和行为改变 必须用var声明变量 禁止自定义的函数中的this指向window 创建eval作用域 对象不能有重名的属性 ES5拓展JSON拓展1JSON.stringify(obj/arr) js对象(数组)转换为json对象(数组) 1JSON.parse(json) json对象(数组)转换为js对象(数组) Object拓展ES5给Object扩展了一些静态方法, 常用的2个 Object.create(新创建对象的原型对象, [可选: 新建对象自身属性描述符]) 作用: 以指定对象为原型创建新对象作为返回值返回 可以为新的对象指定自身的属性(一个或多个属性都需要封装成对象传入) 对每个属性的数据属性进行描述(描述也需要封装成对象,包含以下属性) value: 属性的默认值 writable: 属性值是否是可修改 默认为false configurable: 属性是否可重新定义 默认为false enumerable: 属性是否能用for in枚举 默认为false Object.defineProperties(obj, prop, descriptor) 作用: 为指定对象精确添加或修改对象的属性(属性描述符封装成对象传入) 数据描述符: configurable: 该属性是否可重新定义 writable: 该属性值是否是可修改 value: 该属性的默认值 enumerable: 该属性是否能用 for in 枚举 访问描述符: 123get: function ()&#123; return 值&#125; 设置扩展属性的值的回调函数, 在使用扩展属性的时候才调用, 返回动态计算出的该属性的值(惰性求值) 123set: function(newValue)&#123; return 值&#125; 修改扩展属性的值时触发的回调函数, 修改后的值作为实参传入 Array方法拓展12345678910111213141516// 得到值在数组中的第一个下标arr.indexOf(value)// 得到值在数组中的最后一个下标arr.lastIndexOf(value)// 遍历数组arr.forEach(function(item, index)&#123; // 回调函数&#125;)// 遍历数组将加工后的值 作为新数组返回arr.map(function(item, index)&#123; // 回调函数&#125;)// 遍历过滤出一个新的子数组， 返回条件为true的值arr.filter(function(item, index)&#123; // 回调函数&#125;) Function拓展1fun.bind(obj, 参数 ,...) 作用: 将函数内的this绑定为obj, 但并不执行函数,而只将函数返回 面试题: 区别bind()与call()和apply()? 都能指定函数中的this call(obj, 参数,...)/apply(obj, [参数,...])会立即调用函数,传参不一样 bind(obj, 参数 ,...)不执行函数,只将函数返回 Let 和 Constlet 关键字 作用: 与var类似, 用于声明一个变量 特点: 在块作用域内有效 (ES6中添加) 不能重复声明同名变量 不会预处理, 既不存在变量提升 应用: 循环遍历加监听 使用let取代var是趋势 const 关键字 作用: 定义一个常量 (不可改变引用) 特点: 不能修改 对象可以修改它的属性,但是不能重新赋值引用 其它特点同let 应用: 保存不用改变的数据 解构赋值和模板字符串解构赋值 理解: 相当于声明了多个(一个)变量, 变量的值在赋值的对象或数组里取对应的值 对象的解构赋值(属性名必须对应) let {a, b} = {a:&#39;xxx&#39;, b:&quot;yyy&quot;} 数组的解构赋值(根据下标对应取值) let [a, b] = [1, &#39;zzz&#39;] 用途 给多个形参赋值 模板字符串 作用简化字符串的拼接 模板字符串必须用 包裹 变量部分使用 ${xxx} 包裹 对象简写简化写法总结: 属性名和属性值相同可以省略 对象的方法和function同名可以省略方法名 12345678910let x = 1;let y = 2;let obj = &#123; x, yfun()&#123; //语句 &#125;&#125; 箭头函数 作用: 方便定义匿名函数, 调整**this**指向 基本语法: (形参) =&gt; {函数内容} 没有形参时, 需要用括号占位 一个参数时, 括号可以省略 函数体只有一条语句时, 可以不用大括号, 默认return语句执行后的结果 函数体如果有多条语句: 需要用{}包裹, 若有需要返回的内容需要设置return 常用场景: 回调函数 this 箭头函数没有自己的this 它的this不是调用时决定的 它的this指向箭头函数定义时所属的作用域 理解: * 箭头函数的`this`看它的外层是否有其他函数 * 如果有, 箭头函数的`this`和外层函数相同 * 如果没有, 则指向 `window` … 运算符和形参默认值…运算符用途 可变参数 比arguments更灵活, 但只能搜集末尾所有未接收的实参,以数组保存 12345678function fun(n, ...values) &#123; console.log(arguments); // arguments是伪数组,所以无法用forEach遍历 console.log(values); values.forEach(function (item, index) &#123; console.log(item, index); // n 接收了第一个实参,所以只能打印出2,3 &#125;)&#125;fun(1,2,3); 拓展运算符123456// 将arr1插入arr2中let arr1 = [1,3,5];let arr2 = [2,...arr1,6];// 将数组arr1中的元素依次push到arr2中arr2.push(...arr1); 形参默认值当不传入参数的时候使用形参里的默认值 123function fun(x = 1,y = 2) &#123; // 函数传实参则使用实参, 不传则使用默认值&#125; Promisepromise 主要用于处理异步请求 语法 123456789101112131415161718192021222324252627let promise = new Promise(function(resolve, reject) &#123; // pending: 初始状态 // 定义时立即执行 异步操作&#123; if (boolean) &#123; //fulfilled: 操作成功完成 resolve(data) &#125; else &#123; //rejected: 操作失败 reject("失败") &#125; &#125;&#125;)// 定义异步完成后的回调函数// 异步完成后根据结果执行对应的回调函数promise.then(function(resolve) &#123; //成功时执行的函数&#125;, function(reject) &#123; //失败时,执行的函数&#125;)// 也可以用catch捕获失败promise.then(resolve =&gt; &#123; // 只传入成功回调&#125;).catch(reject =&gt; &#123; // 用catch捕获失败&#125;) 注意点 Promise构造函数执行时立即调用传入的函数 resolve 和 reject 两个回调函数作为参数 调用resolve()时修改状态为成功 fulfilled 调用reject()时修改状态为失败 rejected then()最多可传入两个回调函数, 对应异步成功和失败 then()的返回值仍然是个promise对象 Symbol概念: ES6中添加的一种原始数据类型 symbol 已有的6种原始数据类型：String, Number, Boolean, null, undefined, Object 特点: Symbol表示一个唯一的值，解决命名冲突问题 Symbol的值不能与其他数据进行计算，包括同字符串拼串 for in, for of遍历时不会遍历symbol属性 使用: 调用Symbol函数得到symbol值 注意: 不能使用new symbol作为属性名时必须使用属性选择器 [] 1234// 该方法创建的symbol不放入全局Symbol注册表中let symbol = Symbol()let obj = &#123;&#125;obj[symbol] = 'hello' 标识symbol: 1234let symbol = Symbol('one');let symbol2 = Symbol('two');console.log(symbol); // Symbol('one')console.log(symbol2); // Symbol('two') Iterator 概念: iterator是一种接口机制, 为各种不同的数据结构提供统一的访问机制 作用: 为各种数据结构, 提供一个统一的、简便的访问接口 使得数据结构的成员能够按某种次序排列 ES6创造了一种新的遍历命令for...of循环，iterator接口主要供for...of使用 工作原理: 创建一个指针对象(遍历器对象), 指向数据结构的起始位置 第一次调用next()方法, 指针自动指向数据结构的第一个成员 接下来不断调用next()方法, 指针会一直往后移动, 直到指向最后一个成员 每次调用next()方法返回的是一个包含value和done的对象 {value: 当前成员的值, done: 布尔值} value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束 当遍历结束的时候返回的value值是undefined，done值为false 原生具备iterator接口的数据: Array arguments String set map 当使用 for of 去遍历某一个数据结构时 首先在目标上找Symbol.iterator 找到则可以用for of遍历 否则报错 ...运算符 和 解构赋值 默认也是调用iterator接口 123456789101112131415161718function iteratorFun(obj) &#123; let i = 0 return &#123; next() &#123; return &#123; value: obj.data[i++], done: i &gt; obj.data.length &#125; &#125; &#125;&#125; let obj = &#123; data: ["无", "聊", "大", "作", "战"] , [Symbol.iterator]() &#123; return iteratorFun(this) &#125;&#125; Generator 概念 生成器函数在执行时能暂停, 后面又能从暂停处继续执行 调用一个生成器函数并不会马上执行它里面的语句, 而是返回一个这个生成器的迭代器/遍历器(iterator)对象 当这个遍历器的next()方法被调用时, 其内的语句会执行到出现yield的位置为止 包括紧跟yield的语句 yield后紧跟遍历器要返回的值 next()方法返回一个对象, 这个对象包含两个属性: value和done value属性表示本次yield表达式的返回值 done属性为布尔类型, 表示生成器后续是否还有yield语句, 即生成器函数是否已经执行完毕并返回 调用next()方法时，如果传入了参数, 那么这个参数会作为上一条执行的yield的值 用途 ES6提供的解决异步编程的方案之一 Generator函数是一个状态机，内部封装了不同状态的数据 用来生成遍历器对象 特点 function与函数名之间有一个星号 内部用yield表达式来定义不同的状态 可暂停函数(惰性求值) 注意 generator函数返回的是指针对象(iterator)，而不会执行函数内部逻辑 调用next()方法函数内部逻辑开始执行，遇到yield表达式停止，返回{value: yield后的表达式结果/undefined, done: false/true} 再次调用next()方法会从上一次停止时的yield处开始, 到下一个yield为止 yield语句返回结果通常为undefined, 当调用next()方法时传参内容会作为启动时yield的返回值 class`class`声明创建一个基于原型继承的具有给定名称的新类. 类声明**不允许**再次声明已经存在的类，否则将会抛出一个类型错误。 123456789101112131415161718192021222324// class 定义类class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; showName() &#123; console.log(this.name) &#125;&#125;let per = new Person("test", 18)// extends 继承类class extendsPer extends Person &#123; constructor(name, age, salary) &#123; // 调用父类的构造方法 (需要传入参数) super(name, age) this.salary = salary &#125; showName() &#123; console.log(this.name + this.salary) &#125;&#125;let extPer = new extendsPer("extTest", 16, 666) 通过class定义类/实现类的继承 在类中通过constructor定义构造方法 通过new来创建类的实例 通过extends来实现类的继承 通过super调用父类的构造方法 可在子类中重写父类中继承的一般方法 类声明不可以提升 方法必须使用简写 字符串/数值拓展字符串 includes(str): 判断是否包含指定的字符串 startsWith(str): 判断是否以指定字符串开头 endsWith(str): 判断是否以指定字符串结尾 repeat(count): 重复指定次数 String.prototype.padStart(maxLength, fillString = &quot;&quot;)或padEnd: 在字符串的开头或结尾处用fillString将它填充到指定长度 数值 二进制与八进制数值表示法: 二进制用0b, 八进制用`0o Number.isFinite(i): 判断是否是有限大的数 Number.isNaN(i): 判断是否是NaN Number.isInteger(i): 判断是否是整数 Number.parseInt(str): 将字符串转换为对应的数值 Math.trunc(i): 直接去除小数部分 数组/对象拓展数组 Array.from(v): 将伪数组对象或可遍历对象转换为真数组 Array.of(v1, v2, v3): 将一系列值转换成数组 find(function(value, index, arr){return true}): 返回第一个满足条件返回true的元素 findIndex(function(value, index, arr){return true}): 返回第一个满足条件返回true的元素下标 对象 Object.is(v1, v2): 判断2个数据是否完全相等 Object.assign(target, source1, source2..): 将源对象的属性复制到目标对象上 直接操作__proto__属性 之前只能通过 构造函数的prototype来操作实例的___proto___ 深度克隆 浅拷贝数据: 拷贝引用, 操作会影响原数据 直接赋值给另一个变量 Object.assign() Array.prototype.concat() Array.prototype.slice() 深拷贝(深度克隆): 生成新数据, 操作不会影响原数据 JSON.parse(JSON.stringify()) 可以拷贝数组和对象, 不能拷贝函数 深度克隆方法: 递归遍历原对象或数组, 遇到对象或数组继续遍历里面的内容, 直到拿到的是基本数据类型才复制 123456789101112131415161718192021222324function typeCheck(test) &#123; //使用 Object 原型上的 toString 方法检测数据类型, 返回数据类型的字符串 return Object.prototype.toString.call(test).slice(8, -1)&#125;function copy(obj) &#123; let res if (typeCheck(obj) === "Object") &#123; res = &#123;&#125; &#125; else if (typeCheck(obj) === "Array") &#123; res = [] &#125; else &#123; return obj &#125; for (let i in obj) &#123; if (typeCheck(obj[i]) === "Object" || typeCheck(obj[i]) === "Array") &#123; let obj2 = copy(obj[i]) res[i] = obj2 &#125; else &#123; res[i] = obj[i] &#125; &#125; return res&#125; Set和Map容器set**无序**不可重复, 可存储任何数据类型, 无论是原始值或者是对象 语法: let mySet = new Set(xxx) add(value): Set对象尾部添加一个元素, 返回该Set对象 delete(value): 移除Set的中与这个值相等的元素 has(value): 返回一个布尔值, 表示该值在Set中存在与否 clear(): 清空Set对象 size: Set中储存的数据的数量 可以用for...of进行遍历 mySet / mySet.keys() / mySet.values() 数组去重 1234// 用Set构造器将Array转换为Setvar mySet = new Set(myArray)// 用...操作符将Set还原为Arrayconsole.log([...mySet]) map**有序**不可重复, 用于保存键值对, **任何值**(对象或者原始值) 都可以作为一个键或一个值 for...of 循环为每次迭代返回一个[key，value]数组 和Object的区别: Map 的键可以是任意值, 包括函数、对象 Map 中的键值是有序的 size 属性直接获取一个 Map 的键值对个数 Map 是可迭代的 语法: let myMap = new Map([{key1, value1}, {key2, value2}...]) set(key, value): 像Map中添加数据, 返回该Map对象 get(key): 返回键对应的值，如果不存在，则返回undefined delete(key): 移除任何与键相关联的值，并且返回该值 has(key): 返回一个布尔值，表示Map实例是否包含键对应的值 clear(): 移除Map对象的所有键 / 值对 size: 返回Map 的键值对个数 for…of 遍历数组 遍历Set 遍历Map 遍历字符串 遍历伪数组 for...of / for...in / forEach 的区别: for...in index索引为字符串型数字, 不能直接进行几何运算 遍历顺序有可能不是按照实际的内部顺序 使用for...in会遍历数组所有的可枚举属性, 包括原型上的 适合遍历对象 index ==&gt; key for...of 遍历的只是数组内的元素, 而不包括数组的原型 不能遍历普通对象, 因为没有 iterator 接口 适合遍历数组 index ==&gt; value forEach(callback(Value, index, arr)) 对数组的每个元素执行一次提供的回调函数 只能遍历数组 无法break或者return中断 async函数async 函数 当调用一个async函数时, 会返回一个Promise对象 当这个async函数返回一个值时, Promise的resolve()方法会负责传递这个值 当async函数抛出异常时, Promise的reject()方法也会传递这个异常值 async函数中可能会有await表达式, 可以使async函数暂停执行 等表达式中的Promise解析完成后继续执行async函数并返回解决结果 await 表达式 会暂停当前async函数的执行, 等待Promise处理完成 若Promise正常处理(fulfilled), 其回调的resolve函数参数作为await表达式的值，继续执行async函数 若Promise处理异常(rejected), await表达式会把Promise的异常原因抛出 如果await操作符后的表达式的值不是一个Promise, 那么该值将被转换为一个已正常处理的Promise 注意: await关键字仅仅在async function中有效 概念: 真正意义上去解决异步回调的问题，同步流程表达异步操作 本质: Generator的语法糖 12345async function fun() &#123; // await后面执行异步操作, 前面保存异步结果 const result = await ajax() console.log(result)&#125; 特点: 不需要像Generator去调用next()方法, 遇到await等待, 当前的异步操作完成就往下执行 返回的总是Promise对象, 可以用then()方法进行下一步操作 async取代 Generator 函数的星号*, await取代 Generator 的yield 语意上更为明确, 使用简单, 暂时没有任何副作用 模块化export暴露数据 1234567891011121314151617export function test() &#123; console.log("暴露test函数")&#125;export let arr = [1, 2, 3]// 可以将要暴露的多函数放到一个对象里function fun1() &#123; console.log("fun1")&#125;function fun2() &#123; console.log("fun2")&#125;export &#123;fun1, fun2&#125;// 默认暴露 --- 可以暴露任意数据类型, 暴露什么类型的数据接收到的就是什么数据// 一个文件只能使用一次 export default 引入直接用一个变量接收即可export default xxx import引入数据 12import &#123;fun1, fun2&#125; from &quot;./路径/文件名&quot;import xxx from &quot;./xxx.js&quot;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>js</tag>
      </tags>
  </entry>
</search>
