<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript笔记]]></title>
    <url>%2F2018%2F09%2F12%2FJavaScript%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JavaScriptJS 规范 空格 逗号 前不加空格 , 后加空格 关键词 1234if () &#123; // 关键字后面加空格 // &#123; 之前加空格&#125; 对象 123ojb = &#123; a: "前不加空格 : 后加空格"&#125; 函数 1234function() &#123; //函数的 () 前不加空格 arguments[] = "函数的[]也不加空格"&#125; 运算符处换行时, 运算符必须在新行的行首 变量: 使用驼峰命名法 常量全部使用字母大写, 单词间下划线分隔 构造函数(类)单词首字母大写 命名: 类名 使用名词 函数名 使用动宾短语 布尔值 使用 is 或 has 开头 Promise对象 使用动宾短语的进行时表达 类型检测: 优先使用typeof 对象类型检测使用instanceof null或undefined的检测使用 == null 字符串: JS内使用&#39;&#39; 字符串内使用&quot;&quot; 新建: 使用字面量 对象 = {} 数组 = [] 事件: 优先使用addEventListener绑定事件, 第三个参数使用false(冒泡时触发) HelloWorld JS中严格区分大小写 JS中每条语句以;结尾 也可以不加; 注意当语句以()或[]开头时则需要在前面加上; JS中会忽略多个空格和换行 我们以空格和缩进对代码进行格式化 123alert("弹出警告窗口")document.write("页面中写入内容")console.log("在控制台输出") 123&lt;!--不建议这样写!他们属于结构与行为耦合,不方便维护--&gt;&lt;button onclick="alert('JS代码可以编写到按钮的onclick事件中')"&gt;test&lt;/button&gt;&lt;a href="javascript:alert('JS代码编写到超链接href属性中')"&gt;test&lt;/a&gt; 字面量和变量 常量: 都是一些不可改变的值 常量都可以直接使用 变量: 变量的值是可以任意改变的 声明变量: 在es5中使用var关键字来声明一个变量 var a 为变量赋值 a = 123 声明+赋值 var a = 456 标识符: 在JS中所有可以由我们自主命名的都可以称为标识符 命名规则: 可以包含字母 数字 _ $ 不能以数字开头 不能是ES中的关键字和保留字 驼峰命名法 JS底层保存标识符实际上是用的unicode编码, 理论上所有utf-8中的所有内容都可以当作标识符 数据类型 在es5中只有6种数据类型 基本数据类型 String 字符串 Number 数值 Boolean 布尔值 Null 空值 Undefined 未定义 引用数据类型 Object 对象 只要不是基本数据类型的都是对象 特殊对象: Function 封装可执行代码, 并可以调用执行 Array 使用索引有序的保存数据 判断方法 typeof 注意返回数据类型的字符串表达,所以对比时要加&#39;&#39; &gt; 该方法不能用来判断`null` `object` `function` instanceof 判断a是否是b的实例,判断对象的具体类型,返回布尔值 === 三等会先判断数据类型, 双等则不会判断数据类型直接比较值 类型详情 String 字符串 在JS中字符串需要用引号引起来 引号或双引号都行, 但是不能混用 在字符串中用\作为转义符\n换行 Number 数值 JS中所有数值都是Number类型 包括整数和浮点数(小数) Number.MAX_VALUE表示JS中的最大数值 Number.MIN_VALUE表示JS中最小的小数 超过最大值Infinity表示正无穷 NaN 特殊数字 Not A Number 使用JS进行浮点数计算 会得到一个不精确的结果 12var a = 0.1 + 0.2;0.30000000000000004 Boolean 布尔值: true 真 false 假 Null 空值 表示: 定义了,并且值为空&#39;&#39; null空的对象 所以typeof null返回&#39;Object&#39; 初始值为null表示该变量是个对象 对象不再使用时, 赋值null可使浏览器对其进行垃圾回收 Undefined 未定义: 未定义类型,其实就是没赋值的意思 当声明一个变量但未赋值时, 变量的值就是 undefined 变量的类型 基本类型: 保存的是在栈内存中的基本类型数据 引用类型: 是在栈内存中保存对象在堆能存中的储存地址 JS在调用函数时传递变量参数时是引用传递(基本数值/引用地址) 注意函数的形参是新建一个局部变量, 并复制实参的数值或者引用地址(浅拷贝) 强制类型转换 转换String 调用被转换数据类型的toString()方法 a.toString() 该方法不会影响原变量, 它会将转换结果返回 null和undefined没有toString方法, 调用会报错 调用String()函数 调用函数String(a)将被转换的数据作为参数传递给函数 该方法也不会影响变量, 也是将结果返回 对于Number和Boolean实际上还是调用的toString()方法 对于null和undefined则不会调用toString()方法, 直接转换 简便方法: + &#39;&#39; 转换Number 调用Number()函数 字符串 ==&gt; 数字 纯数字直接转 有非数字转为NaN 空字符串或空格转换为0 布尔值 ==&gt; 数字 true == 1 false == 0 null == 0 undefined NaN parse方法: parseInt() 把字符串转换为一个整数 取出字符串中的连续数字,从左往右 遇到非数字立即结束 parseFloat() 把字符串转为浮点数 对非String使用为NaN 简便方法: + 转换Boolean 使用Boolean()函数 数字 ==&gt; 布尔: 除了0和NaN是false其余为true 字符串 ==&gt;布尔: 除了空串是false其余为true null和undefined都是false 任何对象都为true包括空对象/空数组 简便方法: !! 算数运算符运算符也叫操作符, 通过运算符可以对一个值或多个值进行运算, 并获取结果 比如typeof就是运算符, 用来获取一个值的类型 算术运算符 +加法: 对非Number运算会先转换城Number再进行运算 任何值和字符串相加都会转换成字符串再进行拼串 数字 + NaN = NaN / 数字 + null = 0 -:减法 *:乘法 /:除法 %:取模 String会转换为Number再进行计算 一元运算符 +正号 -负号(取反) 自增 / 自减 ++: 原变量会立刻在原来得基础上自增1 自增分两种i++ / ++i 无论哪种都会立即使 原变量 +1 不同的是表达式 i++显示原值 ++i显示+值 自减分两种i-- / --i 无论哪种都会立即使 原变量 -1 不同的是表达式i--显示原值 --i显示-值 逻辑运算符 !非: 布尔值取反 &amp;&amp;与: 两边都满足 如果第一个值为false则不会检查第二个值 ||或: 两边只需要满足一边 如果第一个值为true则不会检查第二个值 var a = a||0 设置默认值 非布尔值运算: &amp;&amp;: 优先返回false` ||: 优先返回true 赋值运算 =赋值: 将等号右边的原始值或引用地址赋值给左边的变量 ==相等运算: 对于非数值情况 会先转换成数字 然后再比较 任何值和NaN比较都是false 如果符号两边都是字符串则不会转换数字, 直接比较unicode编码 !=: 不全等运算, 会转换成同一数据类型再比较 ===全等: 先比较类型, 如果类型不同直接返回false 注意: 比较时需要注意数据是字符串数字还是数值 !==: 全不等, 如果数据类型相同直接返回 false +=加等: a += b 等同于 a = a + b 条件运算符条件运算符也叫三元运算符 条件表达式 ? 语句1 : 语句2 执行流程: 条件运算符在执行时, 首先对条件表达式求值 如果为true执行语句1返回结果 如果为false执行语句2返回结果 ,运算符 可以分割多个语句, 一般可以在声明多个变量时使用 流程控制语句 流程控制语句分类 条件判断语句 .条件分支语句 循环语句 条件判断语句 使用条件判断语句可以在执行某个语句前进行判断 如果条件成立才会执行语句, 条件不成立则不执行 123456789if (条件表达式) &#123; 语句...&#125; else if (条件表达式) &#123; 语句...&#125; else if (条件表达式) &#123; 语句...&#125; else &#123; 语句...&#125; 该语句从上到下依次对条件表达式求值判断 如果为true则执行当前语句 如果为false则继续向下判断 该语句中只有一个代码块会被执行 一旦代码块执行了则直接结束语句, 不会向下判断 条件分支语句 也叫 switch 语句 1234567891011switch (条件表达式) &#123; case 表达式: 语句... break; case 表达式: 语句... break; default: 语句... break;&#125; 在执行时会依次将switch的条件表达式的值和case的表达式值进行全等比较 如果结果为true则执行该case后面的语句 如果结果为false则继续向下比较 如果所有结果都为false则执行default后的语句 循环语句 while循环 通过循环语句可以反复的执行一段代码多次 123while (条件表达式) &#123; 语句...&#125; while语句在执行时先对条件表达式求值判断 如果结果为true则执行语句 执行完毕后再次回到判断 当结果为false则终止循环 可以用break来终止循环 1.初始化一个变量var i=0 2.在循环中设置一个条件表达式i&lt;10 3.定义一个表达式更新i++ do…while循环 123do &#123; 语句...&#125; while (条件表达式); 区别: while先判断后执行do...while先执行后判断, 至少执行一次 for循环 123for (初始化表达式; 条件表达式; 更新表达式) &#123; 语句...&#125; 初始化表达式 执行条件表达式判断 每次执行会重新计算然后判断里面的值 所以为了追求性能 应将计算放到初始化表达式中去) 如果为 true 执行语句 如果为 false 终止循环 更新表达式 回到第二部 再次判断 执行 break和continue break关键字可以用来退出整个switch或循环 if语句不能使用break和continue break关键字会立即终止离他最近的那个循环语句 可以为循环语句创建一个label来标识当前的循环 语法: label名 : 循环语句 `break` `label名`; continue关键字可以用来跳过当次循环, 只对最近循环起作用 continue要写在代码语句之前才能起作用 耗时测试 console.time(&#39;txt&#39;) + console.timeEnd(&#39;txt&#39;) 对象 对象是一种复合的数据类型, 在对象中可以保存多个不同数据类型的属性 对象的分类 内建对象: 由ES标准中定义的对象,在任何的ES的实现中都可以使用 例如: Array Function Object … 宿主对象: 由JS的运行坏境提供的对象, 目前来讲主要指由浏览器提供的对象 例如: BOM浏览器对象模型 DOM文档对象模型 自定义对象: 由开发人员自己创建的对象 创建对象 var obj = new Object() 使用 new 关键字调用的函数是构造函数 构造函数是专门用来创建实例对象的函数 属性: 在对象中保存的值称为属性 向对象中添加属性 对象.属性名 = 属性值 读取对象中的属性 对象.属性名 删除对象的属性 delete 对象.属性名 属性名 读取变量属性名或者特殊属性名 对象[属性名] = 属性值 属性值 JS对象的属性值 可以是任意数据类型 in运算符可以检查一个对象中是否含有指定属性(包括原型上的属性) 只检查自身使用hasOwnProperty “属性名” in 对象 有则返回true没有则返回false 引用数据类型 基本数据类型保存在栈内存中,变量的值直接保存相互独立 引用数据类型保存在堆内存中, 对象的值是保存的对象的**内存地址 如果两个保存的是同一个对象引用, 通过一个变量修改属性时另一个也会受到影响 引用数据类型比较值的时候它是比较的对象的内存地址 对象字面量 1234var obj = &#123; 属性名: 属性值, 属性名: 属性值...&#125; 函数函数也是一个对象, 用于提高相同代码(功能)可复用性 函数中可以封装一些功能 在需要时调用 可以执行这些功能 fun表示函数对象本身, fun()表示函数执行后的返回值 如果函数没有return返回值默认undefiend 创建函数 var fun = new Function() 可以将要封装的代码以字符串的形式传递给构造函数 封装的代码不会立即执行 函数中的代码会在函数被调用时执行 调用语法: 函数名() 当函数被调用时, 函数中封装的代码会按顺序依次执行 函数声明: 一般使用这种方式来创建函数 123function 函数名(形参1, 形参2, ...) &#123; 语句...&#125; 函数表达式 123var 函数名 = function(形参1, 形参2, ...) &#123; 语句...&#125; 形参(形式参数) 多个形参用 , 分割 声明形参就相当于在函数内部声明了对应的变量, 但并不赋值 实参(实际参数) 在调用函数时在()中指定实参, 相当于把实参的值赋值给形参 调用函数时解析器不会检查实参的数据类型和数量 有可能会接收到非法参数, 需要对参数的数据类型进行检查 如果实参的数量少于形参,则没有对应实参的形参的值是 undefined 实参可以是任意数据类型,也可以是对象或者函数 当我们的参数过多时,可以将参数封装到一个对象中,然后通过对象传递 函数返回值 使用return来设置函数的返回值 return后的值,将作为函数执行后的结果 return返回值后结束整个函数, 之后的语句都不会执行 如果不写return或者return后没有值则返回undefined 调用函数函数名()相当于使用函数的返回值, 函数名相当于使用函数对象 立即执行函数 (IIFE) 123(function() &#123; alert("这是一个匿名函数自调用");&#125;)() 整个函数加上括号表示一个整体代码才能正确识别 最后加一个()表示立即调用该函数 作用: 隐藏实现, 不会污染全局命名空间, 函数执行完后会立即销毁函数及里面的内容 JS 模块化的基础 回调函数 由开发者定义,但没有调用 (在满足某些条件后)最终执行了的函数 就是回调函数 DOM事件回调函数 定时器回调函数 AJAX 请求回调函数 生命周期回调函数 递归调用 在函数内部自己调用自己就是递归调用 递归调用首先要设置递归条件和retrun条件 否则这个函数将成为一个死循环 方法 方法 对象的属性可以是任何数据类型, 也可以是函数 如果一个函数作为一个对象的属性保存, 那么我们称这个函数是这个对象的方法 调用函数就说调用对象的方法 但是他们只是叫法上的区别, 本质没变 枚举对象中的属性 123for(var key in obj)&#123; obj[key]&#125; for ... in语句对象中有几个属性, 循环就会执行几次 包括原型上的属性和方法 每次会把对象的属性名赋值给变量 提取对象信息: 因为属性名是赋值给了变量所以提取属性信息必须用 obj[key] 作用域作用域用来隔离变量, 不同作用域下的同名变量不会冲突 作用域的范围是在编写代码时确定, 并非在函数执行时确定 调用函数是直接在函数原来的作用域里执行, 并非将函数复制到调用的作用域里执行 全局作用域 直接编写在script标签中的JS代码都在全局作用域中 全局作用域在页面打开时创建,页面关闭时销毁 在全局作用域中有一个全局对象window我们可以直接使用 它代表我们浏览器的窗口,由浏览器创建 我们创建的变量都会作为window对象的属性保存 我们创建的函数都会作为window对象的方法保存 全局作用域中的变量都是全局变量, 在页面任意部分都可以访问到 函数作用域 调用函数时函数作用域创建, 函数执行完毕后函数作用域销毁 闭包时不会销毁 每调用一次函数就会创建一个新的函数作用域 他们是相互独立的 在函数作用域中可以访问到全局作用域的变量 在全局作用域中无法访问到函数作用域的变量 当在函数作用域中操作一个变量时会先在自身作用域中寻找,如果没有则向上一级作用域中寻找 如果全局作用域中依然没有找到 则会报错ReferenceError 在函数中想要访问全局中的同名变量可以借用window对象 函数作用域中, 函数也会声明提前 在函数中不使用var声明的变量 都是全局变量 定义形参就相当于在函数中声明了一个变量 声明提前 浏览器加载 浏览器在加载一个页面时,时按照自上向下的顺序加载的 读取到一行就运行一行, 需要注意代码顺序和JS代码的位置 全局里的所有var和function ()都会提升到顶部执行 如果声明时没有使用var关键字, 则不会被提前 变量提前 &gt; 函数提前 函数表达式var只会提前声明变量, 函数不会提前所以不能在声明前调用函数 全局执行上下文 在执行全局代码前将window确定为全局执行上下文对象 对全局数据进行预处理 var定义的全局变量值设置为undefined并将其添加为window的属性 function声明的全局函数赋值, 并将其添加为window的方法 this指向window 开始执行全局代码 函数执行上下文 每当调用函数时, 准备执行函数体前, 创建对应的函数执行上下文对象 将实参值赋值给形参, 并将其添加为执行上下文对象的属性 arguments赋值实参列表, 并将其添加为执行上下文对象的属性 var定义的局部变量值设置为undefined并将其添加为执行上下文对象的属性 function声明的函数, 并将其添加为执行上下文对象的方法 this指向调用函数的对象 执行上下文栈 栈:像一个”柱”状 容器, 先放进去的执行上下文对象在下面后进去的在上面 只能操作在最上面的上下文对象, 在上面的执行上下文对象先执行先销毁 全局执行上下文对象window永远在最下面 闭包 闭包Closure 当一个嵌套的内部函数引用了嵌套的外部函数的变量或函数时就会产生闭包 闭包产生在外部函数调用时且内部函数已定义, 跟内部函数是否调用无关 在没有变量引用闭包的函数时闭包销毁 闭包的作用 使外部函数的变量在函数执行完后,仍保存在内存中 延长局部变量的生命周期 在函数外面可以操作到函数内部的数据 (变量/函数) JS模块 JS 模块就是具有特定功能的JS文件 将所有的数据和功能都封装在一个函数内部(私有的) 只向外暴露return一个包含n个方法的对象或函数 模块的使用者就可以通过模块暴露的对象来调用方法实现对应功能 将数据或功能写在IIFE中, 为暴露对象添加属性或方法, 并将向外暴露的对象设置为window的属性 闭包的缺点 函数执行完毕后, 函数内部的局部变量没有释放, 占用内存 容易造成内存泄漏 解决: 及时释放 (将不再使用的函数引用赋值null) 内存溢出: 当程序运行需要的内存超过剩余内存时就会抛出内存溢出的错误 内存泄露: 占用的内存没有及时释放,积少成多后容易导致内存溢出 常见的内存泄漏: 意外的全局变量 没有及时清理的计时器或回调函数 闭包 this解析器在每次调用函数时都会传递一个隐含的参数this this会指向调用函数的对象 根据函数调用方式的不同this会指向不同的对象 以函数的形式调用this(或未指定调用对象)则指向window 以方法的形式调用this则指向调用的对象 DOM 事件回调函数中的this一般指向 DOM 元素 其他回调函数中的this一般指向window 当以构造函数调用时, this则是构造函数中新建的对象 以call(调用对象,函数形参1,形参2,...)和apply(调用对象,形参数组)方法调用时this是指定的那个对象 构造函数构造函数是专门用来创建某种类型的对象的函数 构造函数就是一个普通的函数, 创建方式和普通函数没有区别 构造函数首字母大写 构造函数和普通函数的区别是调用方式的不同 普通函数是直接调用 构造函数需要使用new关键字来调用 构造函数的执行流程 new立刻在堆内存创建一个新对象 将新建的对象设置为函数中的this 用 this 来选择新建的对象 逐行执行函数中的代码 将新建对象返回 类 使用同一个构造函数创建的对象我们称为一类对象, 也将这个构造函数称为一个类 我们将通过一个构造函数创建的对象称为是该类的实例 使用instanceof可以检查一个对象是否是某一个类的实例 所有的对象都是Object的实例, 用instanceof检查返回true Object.prototype 除外 原型我们所创建的每一个函数, 解析器都会向函数中添加一个属性prototype显式原型 这个属性对应着一个Object对象, 这个对象就是原型对象 原型对象中有个constructor属性指向该对象的构造函数 如果作为普通函数调用prototype没有任何作用 当函数以构造函数的形式调用时, 它所创建的实例对象中都会有一个隐含的属性 该属性指向该构造函数的原型对象, 我们可以通过__proto__隐式原型来访问该属性 原型链 当我们访问对象的一个属性或方法时, 他会现在对象自身中寻找 如果有则直接使用, 如果没有则会去原型对象中寻找 原型对象也是对象,所以它也有原型 所以如果原型中没有找到, 则去原型的原型中寻找 (也就是Object对象的原型) Object.prototype.__proto__的值是null它是原型链的尽头 使用in检查对象中是否含有某个属性时, 如果对象中没有, 原型中有也会返回true 使用对象.hasOwnProperty(&quot;属性名&quot;)来检查对象自身中是否含有该属性 所有函数(主要是构造函数)都有显示原型 所有对象(包括函数, 数组)都有隐式原型 函数实例的隐式原型 等于 构造函数的显示原型 继承 原型继承 构造函数的实例对象自动拥有构造函数原型对象的属性和方法 (利用原型链继承) 当修改对象属性的常规值的时候就是修改属性名对应的值本身 对象重新赋值相当于修改变量名/属性名保存的引用地址 原型链继承 (为了继承父类型的方法) 定义父类型构造函数 给父类型的原型添加方法 定义子类型构造函数 关键: 创建父类型的实例对象赋值给子类型的原型对象 将子类型原型的构造constructor属性修正为子类型函数 给子类型添加方法 创建子类型的实例 (可以调用父类型的方法) 借用构造函数继承 (假借, 为了构建相同属性) 定义父类型构造函数 定义子类型构造函数 在子类型构造函数中通过Fun.call(this, a, b)调用父类型构造函数 组合继承 利用原型链实现对父类型对象的方法继承 利用call()方法假借父类型构建函数初始化相同属性 数组数组也是一个对象 (内建对象) 他和我们普通对象功能类似, 也是用来储存一些值的 不同的是普通对象是使用字符串作为属性名, 且无序 而数组是使用数字作为索引来操作元素, 有序 索引: 0 开始的整数 数组的储存性能要比普通对象好, 在开发中我们经常使用数组来储存一些数据 添加/修改元素: 数组名[索引] = 值 获取数组长度: 使用数组的length方法 语法: 数组.length 会获取到数组最大索引 +1 设置数组长度: 语法: 数组.length = 值 如果大于原长度, 多出的值会空出来 如果小于原长度, 多出的值会被删除 向数组最后一个位置添加元素: 数组名[数组名.length] = 值 字面量创建数组: var 数组名 = [值, 值, 值...] 使用构造函数创建数组: var 数组名 = new Array(值, 值, 值...) 使用这种方法如果只传一个整数值则表示创建一个长度为n的空数组 数组方法 push() 该法方法可以向数组的末尾添加一个或多个元素, 并返回新数组的长度 将要添加的元素作为参数传递, 这样这些元素会自动添加到数组末尾 该方法会将数组的新长度作为返回值返回 pop() 该方法可以立即删除数组中的最后一个元素 该方法的返回值是删除的那个元素 unshift() 向数组的开头添加一个或多个元素, 并返回新的长度 向最前面插入元素, 其他元素的索引会依次调整 shift() 删除数组第一个元素, 并将删除的元素作为返回值返回 slice() 可以用来从数组中提取出指定元素 该方法不会影响原数组, 会将截取到的数组返回 语法: 数组名.slice(参数1, 参数2) 参数: 截取开始位置索引(包含) 截取结束位置索引(不包含,省略则是到末尾) 参数可以传递负值,如果传递一个负数则从后往前计算 (-1 倒数第一个元素) splice() 可以用来替换/删除/添加数组中的指定元素 使用splice()会影响原数组 它会将指定元素从原数组中删除, 并将被删除的元素作为返回值返回 语法: 数组名.splice(参数1, 参数2, 参数3...) 参数: 表示开始位置的索引(包含) 表示删除元素的数量 可以传递一些新元素,这些元素会插入到开始位置索引的 前面 concat() 可以拼接多个数组, 并将新的数组返回 该方法不会对原数组产生影响 语法: var arr = arr1.concat(arr2,arr3...) join() 该方法可以将数组转换成一个字符串 该方法不会对原数组产生影响, 而是将转换后的字符串作为结果返回 在join()中可以指定一个字符串作为参数, 这个字符串将会称为数组中元素的连接符(默认 ,) 语法: var str = arr.join(&quot;连接符&quot;) reverse() 该方法用来反转数组,该方法会直接修改原数组 sort() 可以用来对数组元素按unicode编码进行排序, 它也直接修改原数组 我们可以自己指定排序规则在sort()添加一个回调函数, 来指定排序规则 回调函数中需要定义两个形参 浏览器会分别使用数组中的元素作为实参去调用回调函数 使用那个元素调用不确定, 但可以肯定 数组中的a一定在b之前 浏览器会根据回调函数的返回值决定元素的顺序 返回值大于0元素交换位置, 小于0则不换位, 等于0认为两个元素相等依然不变 1234arr.sort(function(a, b)&#123; return a - b; //升序 return b - a; //降序&#125;) filter() filter使用数组中的每个元素去调用callback函数 如果callback返回true则将该元素添加到新数组里面 1var newArray = arr.filter(callback(element, index, arr)) forEach() IE 8及以下不支持 方法遍历数组需要一个函数作为参数 数组中有几个元素则调用函数几次 每次执行浏览器会将遍历到的元素以实参形式传递进函数 123数组名.forEach(function(元素值, 索引, 数组本身) &#123; 操作语句...&#125;) 函数的方法 call()和apply() 这两个方法都是函数对象的方法, 需要通过函数对象来调用 当对函数调用call()和apply()方法时都会执行函数 在调用call()和apply()时可以将一个对象指定为第一个参数 此时这个对象将会成为函数执行时的`this call()方法实参在对象之后依次传递 apply()方法需要将实参封装到一个数组里 arguments 在调用函数时,浏览器每次都会传递进两个隐含的参数: 函数的上下文对象this 封装实参的对象arguments arguments是一个伪数组对象, 它也可以通过索引来操作数据, 也可以获取长度 在函数调用时我们所传递的实参都会在arguments中保存 arguments.length可以用来获取传入实参的数量 我们即使不定义形参, 我们也可以通过arguments[i]来使用实参 它里面有一个属性叫callee这个属性对应一个函数对象, 就是当前这个函数本身 时间对象 创建一个Date对象 直接使用构造函数创建一个Date对象,则会封装当前执行代码的时间 语法: var d = new Date() 创建一个指定的时间对象 需要在构造函数中传递一个表示时间的字符串作为参数 日期格式&quot; 月份 / 日 / 年 时 : 分 : 秒 &quot; 相关方法 getDate() 获取当前日期对象是几号 getDay() 获取当前日期对象是周几 (0 表示周日) getMonth() 获取当前日期对象的月份 (返回值 0 - 11) getFullYear() 获取当前日期对象的年份 getTime() 获取当前日期对象的时间戳 时间戳是指格林威治标准时间到当前时间经过的毫秒数 计算机底层在保存时间使用的都是时间戳 获取当前代码执行时的时间戳 var time = Date.now() Math对象Math和其他对象不同, 它不是一个构造函数 它属于一个工具类不用创建对象, 它里面封装了数学运算相关的属性和方法 Math.PI 圆周率 (全大写表示常量) Math.abs() 求绝对值 Math.ceil() 向上取整 Math.floor() 向下取整 Math.round() 四舍五入 Math.random() 生成一个0-1之间的随机数 Math.floor(Math.random()*10) 0-9 之间的整数 Math.max() 返回值是传入参数中的最大值 Math.min() 返回值是传入参数中的最小值 Math.pow(x,y) 返回 x 的 y 次幂 Math.sqrt() 返回值是参数的开方 包装类在JS中为我们提供了三个包装类,通过这三个包装类可以将基本数据类型转换为对象 String() 可以将一个基本数据类型的字符串转换为 String 对象 Number() 可以将一个基本数据类型的数字转换为 Number 对象 Boolean() 可以将一个基本数据类型的布尔值转换为 Boolean 对象 但是在实际应用中 我们不会使用基本数据类型的对象 如果使用会带来一些不可预期的结果 方法和属性只能添加给对象, 不能添加给基本数据类型 当我们对一些基本数据类型的值去调用属性或方法时 浏览器会临时使用包装类将其转换为对象, 然后去它的原型上寻找对应的方法 字符串的方法 系统底层字符串是以字符数组形式保存的 length属性 获取字符串长度 (属性不用加括号) charCodeAt() 获取指定位置字符的Unicode编码 concat() 连接一个或多个字符串 indexOf(&quot;查找内容&quot;, 查找起始位置索引) 检索一个字符串里是否有指定内容 如果字符串中含有该内容则返回该内容第一次出现的位置的索引 如果没有则返回 -1 lastIndexOf() 同上, 反向查找 slice(包括起始位置,不包括结束位置) 可以从字符串中截取指定内容, 负数表示倒数 substr(包括起始位置,截取数量) 截取字符串,该方法ES中没有定义,但是所有浏览器都支持 split(分割字符串) 根据分割字符串把一个字符串拆分成一个数组 如果传递一个空串 则将字符串中的每一个字符都拆分成一个元素 toUpperCase() 转换大写 toLowerCase() 转换小写 正则表达式正则表达式用于定义一些字符串的规则 计算机可以根据正则表达式 来检查一个字符串是否符合规则 或者将字符串中符合规则的内容提取出来 创建正则表达式的对象 var 变量名 = new RegExp(&quot;正则表达式&quot;,匹配模式) test()用于检查一个字符串是否符合正则表达式规则 符合返回true 不符合返回false 匹配模式 i忽略大小写 g全局匹配模式 字面量创建正则表达式 var 变量名 = /正则表达式/匹配模式 注意 // 里不能有空格 正则表达式语法 | [] 或 [a-z] 小写字母 [A-Z] 大写字母 [A-z] 任意字母 [^ ] 除了括号以内的任意内容 [0-9] 任意数字 ^ 表示x开头 $ 表示x结尾 ^$ 开始立即结束 . 表示任意字符 \ 转义符 使用 \ 则需要写 \ \w 任意 字母 数字 _ 相当于[A-z_0-9] \W 除了字母 数字 _ 相当于[^A-z_0-9] \d 任意数字 相当于[0-9] \D 除了数字 相当于[^0-9] \s 空格 \S 除了空格 \b 单词边界 (前后各加一个\b表示中间的内容是独立的单词) \B 除了单词边界 量词 (注意不要加空格) {n} 之前的第一个内容出现n次 {m,n} 之前的内容出现 m 至 n 次 (n不写表示无限制) + 至少一个 相当于{1,} * 零个或多个 相当于{0,} ? 零个或一个 相当于{0,1} 相关方法 split() 可以将字符串拆分成一个数组 (默认全局匹配) search() 所搜字符串中是否含有指定内容 不能全局匹配,只能查找第一个 如果所搜到指定内容返回第一次出现的位置, 没有索搜到则返回 -1 match() 根据正则表达式从一个字符串中将符合条件的内容提取出来 默认情况下match()只会找到第一个符合要求的内容就会停止检索 我们可以设置正则表达式为全局匹配模式这样就会匹配到所有的内容 match()会将匹配到的内容封装到一个数组中返回, 即使只匹配到一个结果 replace(被替换内容,新的内容) 将字符串中指定内容替换为新的内容 默认只会替换第一个内容, 被替换内容可以使用正则表达式来匹配 DOMD Document 网页 O Object 标签转换为对象 M Model 标签之间的关系模型 常用节点 nodeName nodeType nodeValue 文档节点: 整个 HTML 文档 #document 9 null 元素节点: HTML 文档中的标签 标签名 1 null 属性节点: 标签的属性 属性名 2 属性值 文本节点: 标签的内容 #text 3 文本内容 浏览器为我们提供 文档节点对象 这个对象是window 可以在页面中直接使用, 文档节点代表整个网页document 事件 就是用户和浏览器之间的交互行为 比如:点击按钮,移动鼠标,关闭窗口… 事件响应函数最后 return false 可以取消元素默认行为 confirm(&quot;提示字符串&quot;)可以弹出一个提示框, 根据用户操作返回一个布尔值 注意: 事件的代码是在触发后执行(异步执行), 而其他代码是在加载时执行, 所以要特别注意事件里的变量 为window绑定一个onload事件, 函数中的代码会在页面加载完成后执行 这样可以确保我们代码执行时 DOM 对象已经加载完毕 123window.onload = function () &#123; 语句...&#125; 通过document调用, 获取元素节点 getElementById() 通过ID获取一个元素节点对象 getElementsByTagName() 通过标签名获取一组元素节点对象 getElementsByName() 通过NAME属性获取一组节点对象 读取元素节点属性 语法: 元素.属性名 class属性需要用className 通过具体节点调用, 获取元素节点的子节点 getElementsByTagName() 返回当前节点的指定标签名后代节点 childNodes 表示当前节点的所有子节点(包括空白文本节点) children 表示当前节点的所有子元素 firstChild 表示当前节点的第一个子节点(包括空白文本节点) firstElementChild 表示当前节点的第一个子元素(不支持IE8及以下) lastChild 表示当前节点的最后一个子节点(包括空白文本节点) lastElementChild 表示当前节点的第一个子元素(不支持IE8及以下) 通过具体节点调用, 获取父节点和兄弟节点 parentNode 表示当前节点的父节点 (父元素唯一) previousSibling 表示当前节点的前一个兄弟节点(包括空白文本节点) previousElementSibling 表示当前节点的前一个兄弟元素(不支持IE8及以下) nextSibling 表示当前节点的后一个兄弟节点(包括空白文本节点) nextElementSibling 表示当前节点的后一个兄弟元素(不支持IE8及以下) 其他查询方法 document.body 表示Body标签 document.all 页面中的所有标签document.getElementsByTagName(&quot;*&quot;) document.getElementsByClassName() 根据 class 获取元素 (不支持IE8及以下) document.querySelector(&quot;CSS选择器&quot;) 根据 CSS 选择器来获取元素(它只会返回第一个结果) document.querySelectorAll(&quot;CSS选择器&quot;) 同上, 支持IE8及以上, 返回多个结果保存在数组里 DOM 操作 document.createElement(&#39;标签名&#39;) 根据标签名创建一个相应的元素节点对象 document.createTextNode(&#39;文本内容&#39;) 根据文本内容创建一个文本节点 父节点对象.appendChild(子节点对象) 向父节点中添加一个子节点 父节点对象.insertBefore(新节点对象, 指定节点对象) 在指定的子节点前添加新的节点 父节点对象.replaceChild(新节点对象, 指定节点对象) 用新节点替换掉指定节点 父节点对象.removeChild(子节点对象) 删除一个子节点 节点对象.innerHTML = &#39;内容&#39; 给节点对象的 HTML 内容赋值 ( += 替换 少用) 内联样式操作修改值 通过DOM对象style属性设置或读取内联样式 语法: DOM对象.style.样式名 = &quot;值&quot; 数值注意要 + px 如果CSS样式名中含有 - 号需要将样式名修改为驼峰命名法 获取元素当前显示的样式 语法: 元素名.currentStyle.样式名 可以用来读取当前元素正在显示的样式的值(只支持IE,其他浏览器不支持) 语法: getComputedStyle(要获取样式的元素对象 , null) 该方法可以将元素对象的所有样式封装到一个对象里返回(支持IE9及以上) 通过以上两种方法获取到的样式都是只读属性修改需要用style属性来修改 其他样式属性操作(返回值不带 px 只读属性, 无法修改) clientWidth\clientHeight 返回元素的可见宽度\高度 返回值(内容区+ padding) offsetWidth\offsetHeight 返回元素的整个宽度\高度 返回值(内容区 + padding + 边框) offsetParent 可以获取当前元素定位的父元素(标签postion属性 定位的父元素) offsetLeft\offsetTop 当前元素对于定位父元素的偏移量 scrollWidth\scrollHeight 获取元素整个滚动区域的宽度\高度 scrollLeft\scrollTop 滚动条 水平\垂直 滚动距离 scrollHeight - scrollTop == clientHeight 表示垂直滚动条滚动到底 自定义 getStyle() 方法 1234567function getStyle(obj , stylename)&#123; if(window.getComputedStyle)&#123; return getComputedStyle(obj , null)[stylename]; &#125;else&#123; return obj.currentStyle.stylename; &#125;&#125; 注意 返回值当中有 px 用parseInt()来取值, 注意 IE 中没有默认参数则返回auto需要设置默认参数 BOMB Browser 浏览器 O Object 对象 M Model 模型 BOM 可以使我们通过JS来操作浏览器, 它为我们提供了一组对象, 用来完成对浏览器的操作 BOM 对象 Window 代表的是整个浏览器的窗口,同时 window 也是网页中的全局对象 Navigator 代表的当前浏览器的信息,该对象可以用来识别不同的浏览器 Location 代表当前浏览器的地址栏信息,通过它可以获取地址栏信息或者跳转页面 History 代表浏览器的历史记录,可以通过该对象来操作浏览器的历史纪录 由于隐私原因 ,该对象不能浏览到具体的历史纪录,只能操作浏览器 向前或者向后 而且该操作只对档次访问有效 Screen 代表用户的屏幕的信息,通过该对象可以获取到用户的显示器相关的信息 BOM 对象在浏览器中都是作为window对象的属性保存的, 可以通过window对象调用, 也可以直接使用 navigator 由于历史原因navigator对象中的大部分属性都不能帮助我们识别浏览器了 一般我们只会使用navigator.userAgent来判断浏览器的信息 123456789if(/firefox/i.test(navigator.userAgent))&#123; firefox&#125;else if(/chrome/i.test(navigator.userAgent))&#123; chrome&#125;else if(/msie/i.test(navigator.userAgent))&#123; ie(Edge除外)&#125;else if("ActiveXObject" in window)&#123; Edge&#125; location 直接将 location属性的值修改为 绝对路径或相对路径 可以使页面跳转到该地址 并生成相应的历史记录 location.reload() 相当于刷新如果在方法中传递一个true作为参数, 则会强制清空缓存 location.replace() 该方法传入一个地址, 跳转页面但是不会生成历史纪录 location.reload() 相当于刷新 如果在方法中传递一个 true 作为参数,则会强制清空缓存 location.replace() 该方法传入一个地址,跳转页面 但是不会生成历史纪录 history length 可以获取到当前访问链接的数量 back() 可以用来退回到上一个页面 作用和浏览器上的回退按钮一样 forward() 可以跳转到下一个页面 作用和浏览器的前进按钮一样 go(整数) 可以用来跳转到指定数目的页面,正数表示向前跳转 负数向后跳转 screen 主要用于移动端 window对象的方法 setInterval(回调函数, 调用间隔 单位ms) 定时调用, 可以设置一个函数每隔一段时间执行一次 这个方法有个返回值, 该数字 是定时器的唯一 标识 clearInterval(定时器标识) 可以接收任意参数, 用来关闭指定的定时器 同一元素开启定时器时, 需要先关闭当前元素的其他定时器 定时器和键盘操作配合起来可以实现连贯流畅的动态效果 setTimeout(回调函数, 调用延时 单位ms) 定时调用会执行多次, 延时调用只调用1次 clearTimeout(timer) 用来关闭延时调用 事件对象 事件对象 当事件的响应函数被触发时,浏览器每次都会将一个事件对象作为实参传递进响应函数event 在事件对象中封装了当前事件相关的一切信息(比如: 鼠标坐标 键盘操作 等等..) IE 8及以下 将事件对象 保存在window.event属性中, 用event = event || window.event来兼容 事件对象的属性 事件对象.clientX \ Y 可以获取鼠标指针在当前可见窗口的横纵坐标 事件对象.pageX \ Y 可以获取鼠标指针在整个页面中的横纵坐标(不支持IE8及以下) 事件冒泡(Bubble) 所谓的事件冒泡指的就是事件的向上传导 当后代元素上的事件被触发时, 其祖先元素上的相同事件也会被触发 取消冒泡 可以通过事件对象来取消冒泡 语法: event.cancelBubble = true 事件委派 当我们希望只绑定一次事件即可应用到多个元素上, 即使元素是后添加的 我们可以尝试将其绑定给元素的共有的祖先元素 将事件统一绑定给元素的共同的祖先元素 这样当后代元素上的事件触发时会一直冒泡到祖先元素 从而通过祖先元素的响应函数来处理事件这就是事件委派 事件委派是利用了冒泡, 通过委派可以减少事件绑定次数, 提高程序性能 检测事件的触发对象 event.target 返回值是触发对象(可配合 if 语句使用) 事件绑定 DOM0: 对象.on事件 = 响应函数` 他只能为一个元素的一个事件绑定一个响应函数 不能绑定多个事件, 绑定多个相当于赋值后面的语句会覆盖掉前面的语句 DOM2: 我们可以通过addEventListener()为元素添加事件监听器来绑定多个响应函数 该语法支持 IE 9 及以上和其他浏览器, this指向调用的元素 元素对象.addEventListener(&quot;事件名称,不要on&quot;, 回调函数, 是否在捕获阶段触发一般false) IE 8及以下使用 元素对象.attachEvent(&quot;事件名称&quot;, 回调函数) 该语法的执行顺序是: 后绑定的先执行, 该语法中的this指向window 自定义事件兼容函数 123456789101112function bind (obj, evenStr, callBack)&#123; if(obj.addEventListener)&#123; //现代浏览器 obj.addEventListener(evenStr, callBack, false); &#125;else&#123; //IE8及以下, this指向window是因为回调函数是浏览器直接以函数形式调用 obj.attachEvent("on"+evenStr, function () &#123; //我们将匿名函数包裹回调函数再传递给浏览器, 由自己控制函数调用 callBack.call(obj); //当函数以call方法调用时 this指向指定对象; &#125;); &#125; &#125; 事件传播 微软公司认为事件应该是由内向外传播, 先触发当前元素上的事件(事件在冒泡阶段执行) 网景公司认为事件应该是由外向内传播, 先触发祖先元素上的事件(事件在捕获阶段执行) W3C标准: ​ 1.捕获阶段 ​ 在捕获阶段时,从最外层的祖先元素向目标元素进行事件捕获,默认此时不会触发事件 ​ 2.目标阶段 ​ 事件捕获到目标元素,捕获结束,开始执行目标元素上的事件 ​ 3.冒泡阶段 ​ 事件从目标元素开始向他的祖先元素上传递,依次触发祖先元素上的相同事件 浏览器默认行为 当我们拖拽网页中的内容时,浏览器默认回去搜索相关内容 此时会导致拖拽功能异常, 这个时浏览器的默认行为可以在事件函数中return false来取消 IE 8 及以下无效 鼠标事件 onclick 鼠标单击时触发 onmousemove 该事件将会在鼠标再元素中移动时触发 mouseover 不论鼠标指针穿过被选元素或其子元素都会触发 mouseenter 只有在鼠标指针穿过被选元素时才会触发 mouseout 不论鼠标指针离开被选元素还是任何子元素都会触发 mouseleave 只有在鼠标指针离开被选元素时才会触发 强制捕获鼠标按下操作 (IE8 取消拖拽搜索) 捕获鼠标操作的对象.setCapture() 当调用setCapture()方法以后元素会将下一次所有的鼠标按下操作捕获到自身上来 捕获鼠标操作的对象.releaseCapture() 取消对象对鼠标按下操作的强制捕获 以上2种方法 chrome 里会报错, 兼容方法: 对象.setCapture &amp;&amp; 对象.setCapture() &amp;&amp; 如果两边都为 true 则返回后面一个值 鼠标滚轮事件 onmousewheel 会在滚轮滚动时触发 但火狐浏览器不支持该属性 在火狐中需要使用DOMMouseScroll来绑定滚动事件 注意该事件需要通过自定义事件绑定兼容函数 来绑定 event.wheelDelta返回值是正值向上, 负值向下(多数浏览器) event.detail返回值是负值向上, 正值向下(火狐浏览器) 12345if( event.wheelDelta &gt; 0 || event.detail &lt; 0 )&#123; 向上滚动&#125;else&#123; 向下滚动&#125; 当我们滚动滚轮时, 如果浏览器有滚动条, 滚动条会随之滚动 如果不需要可以用return false来取消 火狐使用addEventListener()方法来绑定的函数取消默认行为时不能使用return false 需要使用event.preventDefault()来取消默认行为 但是 IE8 不支持, 调用时需要检测是否具有该方法 键盘事件 onkeydown 按键被按下 对于它来说如果按住不放 事件会连续触发 当onkeydown连续触发时 前两次间隔会长一点,之后间隔非常短) onkeyup 按键被松开 键盘事件一般都会绑定给可以获取到焦点的对象或者是document onkeypress 事件在所有浏览器中不能触发所有按键(例如：ALT, CTRL, SHIFT, ESC) oninput 该事件在&lt;input&gt;或&lt;textarea&gt;元素的值发生改变时触发 我们可以通过event.keyCode来获取按键的unicode编码 除了keyCode事件对象中还提供了几个其他属性 altKey ctrlKey shiftKey 这三个用来判断 相对的按键是否按下 按下返回 true 否则返回 false 在文本编辑框的键盘事件的响应函数中return false可以取消默认行为 按下的字母或数字不会打印到文本框上 CSS类我们希望一行代码可以同时修改多个样式时, 可以通过修改元素的class属性来间接修改样式 我们只需要修改一次,即可同时修改多个样式, 浏览器只需要重新渲染一次性能更好并且结构和行为进一步分离 自定义class函数 检查元素中是否含有某个className 1234function hasClass(obj, classname) &#123; var reg = new RegExp("\\b"+classname+"\\b"); return reg.test(obj.className);&#125; 向一个元素中添加指定的className 12345function addClass(obj, classname) &#123; if(!hasClass(obj, classname)) &#123; obj.className += " "+classname; &#125;&#125; 删除元素中指定的className 1234function removeClass(obj,classname)&#123; var reg = new RegExp("\\b"+classname+"\\b"); obj.className = obj.className.replace(reg,"");&#125; 切换一个类(有则删除,没有则添加) 1234567function toggleClass(obj,classname)&#123; if(hasClass(obj.classname))&#123; removeClass(obj,classname); &#125;else&#123; addClass(obj,classname); &#125;&#125; JSONJS中的对象只有自己认识, 其他语言都不认识 JSON就是一个特殊格式的字符串, 这个字符串可以被任何语言所识别 并可以转换为任意语言中的对象,JSON 在开发中主要用来交互数据 JavaScript Object Notation JS对象表示法 JSON和JS对象的格式一样, 只不过 JSON字符串中的”属性名”必须加双引号 JSON 中允许的值 字符串 数值 布尔值 null 普通对象 数组 不能储存函数 JSON 分类: 对象{} 数组[] 将 JSON 字符串转换为 JS 对象 在JS中为我们提供了一个工具类, 就叫 JSON 这个对象可以帮助我们将一个JSON对象转换为JS对象, 也可以将 JS 对象转换为 JSON JSON ==&gt; JS JSON.parse() JS ==&gt; JSON JSON.stringify() eval() 这个函数可以用来执行一段字符串形式的JS代码, 并将结果返回 如果eval()执行的字符串中含有{}他会将{}当成一个代码块 如果不希望将其当成代码块解析, 需要在字符串前后加一个() eval()这个函数的功能很强大, 可以直接执行一个字符串中的JS代码 但是在开发中尽量不要使用, 因为它的执行性能差, 具有安全隐患 如果需要兼容 IE 7 及以下的 JSON 操作, 可以通过引入一个外部的JS文件来处理 Event Loop 浏览器内核 Chrome Safari: webkit FireFox: Gecko IE: Trident 内核组成 主线程 js引擎模块: 负责js程序的编译和运行 html/css文档解析模块: 负责页面文本的解析 dom/css模块: 负责dom&amp;css在内存中的相关处理 布局和渲染模块: 负责页面的布局和效果的绘制 分线程 定时器模块 : 负责定时器的管理 事件响应模块 : 负责事件的管理 网络请求模块 : 负责ajax请求 JS代码分类 初始化执行代码 (同步代码) 回调执行代码 (异步代码) JS引擎执行代码的基本流程 先执行初始化代码:包括一些特别的代码 设定定时器 绑定监听 发送ajax请求 后面在某一个时刻才会执行会调代码 回调函数里面的代码是异步执行的 JS是单线程执行的, 初始代码依次执行完毕后再依次执行回调代码 事件循环 (event loop) 12345678 JS(浏览器主线程模块执行) heap stack →→→ WebAPIs(浏览器分线程模块执行)堆内存数据 栈内存数据 →→→ DOM(事件响应) 对象... 初始化代码执行 ajax(网络请求) setTimeout(定时器) 循环执行 ↓↓↓event loop: callback queue ( 任务队列/消息队列/事件队列 ) 待执行回调队列依次执行 Web Workers HTML5提供的一个JS多线程解决方案 我们可以将一些大计算量的代码交由Web Worker运行而不冻结用户界面 但是子线程完全受主线程控制且不得操作DOM 所以这个新标准并没有改变 JS 单线程的本质 面向对象所谓的面向对象, 就是在编程的时候尽可能的去模拟真实的现实世界按照现实世界中的逻辑去处理一个问题, 分析问题中参与其中的有哪些实体, 这些实体应该有什么属性和方法，我们如何通过调用这些实体的属性和方法去解决问题 实体就是动作的支配者 没有实体, 就肯定没有动作发生 分析那些动作是由哪些实体发出的 定义这些实体，为其增加相应的属性和功能 让实体去执行相应的功能或动作]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery笔记]]></title>
    <url>%2F2018%2F09%2F10%2FjQuery%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[jQuery基础了解jQuery 封装简化DOM操作 它有强大选择器 : 方便查找 DOM 元素 它能隐式便利 : 一次操作所有查找到的元素 它能链式调用 : jQ方法都会返回jQ对象 它可以读写合一 : 不传值则读取 传值则写入 事件处理 , DOM操作 , CSS操作 , 动画效果 , 浏览器兼容 引入jQuery 开发测试的时候使用未压缩的版本方便调试 (服务器本地引入) 正式上线的时候使用压缩版本加载速度快 (CDN远程引入) jQuery两把利器 jQuery(核心)函数 $()使用()调用时是当作函数使用 参数为函数 : 当DOM加载完成后,执行此回调函数 参数为选择器字符串 : 查找所有匹配的标签,并将他们封装为jQuery对象 参数为DOM对象 : 将DOM对象封装成为 jQuery对象 参数为HTML标签字符串 : 创建标签对象并封装成jQuery对象 $.xxx() 使用 . 来使用方法时当作对象来使用 123$.each(arr, function(index, item) &#123;&#125;)$.trim(str) jQuery(核心)对象 执行jQuery核心函数返回的对象(函数名前加 $) jQuery对象内部包含的是 DOM 元素对象的伪数组(即使只有一个元素) jQuery对象拥有很多有用的属性和方法,让程序员能方便的操作 DOM 语法: $obj.xxx()或者$(&quot;选择器&quot;).xxx() 基本用法 .length 获取jQuery对象里面包含的 DOM 元素的个数 [index] 返回index下标对应的 DOM 元素 .each() 遍历jQuery对象里面的 DOM 元素 .index() 得到 DOM 元素在其兄弟元素中的下标 选择器jQuery选择器jQ选择器基于css选择器, 并对其进行了扩展 作用: 根据选择器规则在整个文档中查找所有匹配的标签, 并封装成jQuery对象返回 选择器分类 基本选择器: 和css选择器规则相同 #id / element / .class / * / s1,s2(并集) / s1s2(交集) 层次选择器: 查找子元素 / 后代元素 / 兄弟元素 s1 s2 匹配s1后代所有的s2元素 parent&gt;child 匹配parent的子元素child prev+next 匹配prev后紧接的兄弟元素next prev~siblings 匹配prev之后的所有兄弟元素siblings 过滤选择器: 在原有选择器匹配的元素中进行进一步的筛选 多个过滤选择器是依次执行的, 需要注意index值的变化 基本 :first 选择第一个元素 :last 选择最后一个元素 :not(selector) 不匹配selector的元素 :even 索引值为偶数的元素 :odd 索引值为奇数的元素 :eq(index) 指定索引值的元素 :gt(index) 大于指定索引值的元素 :lt(index) 小于指定索引值的元素 :animated 正在执行动画效果的元素 :focus 当前获取焦点的元素 内容 :contains(text) 匹配包含给定文本的元素 :has(selector) 配含有选择器所匹配的元素的元素 可见 :hidden 匹配所有不可见元素 :visible 匹配所有的可见元素 属性 : [attribute=value] 匹配给定的属性是某个特定值的元素 [attribute!=value] 匹配所有不含有指定的属性 子元素 :nth-child(n) 匹配其父元素下的第N个子或奇偶元素 表单 :checkbox 匹配所有复选框 :button 匹配所有按钮 工具方法将 $ 当作对象来使用 $.each(function(&quot;属性名/索引&quot;,&quot;属性值&quot;){}): 遍历数组或对象中的数据 $.trim(str): 去除字符串两边的空格 $.type(obj): 得到数据的类型 $.isArray(obj): 判断是否是数组 $.isFunction(obj): 判断是否是函数 $.parseJSON(json): 解析json字符串转换为js对象/数组 属性操作 读取/设置任意属性 attr(&quot;属性名&quot;,&quot;属性值&quot;) 单个属性直接传入”属性名”,”属性值” 多个属性封装为对象传入 “属性名”:”属性值” removeAttr(&quot;属性名&quot;) prop(&quot;属性名&quot;,true/false) 操作属性值为布尔值的属性 操作class类名 addClass(&quot;类名&quot;) 为元素添加CSS类名，多个请用空格分开 removeClass(&quot;类名&quot;) 删除元素的CSS类名，多个请用空格分开 操作HTML html() 获取元素的内容,传参则设定HTML的内容 val() 获得匹配元素的当前值,传参则设定值 CSS .css() 传入”属性名” 则读取该属性 传入”属性名”,”值” 设置该属性 设置多个属性 封装为一个对象传入 位置属性 offset() 获取匹配元素相对页面左上角的偏移,只对可见元素有效 返回的对象包含两个整型属性：top 和 left 写入参数传入对象 {top:123,left:456} position() 获取匹配元素相对父元素的偏移 scrollTop([val]) 获取匹配元素相对滚动条顶部的偏移 scrollLeft([val]) 获取匹配元素相对滚动条左侧的偏移 尺寸 height() 内容高度 width() 内容宽度 innerHeight() height + padding innerWidth() width + padding outerHeight(true) height + padding + border + margin outerWidth(false) width + padding + border 对象筛选过滤在已匹配的元素对象中筛选出一个或多个组成新的jQuery对象返回 eq(index|-index) 获取第N个jQuery对象，参数为负数时为反向选取 first() last() 获取第一个或最后一个元素 filter(selector) 筛选出当前元素中与选择器匹配的元素集合 not(selector) 删除与选择器匹配的元素 has(selector) 包含特定后代的元素，去掉那些不含有指定后代的元素 查找通过已匹配的对象找到一个或多个新的元素对象封装为新的jQuery对象 children(selector) 子标签中匹配 find(selector) 后代标签中匹配 parent(selector) 父标签中匹配 prevAll(selector) 前面所有的兄弟标签中匹配 nextAll(selector) 后面所有的兄弟标签中匹配 siblings(selector) 前后所有的兄弟标签中匹配 文档处理 添加 append(content) / appendTo() 向当前匹配的所有元素内部的最后插入指定内容 prepend(content) / prependTo() 向当前匹配的所有元素内部的最前面插入指定内容 before(content) 将指定内容插入到当前所有匹配元素的前面 after(content) 将指定内容插入到当前所有匹配元素的后面 替换 replaceWith(content) 用指定内容替换所有匹配的标签删除节点 删除 empty() 删除所有匹配元素的子元素 remove() 删除所有匹配的元素 事件处理 事件绑定 eventName(function(){}) 绑定对应事件名的监听, 例如：$(‘#div’).click(function(){}) on(eventName, funcion(){}) 通用的绑定事件监听, 例如：$(‘#div’).on(‘click’,”a”, function(){}) 常用事件 click / mouseenter / mouseleave / focus / blur / hover 区别 eventName: 编码时绑定元素必须存在,不能给后添加的元素绑定该事件 on: 可以利用事件委派,将事件绑定在父元素上,事件可以冒泡到目标元素上 事件解绑 off(eventName) 事件的坐标 event.clientX,event.clientY 相对于浏览器窗口的左上角 event.pageX,event.pageY 相对于当前页面的左上角 event.offsetX, event.offsetY 相对于事件元素左上角 事件处理 event.stopPropagation() 停止事件冒泡 event.preventDefault() 阻止事件默认行为 事件委托 事件委托(委派/代理) 将多个子元素的事件监听委托给父辈元素处理 事件监听绑定在父辈元素上 当操作子元素时, 事件会冒泡到父辈元素 父辈元素不会直接处理事件, 而是根据event.target得到发生事件的子元素, 通过这个子元素调用事件回调函数 事件委托的两方 委托方: 子元素 被委托方: 父元素 使用事件委托的好处 添加新的子元素, 自动有事件响应处理 减少事件监听的数量: n==&gt;1 jQuery的事件委托API 设置事件委托: $(parentSelector).delegate(childrenSelector, eventName, callback) 移除事件委托: $(parentSelector).undelegate(eventName) 动画效果 淡入淡出: 不断改变元素的透明度opacity来实现的 fadeIn(&quot;speed&quot;): 带动画的显示 fadeOut(&quot;normal&quot;): 带动画隐藏 fadeToggle(): 带动画切换显示/隐藏 滑动动画: 不断改变元素的高度width来实现的 slideDown(&quot;speed&quot;): 带动画的展开 slideUp(&quot;slow&quot;): 带动画的收缩 slideToggle(): 带动画的切换展开/收缩 显示隐藏，默认没有动画 通过同时改变宽 高 透明度来实现 show(&quot;speed&quot;): 不带动画的显示 hide(&quot;fast&quot;): 不带动画的隐藏 toggle(): 不带动画的切换显示/隐藏 jQuery动画本质 : 在指定时间内不断改变元素样式值来实现的 animate(params,[speed]): 自定义动画效果的动画 params: 包含一个或多个需要操作属性和最终值的对象 移动指定距离 可以用{left : &#39;+=100&#39;} , {top : &#39;-=50&#39;} stop(): 停止动画 多库共存和插件多库共存 问题: 如果有2个库都有$, 就存在冲突 解决: jQuery库可以释放$的使用权, 让另一个库可以正常使用, 此时jQuery库只能使用jQuery了 API: jQuery.noConflict() window.onload与$(document).ready()的区别: window.onload 包括页面的图片加载完后才会回调(晚) 只能有一个监听回调 $(document).ready() 等同于: $(function(){}) 页面加载完就回调(早) 可以有多个监听回调 插件 扩展jQuery的工具方法 $.extend(object) 扩展jQuery对象的方法 $.fn.extend(object) 将需要扩展的一个或多个方法封装成对象传入 方法名: function(){} ​]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>jq</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML笔记]]></title>
    <url>%2F2018%2F09%2F09%2FHTML%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[HTMLHTML标签head123456789&lt;!DOCTYPE html&gt;&lt;head lang="zh-CN"&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;标题必须在charset之后&lt;/title&gt; &lt;meta name="keywords" content="HTML5,CSS3,JAVASCRIPT"&gt; &lt;meta name="description" content="描述网页信息"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0"&gt; &lt;link rel="shortcut icon" href="favicon.ico必须放在根目录"&gt;&lt;/head&gt; body123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;h1&gt; h1表示网页中的主要内容 对于搜索引擎来说h1重要性仅次于title 页面中只能写一个h1 一般在页面中只使用h1 2 3&lt;/h1&gt;&lt;div class="box"&gt;块级盒子多用于布局&lt;/div&gt;&lt;p&gt;段落,承载文字&lt;/p&gt;换行&lt;br&gt;水平线&lt;hr&gt;实体符 &amp;lt; &amp;gt; &amp;nbsp;&lt;img src="路径" title="多余的 title 影响看图体验，并且增加了页面尺寸" alt="提高图片加载失败时的用户体验"&gt;&lt;!-- 产品 logo、用户头像、用户产生的图片等有潜在下载需求的图片，以 img 形式实现，能方便用户下载。 无下载需求的图片，比如：icon、背景、代码使用的图片等，尽可能采用 CSS 背景图实现。--&gt;&lt;iframe src="#" name="flag"&gt;内联框架&lt;/iframe&gt;&lt;a target="_blank" href="#" title="悬停提示"&gt;target="flag"在内联框架中打开&lt;/a&gt;&lt;a href="#id"&gt;跳转到指定ID位置&lt;/a&gt;&lt;h1 title="鼠标悬停提示文字"&gt;&lt;/h1&gt;&lt;em&gt;斜体/语气强调&lt;/em&gt;&lt;strong&gt;加粗/内容强调&lt;/strong&gt;&lt;small&gt;细则内容/合同中的小字或版权内容等&lt;/small&gt;&lt;cite&gt;引用内容/书名歌名电影等&lt;/cite&gt; &lt;q&gt;短引用/引用别人说的话&lt;/q&gt;&lt;blockquote&gt;长引用/块引用&lt;/blockquote&gt;&lt;sup&gt;上标&lt;/sup&gt;&lt;sub&gt;下标&lt;/sub&gt;&lt;del&gt;删除&lt;/del&gt;&lt;ins&gt;插入&lt;/ins&gt;&lt;abbr&gt;缩写&lt;/abbr&gt;&lt;pre&gt;预格式/保留格式&lt;/pre&gt;&lt;code&gt;文本为代码&lt;/code&gt;&lt;ul type="设置样式"&gt; &lt;li&gt;无&lt;/li&gt; &lt;li&gt;序&lt;/li&gt; &lt;li&gt;列&lt;/li&gt; &lt;li&gt;表&lt;/li&gt;&lt;/ul&gt;&lt;ol type="设置样式"&gt; &lt;li&gt;有&lt;/li&gt; &lt;li&gt;序&lt;/li&gt; &lt;li&gt;列&lt;/li&gt; &lt;li&gt;表&lt;/li&gt;&lt;/ol&gt;&lt;dl&gt; &lt;dt&gt;自定义内容&lt;/dt&gt; &lt;dd&gt;内容描述&lt;/dd&gt;&lt;/dl&gt;&lt;table border="1px"&gt; &lt;thead&gt; &lt;th&gt;表&lt;/th&gt; &lt;th&gt;头&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td colspan="2"&gt;左右合并&lt;/td&gt; &lt;td rowspan="2"&gt;上下合并&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;tr行&lt;/td&gt; &lt;td&gt;td列&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;/tfoot&gt;&lt;/table&gt;&lt;form action="index.html" method="get"&gt; &lt;!--有文本标题的控件必须使用 label 标签将其与其标题相关联--&gt; &lt;label for="id"&gt;嵌套或者 for 属性指向控件的 id&lt;/label&gt; &lt;label&gt;文本:&lt;input type="text" name="username" placeholder="提示信息"&gt;&lt;/label&gt; &lt;label&gt;密码:&lt;input type="password"&gt;&lt;/label&gt; &lt;label&gt;邮件:&lt;input type="email"&gt;&lt;/label&gt; &lt;label&gt;单选框:&lt;input type="radio" name="gender" value="boy" checked="checked"&gt; &lt;input type="radio" name="gender" value="girl"&gt;&lt;/label&gt; &lt;label&gt;多选框:&lt;input type="checkbox" name="like" value="football"&gt; &lt;input type="checkbox" name="like" value="pingpang"&gt;&lt;/label&gt; &lt;label&gt; 下拉列表: &lt;select name="love" &gt;&lt;!--multiple="multiple" 可多选--&gt; &lt;option value="one"&gt;1&lt;/option&gt; &lt;optgroup label="分组"&gt; &lt;option value="two" selected="selected"&gt;2&lt;/option&gt; &lt;/optgroup&gt; &lt;option value="three"&gt;3&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; &lt;label&gt;文本域:&lt;textarea name="info" style="resize: none"&gt;&lt;/textarea&gt;&lt;/label&gt; &lt;label&gt;提交:&lt;input type="submit" value="YES"&gt;&lt;/label&gt; &lt;label&gt;重置:&lt;input type="reset"&gt;&lt;/label&gt; &lt;input type="button" value="按钮"&gt; &lt;!--button必须指定type 尽量不要使用name属性--&gt; &lt;button type="button"&gt;按钮2&lt;/button&gt; &lt;button type="submit"&gt;提交2&lt;/button&gt; &lt;button type="reset"&gt;重置2&lt;/button&gt; &lt;fieldset&gt; &lt;legend&gt;组名&lt;/legend&gt; &lt;/fieldset&gt;&lt;/form&gt; CSS css 全部在head中引入 常用规则: 选择器 {空格隔开} 属性: 值 (无空格: 有空格) ,并集多个选择器时每个选择器独占一行 ~ + &gt;符号两边使用空格隔开 属性值&quot;&quot;多个属性 , 结尾; 嵌套层级不大于3, 靠后的限定条件应尽可能精确 border/margin/padding尽量不使用缩写,其他属性尽量使用缩写 属性书写顺序: 如果包含 content 属性，放在最前面 Formatting Model 相关属性包括：position / top / right / bottom / left / float / display / overflow 等 Box Model 相关属性包括：border / margin / padding / width / height 等 Typographic 相关属性包括：font / line-height / text-align / word-wrap 等 Visual 相关属性包括：background / color / transition / list-style 等 通过对伪类设置 clear 或触发 BFC 的方式进行clearfixBFC触发 float 非 none position 非 static overflow 非 visible 当数值为 0 - 1 之间的小数时，省略整数部分的 0 例如.5 url()函数中的路径不加引号 RGB颜色值必须使用十六进制记号形式 #rrggbb, rgba()每个逗号后必须保留一个空格 颜色值可以缩写时,必须使用缩写形式, 不允许使用命名色值 font-family使用 字体英文名 字体不小于12px 按「西文字体在前、中文字体在后」「效果佳的字体在前、效果一般的字体在后」的顺序编写，最后必须指定一个通用字体族( serif / sans-serif ) 尽可能在浏览器能高效实现的属性上添加过渡和动画: transform: translate(npx, npx) transform: scale(n) transform: rotate(ndeg) opacity: 0~1 ​ 典型的，可以使用 translate 来代替 left 作为动画属性 选择器1234567891011121314151617181920212223242526272829303132333435363738* 通配选择器# ID选择器 . 类选择器 , 并集选择器(或) "" 交集选择器(与):first-of-type 同一类型的第一个:last-of-type 同一类型的最后一个:nth-of-type(n) 同一类型的第n个 子元素 : &gt; 子元素选择器 " " 后代选择器 :first-child 第一个子元素 :last-child 最后一个子元素 :nth-child(n) 第n个子元素（even偶 odd奇）兄弟元素 : + 紧接着的兄弟元素 ~ 后面的所有兄弟元素伪类 : 特殊状态的元素 :link 正常链接(未访问) :visited 已访问链接(只能设置颜色) :hover 鼠标悬停 :active 点击状态 :focus 获取焦点 ::selection 内容被选中状态否定伪类 : :not(选择器) 从选中的元素中排除伪元素 : 特殊位置的元素 ::first-letter 首字母 ::first-line 首行 ::before 之前 ::after 之后属性选择器 : "[属性名]" 含有指定属性的元素 "[属性名=属性值]" 含有指定属性值的元素 "[属性名^=内容]" 属性值以指定内容开头的元素 "[属性名$=内容]" 属性值以指定内容结尾的元素 "[属性名*=内容]" 属性包含指定内容的元素 权重 !important 10000 内联样式 1000 id选择器 100 类和伪类 10 元素和伪元素 1 通配* 0 继承样式 - 并集选择器分开计算 样式字体 1234567891011121314151617181920212223242526272829font-size: 12px/1;text-decoration: none;letter-spacing: 10px;/* 字符间距 */word-spacing: 5px;/* 单词(空格)间距 */text-align: center;/* 首行缩进 */text-indent: 2em;font-family: 微软雅黑, 宋体;/* 斜体 */font-style: italic;/* 400正常 700加粗 */font-weight: 400;/* 小型大写字母 */font-variant: small-caps/* font: 必须以 字体大小,字体 结尾行间距 = line-height - font-size单行文本 line-height = height 设置垂直居中*/ 显示省略号 1234display: block;white-space: nowrap;text-overflow: ellipsis;overflow: hidden; 表格 12345border-spacing: 5px;/* 合并单元格 */border-collapse: collapse;/*移入鼠标样式*/cursor: pointer; 常用样式 1234567891011121314151617width: 100px;height: 100px;background-color: greenyellow;background-image: url();background-repeat: no-repeat;background-position: 100px center;border: 2px solid red;/*display: none; 不占有空间*//*visibility: hidden; 隐藏但继续占有空间*//*配合绝对定位使用*/z-index: 1;/* opacity 是元素透明度 rgba() 是透明色 */opacity: 0.3;filter: alpha(opacity=30); 定位1234position: 子绝父相absolute 绝对定位 (相对于最近的开启定位的祖先元素位置/脱离文档流/改变元素性质)relative 相对定位 (相对默认位置/不脱离文档流)fixed 固定定位 (相对于浏览器窗口位置/也属于绝对定位) 当子元素浮动时, 子元素脱离文档流无法撑起父元素的高度, 导致父元素高度塌陷 解决方法开启间接BFC, 设置父元素overflow: hidden 外边距塌子元素和父元素相邻的垂直外边距会发生重叠, 子元素的外边距会传递给父元素, 可以使用空的 table 标签来隔断它们 解决父子元素的外边距塌陷方法 border:1px solid transparent padding float:left/right position:absolute display:inline-block overflow:hidden/auto clearfix1234567.clearfix:before,.clearfix:after &#123; content: ""; line-height: 0; display: table; clear: both;&#125; 双飞翼布局1234567&lt;div class="clearfix"&gt; &lt;div id="mid"&gt; &lt;div id="centent"&gt;content&lt;/div&gt; &lt;/div&gt; &lt;div id="left"&gt;&lt;/div&gt; &lt;div id="right"&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627#mid &#123; width: 100%; height: 200px; background-color: greenyellow; float: left; overflow: hidden;&#125;#left &#123; width: 100px; height: 200px; background-color: rosybrown; float: left; margin-left: -100%;&#125;#right &#123; width: 100px; height: 200px; background-color: cornflowerblue; float: left; margin-left: -100px;&#125;#content &#123; margin: 0 100px;&#125; 语义化 什么是语义化 让机器可以读懂内容 (SEO, 屏幕阅读器, 爬虫) ​ 其他程序员能见文知意 (方便维护) 做法 1. 全局只有一个`h1`就是它的logo, 分栏`h2`, 再细分`h3` 2. 尽量少用`div`和`span`, `div`布局`p`显示内容 3. html标签注重语义, css实现样式 4. 表格 标题使用`caption`主体分`thead` `tbody` `tfoot`, 表头用`th`单元格用`td` 5. 表单输入关联`lable`标签 viewportpc端视窗的大小直接根据浏览器窗口的大小来决定 在移动设备中 浏览器和网页之间 有一层虚拟容器 viewport 用来承载网页 该容器默认宽度980px, 可以设置缩放 标准化适配: 网页宽度 = 视窗宽度 = 浏览器宽度(设备屏幕大小) 缩放1 (保持和PC端一致) 不允许用户缩放 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0"&gt; 布局浮动会提升半层 (定位一层) 下层为盒模型, 上层为内容 上面的div浮动, 盒模型层级为1 内容层级为1.5 下面的div不浮动 盒模型为0.5 所以向上填充, 内容层级为1 所以被浮动div的盒模型卡住 所以保持原位不动 三列布局 中间列写在最上面 三列浮动搭建完整的框架 margin 为负值调整旁边两列的位置 (使三列布局到一行上) 使用padding和相对定位调整内容位置(圣杯) 多加一个div来调整内容位置(双飞翼) 伪等高布局123padding-bottom: 2000px 撑开背景margin-bottom: -2000px 收回边界父元素 overflow: hidden 隐藏多余部分 粘连布局(css sticky footer)12345678910&lt;div id="main"&gt;min-height: 100%; &lt;div&gt; padding-bottom: 100px; &lt;/div&gt;&lt;/div&gt;&lt;div class="footer"&gt;height: 100px;margin-top: -100px;&lt;/div&gt; 定位定位参照 相对于最近的 开启了定位的 祖先元素 (子绝父相) 都没有开启定位的父元素 则相对于初始包含块 固定定位参照于视口 包含块浮动元素 包含块为最近的块级祖先元素 定位元素 根元素html的包含块 就是初始包含块, 由用户代理创建, 初始包含块默认和视口的大小及位置相同 初始包含块不等于视口 非根元素position是relative或static包含块则是最近的块级(表单元格或行内块)祖先框的内边界构成 百分比参照 left和top 默认值为 auto(原位置不动) 不是0 margin和padding的百分比 相对于父元素的 width 绝对定位模拟固定定位 html {overflow: hidden}静止系统滚动条 body {overflow: auto}将滚动条添加给body 将body的尺寸设为视口的尺寸 初始包含块固定, body滚动 BFC定义: block formatting context (块级格式化上下文) 它是一个独立的渲染区域, 只管理内部的块级元素布局, 且不会影响BFC外部 BFC布局规则(5种) 内部块级元素独占一行 内部的BFC区域不与浮动盒子重叠 两列布局: 上div 浮动, 下div BFC 内部的Box垂直方向的距离由margin决定, 同一个BFC内.的两个相交的块级盒子的margin会发生重叠 解决方法嵌套一个触发BFC的div或使用padding 计算BFC高度时, 浮动元素也参与计算 清除浮动 BFC是独立容器内外不会相互影响 BFC触发方式(5种) 根元素 float元素 定位元素 overflow元素 display为 inline-block, table-cell, table-caption, flex, inline-flex FLEX布局 注意: 设为 Flex 布局以后, 子元素的float、clear和vertical-align属性将失效 父元素设置为弹性盒子 1display: flex; 设置主轴方向,换行 默认: row水平 nowrap不换行 1flex-flow: column; 设置子元素主轴方向对齐方式 默认 flex-start 沿主轴排列 1234justify-content: centercenter 居中: 向中心靠齐, 多余空间平分到两端space-between 两端对齐: 两端贴边, 多余空间 平局分布在中间space-around 等外边距对齐: 最外侧的边距只有中间的 1/2 设置子元素交叉轴方向对齐方式 默认 stretch 填满交叉轴 设置第一行内每个元素的对齐 所以多行不生效 123align-items: centercenter 居中: 向中心靠齐, 多余空间平分到两端baseline 以第一行文字的基线(底部)对齐 设置内部有多行子元素时的对齐方式 默认 stretch 填满交叉轴 把每一行 当做一个元素来看 所以单行不生效 1234align-content: centercenter 居中: 向中心靠齐, 多余空间平分到两端space-between 两端对齐: 两端贴边, 多余空间 平局分布在中间space-around 等外边距对齐: 最外侧的边距只有中间的 1/2 设置子元素缩放比例 默认为0 1 auto 1230 (空间多余时按设置比例放大. 默认0不放大, n表示占剩余空间的n份) 1 (空间不足时按设置比例缩小. 0的元素不缩小, 都设置为1则等比例缩小) auto (元素的大小) 可以单独配置某个元素的对齐方式 覆盖父元素align-items设置 1align-self: auto 居中 块级元素水平居中 margin: 0 auto; 块级元素垂直居中 vertical-align:middle; position: absolute; top: 50%; transform: translateY(-50%); 内联元素水平居中 text-align: center; 内联元素垂直居中 line-height = height;]]></content>
      <categories>
        <category>Html</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax笔记]]></title>
    <url>%2F2018%2F09%2F07%2FAjax%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[AJAXAJAX请求是异步执行的，也就是说，要通过回调函数获得响应。 在现代浏览器上写AJAX主要依靠XMLHttpRequest对象 AJAX请求AJAX 是一套 API 核心提供的类型 : XMLHttpRequest AJAX 操作的页面 “不能” 使用文件的方式访问 新建用户代理 状态0 初始化请求代理对象 1const xhr = new XMLHttpRequest 设置请求行 状态1 建立一个与服务端特定端口的连接 1xhr.open('GET/POST', URL) 设置请求头/体 携带请求参数 12xhr.setRequestHeader('Content-Type', 'application/x-www-from-urlencoded(/json)')xhr.send(null/'key=value') 等待响应 每当 readyState 改变时触发回调函数 1234567891011121314151617181920xhr.onreadystatechange = function () &#123; // 状态2 表示已经收到响应头 if (this.readyState === 2) &#123; console.log(this.getAllResponseHeaders()) &#125; // 状态3 表示正在下载响应体 if (this.readyState === 3) &#123; console.log('响应体responseText可能不完整') &#125; // 状态4 表示响应报文全部下载完成 if (this.readyState === 4) &#123; // this.status === 200 时表示下载成功 if (this.status === 200) &#123; //响应体数据在 this.responseText 里 var data = JSON.parse(this.responseText) &#125; else &#123; console.log('请求失败') &#125; &#125;&#125; GET和POST对于一个返回数据的地址我们称之为接口(API) GET (一般用于获取数据) POST (一般用于提交数据) 可见性 数据在 URL 中对所有人都是可见的 数据不会显示在 URL 中,但可以开发者工具或者抓包可以看到 后退按钮/刷新 无害 数据会被重新提交（浏览器应该告知用户数据会被重新提交） 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 历史 参数保留在浏览器历史中 参数不会保存在浏览器历史中 对数据长度的限制 受浏览器限制 一般无限制 对数据类型的限制 只允许 ASCII 字符 没有限制 也允许二进制数据 编码类型 /x-www-form-urlencoded /x-www-form-urlencoded 或 multipart/form-data 为二进制数据使用多重编码 安全性 GET 的安全性较差，因为所发送的数据是 URL 的一部分 POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中 请求过程 对于GET方式的请求,浏览器会把http header和data一并发送出去,服务器响应200(返回数据) 对于POST,浏览器先发送header,服务器响应100 continue,浏览器再发送data,服务器响应200(返回数据) jQuery.ajax使用jQuery发送ajax请求 1234567891011121314151617181920212223242526272829$.ajax(&#123; type: 'get', url: 'url', data: &#123; key: value &#125;, dataType: 'json', // 设置响应体类型 success: function (res) &#123; console.log('请求成功' + res) &#125;, error: function (err) &#123; console.log('请求失败') &#125;, complate: function () &#123; console.log('请求完成回调') &#125;&#125;)// get请求简便写法$.get('url', &#123;data&#125;, function (res) &#123;&#125;)// post请求简便写法$.post('url', &#123;data&#125;, function (res) &#123;&#125;)// 请求 + JSON转换$.getJSON('url', &#123;data&#125;, function (res) &#123;&#125;) load方法pjax:jQuery.load方法局部刷新页面 1$('#div').load('url #refresh') 它将检索 url 返回的页面内容获取ID为 #refresh 元素的内容并且插入到ID为 #div 元素而其他未被检索到的元素将被废弃 ajax请求时切换loading状态 123456$(document).ajaxStart(function () &#123; $('#loading').show()&#125;)$(document).ajaxStop(function () &#123; $('#loading').hide()&#125;) 跨域请求同源策略指的就是:不同源地址之间,默认不能相互发送AJAX请求 不同源地址之间如果需要相互请求,必须服务器和客户端配合才能完成 JSONP:借助script标签发送跨域请求 动态设置script标签的src属性 12let randomFun = 'jsonp_' + Date.now()script.src = url + '?' + 参数 + '&amp;callback=' + randomFun 定义回调函数: 1234window[randomFun] = function (data) &#123; delete window[randomFun] document.body.removeChild('script')&#125; 服务端配合: 1header("Content-Type: application/javascript") 返回调用随机函数的代码,并将要传递的数据作为实参: 随机函数名(data) jQuery中使用JSONP调用方法和ajax相同, 只需要设置 dataType: “jsonp” CORS( 跨域资源共享):服务器设置 header(&#39;Access-Control-Allow-Origin: *&#39;)]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>ajax</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6笔记]]></title>
    <url>%2F2018%2F09%2F07%2FES6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ES6ECMA和严格模式ECMA 它是一种由ECMA组织（前身为欧洲计算机制造商协会）制定和发布的脚本语言规范 我们学的JavaScript是ECMA的实现, 但术语ECMAScript和JavaScript平时表达同一个意思 JS包含三个部分： ECMAScript（核心） 扩展 ==&gt; 浏览器端 BOM（浏览器对象模型） DOM（文档对象模型） 扩展 ==&gt; 服务器端 ES的几个重要版本 ES5: 09年发布 * ES6 (ES2015): 15年发布, 也称为ECMA2015 * ES7 (ES2016): 16年发布, 也称为ECMA2016 (变化不大) 严格模式 理解 除了正常运行模式(混杂模式)，ES5添加了第二种运行模式: “严格模式” (strict mode) 顾名思义，这种模式使得Javascript在更严格的语法条件下运行 目的/作用 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 消除代码运行的一些不安全之处，为代码的安全运行保驾护航 为未来新版本的Javascript做好铺垫 使用 在全局或函数的第一条语句定义为: &#39;use strict&#39; 如果浏览器不支持, 只解析为一条简单的语句, 没有任何副作用 语法和行为改变 必须用var声明变量 禁止自定义的函数中的this指向window 创建eval作用域 对象不能有重名的属性 ES5拓展JSON拓展1JSON.stringify(obj/arr) js对象(数组)转换为json对象(数组) 1JSON.parse(json) json对象(数组)转换为js对象(数组) Object拓展ES5给Object扩展了一些静态方法, 常用的2个 Object.create(新创建对象的原型对象, [可选: 新建对象自身属性描述符]) 作用: 以指定对象为原型创建新对象作为返回值返回 可以为新的对象指定自身的属性(一个或多个属性都需要封装成对象传入) 对每个属性的数据属性进行描述(描述也需要封装成对象,包含以下属性) value: 属性的默认值 writable: 属性值是否是可修改 默认为false configurable: 属性是否可重新定义 默认为false enumerable: 属性是否能用for in枚举 默认为false Object.defineProperties(obj, prop, descriptor) 作用: 为指定对象精确添加或修改对象的属性(属性描述符封装成对象传入) 数据描述符: configurable: 该属性是否可重新定义 writable: 该属性值是否是可修改 value: 该属性的默认值 enumerable: 该属性是否能用 for in 枚举 访问描述符: 123get: function ()&#123; return 值&#125; 设置扩展属性的值的回调函数, 在使用扩展属性的时候才调用, 返回动态计算出的该属性的值(惰性求值) 123set: function(newValue)&#123; return 值&#125; 修改扩展属性的值时触发的回调函数, 修改后的值作为实参传入 Array方法拓展12345678910111213141516// 得到值在数组中的第一个下标arr.indexOf(value)// 得到值在数组中的最后一个下标arr.lastIndexOf(value)// 遍历数组arr.forEach(function(item, index)&#123; // 回调函数&#125;)// 遍历数组将加工后的值 作为新数组返回arr.map(function(item, index)&#123; // 回调函数&#125;)// 遍历过滤出一个新的子数组， 返回条件为true的值arr.filter(function(item, index)&#123; // 回调函数&#125;) Function拓展1fun.bind(obj, 参数 ,...) 作用: 将函数内的this绑定为obj, 但并不执行函数,而只将函数返回 面试题: 区别bind()与call()和apply()? 都能指定函数中的this call(obj, 参数,...)/apply(obj, [参数,...])会立即调用函数,传参不一样 bind(obj, 参数 ,...)不执行函数,只将函数返回 Let 和 Constlet 关键字 作用: 与var类似, 用于声明一个变量 特点: 在块作用域内有效 (ES6中添加) 不能重复声明同名变量 不会预处理, 既不存在变量提升 应用: 循环遍历加监听 使用let取代var是趋势 const 关键字 作用: 定义一个常量 (不可改变引用) 特点: 不能修改 对象可以修改它的属性,但是不能重新赋值引用 其它特点同let 应用: 保存不用改变的数据 解构赋值和模板字符串解构赋值 理解: 相当于声明了多个(一个)变量, 变量的值在赋值的对象或数组里取对应的值 对象的解构赋值(属性名必须对应) let {a, b} = {a:&#39;xxx&#39;, b:&quot;yyy&quot;} 数组的解构赋值(根据下标对应取值) let [a, b] = [1, &#39;zzz&#39;] 用途 给多个形参赋值 模板字符串 作用简化字符串的拼接 模板字符串必须用 包裹 变量部分使用 ${xxx} 包裹 对象简写简化写法总结: 属性名和属性值相同可以省略 对象的方法和function同名可以省略方法名 12345678910let x = 1;let y = 2;let obj = &#123; x, yfun()&#123; //语句 &#125;&#125; 箭头函数 作用: 方便定义匿名函数, 调整**this**指向 基本语法: (形参) =&gt; {函数内容} 没有形参时, 需要用括号占位 一个参数时, 括号可以省略 函数体只有一条语句时, 可以不用大括号, 默认return语句执行后的结果 函数体如果有多条语句: 需要用{}包裹, 若有需要返回的内容需要设置return 常用场景: 回调函数 this 箭头函数没有自己的this 它的this不是调用时决定的 它的this指向箭头函数定义时所属的作用域 理解: * 箭头函数的`this`看它的外层是否有其他函数 * 如果有, 箭头函数的`this`和外层函数相同 * 如果没有, 则指向 `window` … 运算符和形参默认值…运算符用途 可变参数 比arguments更灵活, 但只能搜集末尾所有未接收的实参,以数组保存 12345678function fun(n, ...values) &#123; console.log(arguments); // arguments是伪数组,所以无法用forEach遍历 console.log(values); values.forEach(function (item, index) &#123; console.log(item, index); // n 接收了第一个实参,所以只能打印出2,3 &#125;)&#125;fun(1,2,3); 拓展运算符123456// 将arr1插入arr2中let arr1 = [1,3,5];let arr2 = [2,...arr1,6];// 将数组arr1中的元素依次push到arr2中arr2.push(...arr1); 形参默认值当不传入参数的时候使用形参里的默认值 123function fun(x = 1,y = 2) &#123; // 函数传实参则使用实参, 不传则使用默认值&#125; Promisepromise 主要用于处理异步请求 语法 123456789101112131415161718192021222324252627let promise = new Promise(function(resolve, reject) &#123; // pending: 初始状态 // 定义时立即执行 异步操作&#123; if (boolean) &#123; //fulfilled: 操作成功完成 resolve(data) &#125; else &#123; //rejected: 操作失败 reject("失败") &#125; &#125;&#125;)// 定义异步完成后的回调函数// 异步完成后根据结果执行对应的回调函数promise.then(function(resolve) &#123; //成功时执行的函数&#125;, function(reject) &#123; //失败时,执行的函数&#125;)// 也可以用catch捕获失败promise.then(resolve =&gt; &#123; // 只传入成功回调&#125;).catch(reject =&gt; &#123; // 用catch捕获失败&#125;) 注意点 Promise构造函数执行时立即调用传入的函数 resolve 和 reject 两个回调函数作为参数 调用resolve()时修改状态为成功 fulfilled 调用reject()时修改状态为失败 rejected then()最多可传入两个回调函数, 对应异步成功和失败 then()的返回值仍然是个promise对象 Symbol概念: ES6中添加的一种原始数据类型 symbol 已有的6种原始数据类型：String, Number, Boolean, null, undefined, Object 特点: Symbol表示一个唯一的值，解决命名冲突问题 Symbol的值不能与其他数据进行计算，包括同字符串拼串 for in, for of遍历时不会遍历symbol属性 使用: 调用Symbol函数得到symbol值 注意: 不能使用new symbol作为属性名时必须使用属性选择器 [] 1234// 该方法创建的symbol不放入全局Symbol注册表中let symbol = Symbol()let obj = &#123;&#125;obj[symbol] = 'hello' 标识symbol: 1234let symbol = Symbol('one');let symbol2 = Symbol('two');console.log(symbol); // Symbol('one')console.log(symbol2); // Symbol('two') Iterator 概念: iterator是一种接口机制, 为各种不同的数据结构提供统一的访问机制 作用: 为各种数据结构, 提供一个统一的、简便的访问接口 使得数据结构的成员能够按某种次序排列 ES6创造了一种新的遍历命令for...of循环，iterator接口主要供for...of使用 工作原理: 创建一个指针对象(遍历器对象), 指向数据结构的起始位置 第一次调用next()方法, 指针自动指向数据结构的第一个成员 接下来不断调用next()方法, 指针会一直往后移动, 直到指向最后一个成员 每次调用next()方法返回的是一个包含value和done的对象 {value: 当前成员的值, done: 布尔值} value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束 当遍历结束的时候返回的value值是undefined，done值为false 原生具备iterator接口的数据: Array arguments String set map 当使用 for of 去遍历某一个数据结构时 首先在目标上找Symbol.iterator 找到则可以用for of遍历 否则报错 ...运算符 和 解构赋值 默认也是调用iterator接口 123456789101112131415161718function iteratorFun(obj) &#123; let i = 0 return &#123; next() &#123; return &#123; value: obj.data[i++], done: i &gt; obj.data.length &#125; &#125; &#125;&#125; let obj = &#123; data: ["无", "聊", "大", "作", "战"] , [Symbol.iterator]() &#123; return iteratorFun(this) &#125;&#125; Generator 概念 生成器函数在执行时能暂停, 后面又能从暂停处继续执行 调用一个生成器函数并不会马上执行它里面的语句, 而是返回一个这个生成器的迭代器/遍历器(iterator)对象 当这个遍历器的next()方法被调用时, 其内的语句会执行到出现yield的位置为止 包括紧跟yield的语句 yield后紧跟遍历器要返回的值 next()方法返回一个对象, 这个对象包含两个属性: value和done value属性表示本次yield表达式的返回值 done属性为布尔类型, 表示生成器后续是否还有yield语句, 即生成器函数是否已经执行完毕并返回 调用next()方法时，如果传入了参数, 那么这个参数会作为上一条执行的yield的值 用途 ES6提供的解决异步编程的方案之一 Generator函数是一个状态机，内部封装了不同状态的数据 用来生成遍历器对象 特点 function与函数名之间有一个星号 内部用yield表达式来定义不同的状态 可暂停函数(惰性求值) 注意 generator函数返回的是指针对象(iterator)，而不会执行函数内部逻辑 调用next()方法函数内部逻辑开始执行，遇到yield表达式停止，返回{value: yield后的表达式结果/undefined, done: false/true} 再次调用next()方法会从上一次停止时的yield处开始, 到下一个yield为止 yield语句返回结果通常为undefined, 当调用next()方法时传参内容会作为启动时yield的返回值 class`class`声明创建一个基于原型继承的具有给定名称的新类. 类声明**不允许**再次声明已经存在的类，否则将会抛出一个类型错误。 123456789101112131415161718192021222324// class 定义类class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; showName() &#123; console.log(this.name) &#125;&#125;let per = new Person("test", 18)// extends 继承类class extendsPer extends Person &#123; constructor(name, age, salary) &#123; // 调用父类的构造方法 (需要传入参数) super(name, age) this.salary = salary &#125; showName() &#123; console.log(this.name + this.salary) &#125;&#125;let extPer = new extendsPer("extTest", 16, 666) 通过class定义类/实现类的继承 在类中通过constructor定义构造方法 通过new来创建类的实例 通过extends来实现类的继承 通过super调用父类的构造方法 可在子类中重写父类中继承的一般方法 类声明不可以提升 方法必须使用简写 字符串/数值拓展字符串 includes(str): 判断是否包含指定的字符串 startsWith(str): 判断是否以指定字符串开头 endsWith(str): 判断是否以指定字符串结尾 repeat(count): 重复指定次数 String.prototype.padStart(maxLength, fillString = &quot;&quot;)或padEnd: 在字符串的开头或结尾处用fillString将它填充到指定长度 数值 二进制与八进制数值表示法: 二进制用0b, 八进制用`0o Number.isFinite(i): 判断是否是有限大的数 Number.isNaN(i): 判断是否是NaN Number.isInteger(i): 判断是否是整数 Number.parseInt(str): 将字符串转换为对应的数值 Math.trunc(i): 直接去除小数部分 数组/对象拓展数组 Array.from(v): 将伪数组对象或可遍历对象转换为真数组 Array.of(v1, v2, v3): 将一系列值转换成数组 find(function(value, index, arr){return true}): 返回第一个满足条件返回true的元素 findIndex(function(value, index, arr){return true}): 返回第一个满足条件返回true的元素下标 对象 Object.is(v1, v2): 判断2个数据是否完全相等 Object.assign(target, source1, source2..): 将源对象的属性复制到目标对象上 直接操作__proto__属性 之前只能通过 构造函数的prototype来操作实例的___proto___ 深度克隆 浅拷贝数据: 拷贝引用, 操作会影响原数据 直接赋值给另一个变量 Object.assign() Array.prototype.concat() Array.prototype.slice() 深拷贝(深度克隆): 生成新数据, 操作不会影响原数据 JSON.parse(JSON.stringify()) 可以拷贝数组和对象, 不能拷贝函数 深度克隆方法: 递归遍历原对象或数组, 遇到对象或数组继续遍历里面的内容, 直到拿到的是基本数据类型才复制 123456789101112131415161718192021222324function typeCheck(test) &#123; //使用 Object 原型上的 toString 方法检测数据类型, 返回数据类型的字符串 return Object.prototype.toString.call(test).slice(8, -1)&#125;function copy(obj) &#123; let res if (typeCheck(obj) === "Object") &#123; res = &#123;&#125; &#125; else if (typeCheck(obj) === "Array") &#123; res = [] &#125; else &#123; return obj &#125; for (let i in obj) &#123; if (typeCheck(obj[i]) === "Object" || typeCheck(obj[i]) === "Array") &#123; let obj2 = copy(obj[i]) res[i] = obj2 &#125; else &#123; res[i] = obj[i] &#125; &#125; return res&#125; Set和Map容器set**无序**不可重复, 可存储任何数据类型, 无论是原始值或者是对象 语法: let mySet = new Set(xxx) add(value): Set对象尾部添加一个元素, 返回该Set对象 delete(value): 移除Set的中与这个值相等的元素 has(value): 返回一个布尔值, 表示该值在Set中存在与否 clear(): 清空Set对象 size: Set中储存的数据的数量 可以用for...of进行遍历 mySet / mySet.keys() / mySet.values() 数组去重 1234// 用Set构造器将Array转换为Setvar mySet = new Set(myArray)// 用...操作符将Set还原为Arrayconsole.log([...mySet]) map**有序**不可重复, 用于保存键值对, **任何值**(对象或者原始值) 都可以作为一个键或一个值 for...of 循环为每次迭代返回一个[key，value]数组 和Object的区别: Map 的键可以是任意值, 包括函数、对象 Map 中的键值是有序的 size 属性直接获取一个 Map 的键值对个数 Map 是可迭代的 语法: let myMap = new Map([{key1, value1}, {key2, value2}...]) set(key, value): 像Map中添加数据, 返回该Map对象 get(key): 返回键对应的值，如果不存在，则返回undefined delete(key): 移除任何与键相关联的值，并且返回该值 has(key): 返回一个布尔值，表示Map实例是否包含键对应的值 clear(): 移除Map对象的所有键 / 值对 size: 返回Map 的键值对个数 for…of 遍历数组 遍历Set 遍历Map 遍历字符串 遍历伪数组 for...of / for...in / forEach 的区别: for...in index索引为字符串型数字, 不能直接进行几何运算 遍历顺序有可能不是按照实际的内部顺序 使用for...in会遍历数组所有的可枚举属性, 包括原型上的 适合遍历对象 index ==&gt; key for...of 遍历的只是数组内的元素, 而不包括数组的原型 不能遍历普通对象, 因为没有 iterator 接口 适合遍历数组 index ==&gt; value forEach(callback(Value, index, arr)) 对数组的每个元素执行一次提供的回调函数 只能遍历数组 无法break或者return中断 async函数async 函数 当调用一个async函数时, 会返回一个Promise对象 当这个async函数返回一个值时, Promise的resolve()方法会负责传递这个值 当async函数抛出异常时, Promise的reject()方法也会传递这个异常值 async函数中可能会有await表达式, 可以使async函数暂停执行 等表达式中的Promise解析完成后继续执行async函数并返回解决结果 await 表达式 会暂停当前async函数的执行, 等待Promise处理完成 若Promise正常处理(fulfilled), 其回调的resolve函数参数作为await表达式的值，继续执行async函数 若Promise处理异常(rejected), await表达式会把Promise的异常原因抛出 如果await操作符后的表达式的值不是一个Promise, 那么该值将被转换为一个已正常处理的Promise 注意: await关键字仅仅在async function中有效 概念: 真正意义上去解决异步回调的问题，同步流程表达异步操作 本质: Generator的语法糖 12345async function fun() &#123; // await后面执行异步操作, 前面保存异步结果 const result = await ajax() console.log(result)&#125; 特点: 不需要像Generator去调用next()方法, 遇到await等待, 当前的异步操作完成就往下执行 返回的总是Promise对象, 可以用then()方法进行下一步操作 async取代 Generator 函数的星号*, await取代 Generator 的yield 语意上更为明确, 使用简单, 暂时没有任何副作用 模块化export暴露数据 1234567891011121314151617export function test() &#123; console.log("暴露test函数")&#125;export let arr = [1, 2, 3]// 可以将要暴露的多函数放到一个对象里function fun1() &#123; console.log("fun1")&#125;function fun2() &#123; console.log("fun2")&#125;export &#123;fun1, fun2&#125;// 默认暴露 --- 可以暴露任意数据类型, 暴露什么类型的数据接收到的就是什么数据// 一个文件只能使用一次 export default 引入直接用一个变量接收即可export default xxx import引入数据 12import &#123;fun1, fun2&#125; from &quot;./路径/文件名&quot;import xxx from &quot;./xxx.js&quot;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
</search>
