<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ajax笔记]]></title>
    <url>%2F2018%2F09%2F07%2FAjax%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[AJAXAJAX请求是异步执行的，也就是说，要通过回调函数获得响应。 在现代浏览器上写AJAX主要依靠XMLHttpRequest对象 AJAX请求AJAX 是一套 API 核心提供的类型 : XMLHttpRequest AJAX 操作的页面 “不能” 使用文件的方式访问 新建用户代理 状态0 初始化请求代理对象 1const xhr = new XMLHttpRequest 设置请求行 状态1 建立一个与服务端特定端口的连接 1xhr.open('GET/POST', URL) 设置请求头/体 携带请求参数 12xhr.setRequestHeader('Content-Type', 'application/x-www-from-urlencoded(/json)')xhr.send(null/'key=value') 等待响应 每当 readyState 改变时触发回调函数 1234567891011121314151617181920xhr.onreadystatechange = function () &#123; // 状态2 表示已经收到响应头 if (this.readyState === 2) &#123; console.log(this.getAllResponseHeaders()) &#125; // 状态3 表示正在下载响应体 if (this.readyState === 3) &#123; console.log('响应体responseText可能不完整') &#125; // 状态4 表示响应报文全部下载完成 if (this.readyState === 4) &#123; // this.status === 200 时表示下载成功 if (this.status === 200) &#123; //响应体数据在 this.responseText 里 var data = JSON.parse(this.responseText) &#125; else &#123; console.log('请求失败') &#125; &#125;&#125; GET和POST对于一个返回数据的地址我们称之为接口(API) GET (一般用于获取数据) POST (一般用于提交数据) 可见性 数据在 URL 中对所有人都是可见的 数据不会显示在 URL 中,但可以开发者工具或者抓包可以看到 后退按钮/刷新 无害 数据会被重新提交（浏览器应该告知用户数据会被重新提交） 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 历史 参数保留在浏览器历史中 参数不会保存在浏览器历史中 对数据长度的限制 受浏览器限制 一般无限制 对数据类型的限制 只允许 ASCII 字符 没有限制 也允许二进制数据 编码类型 /x-www-form-urlencoded /x-www-form-urlencoded 或 multipart/form-data 为二进制数据使用多重编码 安全性 GET 的安全性较差，因为所发送的数据是 URL 的一部分 POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中 请求过程 对于GET方式的请求,浏览器会把http header和data一并发送出去,服务器响应200(返回数据) 对于POST,浏览器先发送header,服务器响应100 continue,浏览器再发送data,服务器响应200(返回数据) jQuery.ajax使用jQuery发送ajax请求 1234567891011121314151617181920212223242526272829$.ajax(&#123; type: 'get', url: 'url', data: &#123; key: value &#125;, dataType: 'json', // 设置响应体类型 success: function (res) &#123; console.log('请求成功' + res) &#125;, error: function (err) &#123; console.log('请求失败') &#125;, complate: function () &#123; console.log('请求完成回调') &#125;&#125;)// get请求简便写法$.get('url', &#123;data&#125;, function (res) &#123;&#125;)// post请求简便写法$.post('url', &#123;data&#125;, function (res) &#123;&#125;)// 请求 + JSON转换$.getJSON('url', &#123;data&#125;, function (res) &#123;&#125;) load方法pjax:jQuery.load方法局部刷新页面 1$('#div').load('url #refresh') 它将检索 url 返回的页面内容获取ID为 #refresh 元素的内容并且插入到ID为 #div 元素而其他未被检索到的元素将被废弃 ajax请求时切换loading状态 123456$(document).ajaxStart(function () &#123; $('#loading').show()&#125;)$(document).ajaxStop(function () &#123; $('#loading').hide()&#125;) 跨域请求同源策略指的就是:不同源地址之间,默认不能相互发送AJAX请求 不同源地址之间如果需要相互请求,必须服务器和客户端配合才能完成 JSONP:借助script标签发送跨域请求 动态设置script标签的src属性 12let randomFun = 'jsonp_' + Date.now()script.src = url + '?' + 参数 + '&amp;callback=' + randomFun 定义回调函数: 1234window[randomFun] = function (data) &#123; delete window[randomFun] document.body.removeChild('script')&#125; 服务端配合: 1header("Content-Type: application/javascript") 返回调用随机函数的代码,并将要传递的数据作为实参: 随机函数名(data) jQuery中使用JSONP调用方法和ajax相同, 只需要设置 dataType: “jsonp” CORS( 跨域资源共享):服务器设置 header(&#39;Access-Control-Allow-Origin: *&#39;)]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6笔记]]></title>
    <url>%2F2018%2F09%2F07%2FES6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ES6ECMA和严格模式ECMA 它是一种由ECMA组织（前身为欧洲计算机制造商协会）制定和发布的脚本语言规范 我们学的JavaScript是ECMA的实现, 但术语ECMAScript和JavaScript平时表达同一个意思 JS包含三个部分： ECMAScript（核心） 扩展 ==&gt; 浏览器端 BOM（浏览器对象模型） DOM（文档对象模型） 扩展 ==&gt; 服务器端 ES的几个重要版本 ES5: 09年发布 ES6 (ES2015): 15年发布, 也称为ECMA2015 ES7 (ES2016): 16年发布, 也称为ECMA2016 (变化不大) 严格模式 理解 除了正常运行模式(混杂模式)，ES5添加了第二种运行模式: “严格模式” (strict mode) 顾名思义，这种模式使得Javascript在更严格的语法条件下运行 目的/作用 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 消除代码运行的一些不安全之处，为代码的安全运行保驾护航 为未来新版本的Javascript做好铺垫 使用 在全局或函数的第一条语句定义为: &#39;use strict&#39; 如果浏览器不支持, 只解析为一条简单的语句, 没有任何副作用 语法和行为改变 必须用var声明变量 禁止自定义的函数中的this指向window 创建eval作用域 对象不能有重名的属性 ES5拓展JSON拓展1JSON.stringify(obj/arr) js对象(数组)转换为json对象(数组) 1JSON.parse(json) json对象(数组)转换为js对象(数组) Object拓展ES5给Object扩展了一些静态方法, 常用的2个 Object.create(新创建对象的原型对象, [可选: 新建对象自身属性描述符]) 作用: 以指定对象为原型创建新对象作为返回值返回 可以为新的对象指定自身的属性(一个或多个属性都需要封装成对象传入) 对每个属性的数据属性进行描述(描述也需要封装成对象,包含以下属性) value: 属性的默认值 writable: 属性值是否是可修改 默认为false configurable: 属性是否可重新定义 默认为false enumerable: 属性是否能用for in枚举 默认为false Object.defineProperties(obj, prop, descriptor) 作用: 为指定对象精确添加或修改对象的属性(属性描述符封装成对象传入) 数据描述符: configurable: 该属性是否可重新定义 writable: 该属性值是否是可修改 value: 该属性的默认值 enumerable: 该属性是否能用 for in 枚举 访问描述符: 123get: function ()&#123; return 值&#125; 设置扩展属性的值的回调函数, 在使用扩展属性的时候才调用, 返回动态计算出的该属性的值(惰性求值) 123set: function(newValue)&#123; return 值&#125; 修改扩展属性的值时触发的回调函数, 修改后的值作为实参传入 Array方法拓展12345678910111213141516// 得到值在数组中的第一个下标arr.indexOf(value)// 得到值在数组中的最后一个下标arr.lastIndexOf(value)// 遍历数组arr.forEach(function(item, index)&#123; // 回调函数&#125;)// 遍历数组将加工后的值 作为新数组返回arr.map(function(item, index)&#123; // 回调函数&#125;)// 遍历过滤出一个新的子数组， 返回条件为true的值arr.filter(function(item, index)&#123; // 回调函数&#125;) Function拓展1fun.bind(obj, 参数 ,...) 作用: 将函数内的this绑定为obj, 但并不执行函数,而只将函数返回 面试题: 区别bind()与call()和apply()? 都能指定函数中的this call(obj, 参数,...)/apply(obj, [参数,...])会立即调用函数,传参不一样 bind(obj, 参数 ,...)不执行函数,只将函数返回 Let 和 Constlet 关键字 作用: 与var类似, 用于声明一个变量 特点: 在块作用域内有效 (ES6中添加) 不能重复声明同名变量 不会预处理, 既不存在变量提升 应用: 循环遍历加监听 使用let取代var是趋势 const 关键字 作用: 定义一个常量 (不可改变引用) 特点: 不能修改 对象可以修改它的属性,但是不能重新赋值引用 其它特点同let 应用: 保存不用改变的数据 解构赋值和模板字符串解构赋值 理解: 相当于声明了多个(一个)变量, 变量的值在赋值的对象或数组里取对应的值 对象的解构赋值(属性名必须对应) let {a, b} = {a:&#39;xxx&#39;, b:&quot;yyy&quot;} 数组的解构赋值(根据下标对应取值) let [a, b] = [1, &#39;zzz&#39;] 用途 给多个形参赋值 模板字符串 作用简化字符串的拼接 模板字符串必须用 包裹 变量部分使用 ${xxx} 包裹 对象简写简化写法总结: 属性名和属性值相同可以省略 对象的方法和function同名可以省略方法名 12345678910let x = 1;let y = 2;let obj = &#123; x, yfun()&#123; //语句 &#125;&#125; 箭头函数 作用: 方便定义匿名函数, 调整**this**指向 基本语法: (形参) =&gt; {函数内容} 没有形参时, 需要用括号占位 一个参数时, 括号可以省略 函数体只有一条语句时, 可以不用大括号, 默认return语句执行后的结果 函数体如果有多条语句: 需要用{}包裹, 若有需要返回的内容需要设置return 常用场景: 回调函数 this 箭头函数没有自己的this 它的this不是调用时决定的 它的this指向箭头函数定义时所属的作用域 理解: * 箭头函数的`this`看它的外层是否有其他函数 * 如果有, 箭头函数的`this`和外层函数相同 * 如果没有, 则指向 `window` … 运算符和形参默认值…运算符用途 可变参数 比arguments更灵活, 但只能搜集末尾所有未接收的实参,以数组保存 12345678function fun(n, ...values) &#123; console.log(arguments); // arguments是伪数组,所以无法用forEach遍历 console.log(values); values.forEach(function (item, index) &#123; console.log(item, index); // n 接收了第一个实参,所以只能打印出2,3 &#125;)&#125;fun(1,2,3); 拓展运算符123456// 将arr1插入arr2中let arr1 = [1,3,5];let arr2 = [2,...arr1,6];// 将数组arr1中的元素依次push到arr2中arr2.push(...arr1); 形参默认值当不传入参数的时候使用形参里的默认值 123function fun(x = 1,y = 2) &#123; // 函数传实参则使用实参, 不传则使用默认值&#125; Promisepromise 主要用于处理异步请求 语法 123456789101112131415161718192021222324252627let promise = new Promise(function(resolve, reject) &#123; // pending: 初始状态 // 定义时立即执行 异步操作&#123; if (boolean) &#123; //fulfilled: 操作成功完成 resolve(data) &#125; else &#123; //rejected: 操作失败 reject("失败") &#125; &#125;&#125;)// 定义异步完成后的回调函数// 异步完成后根据结果执行对应的回调函数promise.then(function(resolve) &#123; //成功时执行的函数&#125;, function(reject) &#123; //失败时,执行的函数&#125;)// 也可以用catch捕获失败promise.then(resolve =&gt; &#123; // 只传入成功回调&#125;).catch(reject =&gt; &#123; // 用catch捕获失败&#125;) 注意点 Promise构造函数执行时立即调用传入的函数 resolve 和 reject 两个回调函数作为参数 调用resolve()时修改状态为成功 fulfilled 调用reject()时修改状态为失败 rejected then()最多可传入两个回调函数, 对应异步成功和失败 then()的返回值仍然是个promise对象 Symbol概念: ES6中添加的一种原始数据类型 symbol 已有的6种原始数据类型：String, Number, Boolean, null, undefined, Object 特点: Symbol表示一个唯一的值，解决命名冲突问题 Symbol的值不能与其他数据进行计算，包括同字符串拼串 for in, for of遍历时不会遍历symbol属性 使用: 调用Symbol函数得到symbol值 注意: 不能使用new symbol作为属性名时必须使用属性选择器 [] 1234// 该方法创建的symbol不放入全局Symbol注册表中let symbol = Symbol()let obj = &#123;&#125;obj[symbol] = 'hello' 标识symbol: 1234let symbol = Symbol('one');let symbol2 = Symbol('two');console.log(symbol); // Symbol('one')console.log(symbol2); // Symbol('two') Iterator 概念: iterator是一种接口机制, 为各种不同的数据结构提供统一的访问机制 作用: 为各种数据结构, 提供一个统一的、简便的访问接口 使得数据结构的成员能够按某种次序排列 ES6创造了一种新的遍历命令for...of循环，iterator接口主要供for...of使用 工作原理: 创建一个指针对象(遍历器对象), 指向数据结构的起始位置 第一次调用next()方法, 指针自动指向数据结构的第一个成员 接下来不断调用next()方法, 指针会一直往后移动, 直到指向最后一个成员 每次调用next()方法返回的是一个包含value和done的对象 {value: 当前成员的值, done: 布尔值} value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束 当遍历结束的时候返回的value值是undefined，done值为false 原生具备iterator接口的数据: Array arguments String set map 当使用 for of 去遍历某一个数据结构时 首先在目标上找Symbol.iterator 找到则可以用for of遍历 否则报错 ...运算符 和 解构赋值 默认也是调用iterator接口 123456789101112131415161718function iteratorFun(obj) &#123; let i = 0 return &#123; next() &#123; return &#123; value: obj.data[i++], done: i &gt; obj.data.length &#125; &#125; &#125;&#125; let obj = &#123; data: ["无", "聊", "大", "作", "战"] , [Symbol.iterator]() &#123; return iteratorFun(this) &#125;&#125; Generator 概念 生成器函数在执行时能暂停, 后面又能从暂停处继续执行 调用一个生成器函数并不会马上执行它里面的语句, 而是返回一个这个生成器的迭代器/遍历器(iterator)对象 当这个遍历器的next()方法被调用时, 其内的语句会执行到出现yield的位置为止 包括紧跟yield的语句 yield后紧跟遍历器要返回的值 next()方法返回一个对象, 这个对象包含两个属性: value和done value属性表示本次yield表达式的返回值 done属性为布尔类型, 表示生成器后续是否还有yield语句, 即生成器函数是否已经执行完毕并返回 调用next()方法时，如果传入了参数, 那么这个参数会作为上一条执行的yield的值 用途 ES6提供的解决异步编程的方案之一 Generator函数是一个状态机，内部封装了不同状态的数据 用来生成遍历器对象 特点 function与函数名之间有一个星号 内部用yield表达式来定义不同的状态 可暂停函数(惰性求值) 注意 generator函数返回的是指针对象(iterator)，而不会执行函数内部逻辑 调用next()方法函数内部逻辑开始执行，遇到yield表达式停止，返回{value: yield后的表达式结果/undefined, done: false/true} 再次调用next()方法会从上一次停止时的yield处开始, 到下一个yield为止 yield语句返回结果通常为undefined, 当调用next()方法时传参内容会作为启动时yield的返回值 class`class`声明创建一个基于原型继承的具有给定名称的新类. 类声明**不允许**再次声明已经存在的类，否则将会抛出一个类型错误。 123456789101112131415161718192021222324// class 定义类class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; showName() &#123; console.log(this.name) &#125;&#125;let per = new Person("test", 18)// extends 继承类class extendsPer extends Person &#123; constructor(name, age, salary) &#123; // 调用父类的构造方法 (需要传入参数) super(name, age) this.salary = salary &#125; showName() &#123; console.log(this.name + this.salary) &#125;&#125;let extPer = new extendsPer("extTest", 16, 666) 通过class定义类/实现类的继承 在类中通过constructor定义构造方法 通过new来创建类的实例 通过extends来实现类的继承 通过super调用父类的构造方法 可在子类中重写父类中继承的一般方法 类声明不可以提升 方法必须使用简写 字符串/数值拓展字符串 includes(str): 判断是否包含指定的字符串 startsWith(str): 判断是否以指定字符串开头 endsWith(str): 判断是否以指定字符串结尾 repeat(count): 重复指定次数 String.prototype.padStart(maxLength, fillString = &quot;&quot;)或padEnd: 在字符串的开头或结尾处用fillString将它填充到指定长度 数值 二进制与八进制数值表示法: 二进制用0b, 八进制用`0o Number.isFinite(i): 判断是否是有限大的数 Number.isNaN(i): 判断是否是NaN Number.isInteger(i): 判断是否是整数 Number.parseInt(str): 将字符串转换为对应的数值 Math.trunc(i): 直接去除小数部分 数组/对象拓展数组 Array.from(v): 将伪数组对象或可遍历对象转换为真数组 Array.of(v1, v2, v3): 将一系列值转换成数组 find(function(value, index, arr){return true}): 返回第一个满足条件返回true的元素 findIndex(function(value, index, arr){return true}): 返回第一个满足条件返回true的元素下标 对象 Object.is(v1, v2): 判断2个数据是否完全相等 Object.assign(target, source1, source2..): 将源对象的属性复制到目标对象上 直接操作__proto__属性 之前只能通过 构造函数的prototype来操作实例的___proto___ 深度克隆 浅拷贝数据: 拷贝引用, 操作会影响原数据 直接赋值给另一个变量 Object.assign() Array.prototype.concat() Array.prototype.slice() 深拷贝(深度克隆): 生成新数据, 操作不会影响原数据 JSON.parse(JSON.stringify()) 可以拷贝数组和对象, 不能拷贝函数 深度克隆方法: 递归遍历原对象或数组, 遇到对象或数组继续遍历里面的内容, 直到拿到的是基本数据类型才复制 123456789101112131415161718192021222324function typeCheck(test) &#123; //使用 Object 原型上的 toString 方法检测数据类型, 返回数据类型的字符串 return Object.prototype.toString.call(test).slice(8, -1)&#125;function copy(obj) &#123; let res if (typeCheck(obj) === "Object") &#123; res = &#123;&#125; &#125; else if (typeCheck(obj) === "Array") &#123; res = [] &#125; else &#123; return obj &#125; for (let i in obj) &#123; if (typeCheck(obj[i]) === "Object" || typeCheck(obj[i]) === "Array") &#123; let obj2 = copy(obj[i]) res[i] = obj2 &#125; else &#123; res[i] = obj[i] &#125; &#125; return res&#125; Set和Map容器set**无序**不可重复, 可存储任何数据类型, 无论是原始值或者是对象 语法: let mySet = new Set(xxx) add(value): Set对象尾部添加一个元素, 返回该Set对象 delete(value): 移除Set的中与这个值相等的元素 has(value): 返回一个布尔值, 表示该值在Set中存在与否 clear(): 清空Set对象 size: Set中储存的数据的数量 可以用for...of进行遍历 mySet / mySet.keys() / mySet.values() 数组去重 1234// 用Set构造器将Array转换为Setvar mySet = new Set(myArray)// 用...操作符将Set还原为Arrayconsole.log([...mySet]) map**有序**不可重复, 用于保存键值对, **任何值**(对象或者原始值) 都可以作为一个键或一个值 for...of 循环为每次迭代返回一个[key，value]数组 和Object的区别: Map 的键可以是任意值, 包括函数、对象 Map 中的键值是有序的 size 属性直接获取一个 Map 的键值对个数 Map 是可迭代的 语法: let myMap = new Map([{key1, value1}, {key2, value2}...]) set(key, value): 像Map中添加数据, 返回该Map对象 get(key): 返回键对应的值，如果不存在，则返回undefined delete(key): 移除任何与键相关联的值，并且返回该值 has(key): 返回一个布尔值，表示Map实例是否包含键对应的值 clear(): 移除Map对象的所有键 / 值对 size: 返回Map 的键值对个数 for…of 遍历数组 遍历Set 遍历Map 遍历字符串 遍历伪数组 for...of / for...in / forEach 的区别: for...in index索引为字符串型数字, 不能直接进行几何运算 遍历顺序有可能不是按照实际的内部顺序 使用for...in会遍历数组所有的可枚举属性, 包括原型上的 适合遍历对象 index ==&gt; key for...of 遍历的只是数组内的元素, 而不包括数组的原型 不能遍历普通对象, 因为没有 iterator 接口 适合遍历数组 index ==&gt; value forEach(callback(Value, index, arr)) 对数组的每个元素执行一次提供的回调函数 只能遍历数组 无法break或者return中断 async函数async 函数 当调用一个async函数时, 会返回一个Promise对象 当这个async函数返回一个值时, Promise的resolve()方法会负责传递这个值 当async函数抛出异常时, Promise的reject()方法也会传递这个异常值 async函数中可能会有await表达式, 可以使async函数暂停执行 等表达式中的Promise解析完成后继续执行async函数并返回解决结果 await 表达式 会暂停当前async函数的执行, 等待Promise处理完成 若Promise正常处理(fulfilled), 其回调的resolve函数参数作为await表达式的值，继续执行async函数 若Promise处理异常(rejected), await表达式会把Promise的异常原因抛出 如果await操作符后的表达式的值不是一个Promise, 那么该值将被转换为一个已正常处理的Promise 注意: await关键字仅仅在async function中有效 概念: 真正意义上去解决异步回调的问题，同步流程表达异步操作 本质: Generator的语法糖 12345async function fun() &#123; // await后面执行异步操作, 前面保存异步结果 const result = await ajax() console.log(result)&#125; 特点: 不需要像Generator去调用next()方法, 遇到await等待, 当前的异步操作完成就往下执行 返回的总是Promise对象, 可以用then()方法进行下一步操作 async取代 Generator 函数的星号*, await取代 Generator 的yield 语意上更为明确, 使用简单, 暂时没有任何副作用 模块化export暴露数据 1234567891011121314151617export function test() &#123; console.log("暴露test函数")&#125;export let arr = [1, 2, 3]// 可以将要暴露的多函数放到一个对象里function fun1() &#123; console.log("fun1")&#125;function fun2() &#123; console.log("fun2")&#125;export &#123;fun1, fun2&#125;// 默认暴露 --- 可以暴露任意数据类型, 暴露什么类型的数据接收到的就是什么数据// 一个文件只能使用一次 export default 引入直接用一个变量接收即可export default xxx import引入数据 12import &#123;fun1, fun2&#125; from &quot;./路径/文件名&quot;import xxx from &quot;./xxx.js&quot;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>js</tag>
      </tags>
  </entry>
</search>
