<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.4.1" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=6.4.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=6.4.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=6.4.1">










<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.4.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="JavaScriptJS 规范 空格  逗号  前不加空格 , 后加空格   关键词 1234if () &amp;#123;	// 关键字后面加空格	// &amp;#123; 之前加空格&amp;#125;  对象 123ojb = &amp;#123;  a: &apos;前不加空格 : 后加空格&apos;&amp;#125;  函数 1234function() &amp;#123;    //函数的 () 前不加空格    arguments[] =">
<meta name="keywords" content="自学笔记,js">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript笔记">
<meta property="og:url" content="https://consolelog.wang/2018/09/12/JavaScript笔记/index.html">
<meta property="og:site_name" content="无聊大作战">
<meta property="og:description" content="JavaScriptJS 规范 空格  逗号  前不加空格 , 后加空格   关键词 1234if () &amp;#123;	// 关键字后面加空格	// &amp;#123; 之前加空格&amp;#125;  对象 123ojb = &amp;#123;  a: &apos;前不加空格 : 后加空格&apos;&amp;#125;  函数 1234function() &amp;#123;    //函数的 () 前不加空格    arguments[] =">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-05-08T03:18:07.025Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript笔记">
<meta name="twitter:description" content="JavaScriptJS 规范 空格  逗号  前不加空格 , 后加空格   关键词 1234if () &amp;#123;	// 关键字后面加空格	// &amp;#123; 之前加空格&amp;#125;  对象 123ojb = &amp;#123;  a: &apos;前不加空格 : 后加空格&apos;&amp;#125;  函数 1234function() &amp;#123;    //函数的 () 前不加空格    arguments[] =">






  <link rel="canonical" href="https://consolelog.wang/2018/09/12/JavaScript笔记/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>JavaScript笔记 | 无聊大作战</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">无聊大作战</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://consolelog.wang/2018/09/12/JavaScript笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="无聊大作战">
      <meta itemprop="description" content="半路出家，自学前端半年">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无聊大作战">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JavaScript笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-12 06:06:44" itemprop="dateCreated datePublished" datetime="2018-09-12T06:06:44+08:00">2018-09-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-08 11:18:07" itemprop="dateModified" datetime="2019-05-08T11:18:07+08:00">2019-05-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="JS-规范"><a href="#JS-规范" class="headerlink" title="JS 规范"></a>JS 规范</h2><ul>
<li><p><strong>空格</strong></p>
<ol>
<li><p>逗号</p>
<blockquote>
<p>前不加空格 <code>,</code> 后加空格</p>
</blockquote>
</li>
<li><p>关键词</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> () &#123;</span><br><span class="line">	<span class="comment">// 关键字后面加空格</span></span><br><span class="line">	<span class="comment">// &#123; 之前加空格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ojb = &#123;</span><br><span class="line">  a: <span class="string">'前不加空格 : 后加空格'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//函数的 () 前不加空格</span></span><br><span class="line">    <span class="built_in">arguments</span>[] = <span class="string">"函数的[]也不加空格"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>运算符处换行时, 运算符必须在新行的行首</p>
</li>
<li><p><strong>变量:</strong> 使用驼峰命名法</p>
<ol>
<li>常量全部使用字母大写,</li>
<li>单词间下划线分隔</li>
<li>构造函数(类)单词首字母大写</li>
</ol>
</li>
<li><p><strong>命名:</strong></p>
<ol>
<li>类名 使用名词</li>
<li>函数名 使用动宾短语</li>
<li>布尔值 使用 is 或 has 开头</li>
<li>Promise 对象 使用动宾短语的进行时表达</li>
</ol>
</li>
<li><p><strong>类型检测:</strong></p>
<ol>
<li>优先使用<code>typeof</code></li>
<li>对象类型检测使用<code>instanceof</code></li>
<li><code>null</code>或<code>undefined</code>的检测使用 <code>== null</code></li>
</ol>
</li>
<li><p><strong>字符串:</strong></p>
<ol>
<li>JS 内使用<code>&#39;&#39;</code></li>
<li>字符串内使用<code>&quot;&quot;</code></li>
</ol>
</li>
<li><p><strong>新建:</strong> 使用字面量</p>
<ol>
<li>对象 = {}</li>
<li>数组 = []</li>
</ol>
</li>
<li><p><strong>事件:</strong></p>
<p>优先使用<code>addEventListener</code>绑定事件, 第三个参数使用<code>false</code>(冒泡时触发)</p>
</li>
</ul>
<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><ol>
<li><p>JS 中严格区分大小写</p>
</li>
<li><p>JS 中每条语句以<code>;</code>结尾</p>
<blockquote>
<p>也可以不加<code>;</code> 注意当语句以<code>()</code>或<code>[]</code>开头时则需要在前面加上<code>;</code></p>
</blockquote>
</li>
<li><p>JS 中会忽略多个空格和换行</p>
<blockquote>
<p>我们以空格和缩进对代码进行格式化</p>
</blockquote>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">'弹出警告窗口'</span>)</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'页面中写入内容'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'在控制台输出'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--不建议这样写!他们属于结构与行为耦合,不方便维护--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert('JS代码可以编写到按钮的onclick事件中')"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert('JS代码编写到超链接href属性中')"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="字面量和变量"><a href="#字面量和变量" class="headerlink" title="字面量和变量"></a>字面量和变量</h2><ol>
<li><p><strong>常量:</strong></p>
<ul>
<li>都是一些不可改变的值</li>
<li>常量都可以直接使用</li>
</ul>
</li>
<li><p><strong>变量: </strong></p>
<ul>
<li>变量的值是可以任意改变的</li>
</ul>
</li>
<li><p>声明变量: 在 es5 中使用<code>var</code>关键字来声明一个变量</p>
<ul>
<li><code>var a</code></li>
</ul>
</li>
<li><p>为变量赋值</p>
<ul>
<li><code>a = 123</code></li>
</ul>
</li>
<li><p>声明+赋值</p>
<ul>
<li><code>var a = 456</code></li>
</ul>
</li>
<li><p><strong>标识符:</strong> 在 JS 中所有可以由我们自主命名的都可以称为标识符</p>
<ul>
<li>命名规则:<ol>
<li>可以包含字母 数字 <code>_</code> <code>$</code></li>
<li>不能以数字开头</li>
<li>不能是 ES 中的关键字和保留字</li>
<li>驼峰命名法</li>
</ol>
</li>
</ul>
</li>
<li><p>JS 底层保存标识符实际上是用的<code>unicode编码</code>, 理论上所有<code>utf-8</code>中的所有内容都可以当作标识符</p>
</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li><p>在<code>es5</code>中只有<strong>6</strong>种数据类型</p>
<ul>
<li><p><strong>基本数据类型</strong></p>
<ol>
<li>String 字符串</li>
<li>Number 数值</li>
<li>Boolean 布尔值</li>
<li>Null 空值</li>
<li>Undefined 未定义</li>
</ol>
</li>
<li><p><strong>引用数据类型</strong></p>
<ol>
<li>Object 对象</li>
</ol>
<blockquote>
<p>只要不是基本数据类型的都是对象</p>
</blockquote>
</li>
<li><p><strong>特殊对象:</strong></p>
<ol>
<li>Function 封装可执行代码, 并可以调用执行</li>
<li>Array 使用索引有序的保存数据</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>判断方法</strong></p>
<ul>
<li><p><code>typeof</code> 注意返回数据类型的字符串表达,所以对比时要加<code>&#39;&#39;</code></p>
<blockquote>
<p>该方法不能用来判断<code>null</code> <code>object</code> <code>function</code></p>
</blockquote>
</li>
<li><p><code>instanceof</code> 判断 a 是否是 b 的实例,判断对象的具体类型,返回布尔值</p>
</li>
<li><code>===</code> 三等会先判断数据类型, 双等则不会判断数据类型直接比较值</li>
</ul>
</li>
<li><p><strong>类型详情</strong></p>
<ol>
<li><p>String 字符串</p>
<ul>
<li>在 JS 中字符串需要用引号引起来</li>
<li>引号或双引号都行, 但是不能混用</li>
<li>在字符串中用<code>\</code>作为转义符<code>\n</code>换行</li>
</ul>
</li>
<li><p>Number 数值</p>
<ul>
<li><p>JS 中所有数值都是 Number 类型</p>
</li>
<li><p>包括整数和浮点数(小数)</p>
</li>
<li><p><code>Number.MAX_VALUE</code>表示 JS 中的最大数值</p>
</li>
<li><p><code>Number.MIN_VALUE</code>表示 JS 中最小的小数</p>
</li>
<li><p>超过最大值<code>Infinity</code>表示正无穷</p>
</li>
<li><p><code>NaN</code> 特殊数字 Not A Number</p>
</li>
<li><p>使用 JS 进行浮点数计算 会得到一个不精确的结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0.1</span> + <span class="number">0.2</span></span><br><span class="line"><span class="number">0.30000000000000004</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Boolean 布尔值: true 真 false 假</p>
</li>
<li><p>Null 空值</p>
<ul>
<li>表示: 定义了,并且值为空<code>&#39;&#39;</code></li>
<li><code>null</code>空的对象 所以<code>typeof null</code>返回<code>&#39;Object&#39;</code></li>
<li>初始值为<code>null</code>表示该变量是个对象</li>
<li>对象不再使用时, 赋值<code>null</code>可使浏览器对其进行垃圾回收</li>
</ul>
</li>
<li><p>Undefined 未定义: 未定义类型,其实就是没赋值的意思</p>
<blockquote>
<p>当声明一个变量但未赋值时, 变量的值就是 undefined</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>变量的类型</strong></p>
<ol>
<li>基本类型: 保存的是在栈内存中的基本类型数据</li>
<li>引用类型: 是在栈内存中保存对象在堆能存中的储存地址</li>
</ol>
</li>
<li><p>JS 在调用函数时传递变量参数时是引用传递(基本数值/引用地址)</p>
<blockquote>
<p>注意函数的形参是新建一个局部变量, 并复制实参的数值或者引用地址(浅拷贝)</p>
</blockquote>
</li>
</ul>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><ul>
<li><p>转换 String</p>
<ol>
<li><p>调用被转换数据类型的<code>toString()</code>方法</p>
<blockquote>
<p><code>a.toString()</code> 该方法<strong>不会影响原变量</strong>, 它会将转换结果返回</p>
<p><code>null</code>和<code>undefined</code>没有<code>toString</code>方法, 调用会报错</p>
</blockquote>
</li>
<li><p>调用<code>String()</code>函数</p>
<blockquote>
<p>调用函数<code>String(a)</code>将被转换的数据作为参数传递给函数</p>
</blockquote>
<ul>
<li>该方法也<strong>不会影响变量</strong>, 也是将结果返回</li>
<li>对于<code>Number</code>和<code>Boolean</code>实际上还是调用的<code>toString()</code>方法</li>
<li>对于<code>null</code>和<code>undefined</code>则不会调用<code>toString()</code>方法, 直接转换</li>
</ul>
</li>
<li><p>简便方法: <code>+ &#39;&#39;</code></p>
</li>
</ol>
</li>
<li><p>转换 Number</p>
<ol>
<li><p>调用 Number()函数</p>
<ul>
<li><p>字符串 ==&gt; 数字</p>
<ol>
<li>纯数字直接转</li>
<li>有非数字转为<code>NaN</code></li>
<li>空字符串或空格转换为<code>0</code></li>
</ol>
</li>
<li><p>布尔值 ==&gt; 数字</p>
<ol>
<li>true == 1</li>
<li>false == 0</li>
</ol>
</li>
<li><p>null == 0</p>
</li>
<li>undefined NaN</li>
</ul>
</li>
<li><p>parse 方法:</p>
<ul>
<li><p><code>parseInt()</code> 把字符串转换为一个整数</p>
<blockquote>
<p>取出字符串中的连续数字,从左往右 遇到非数字立即结束</p>
</blockquote>
</li>
<li><p><code>parseFloat()</code> 把字符串转为浮点数</p>
<blockquote>
<p>对非 String 使用为<code>NaN</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p>简便方法: <code>+</code></p>
</li>
</ol>
</li>
<li><p>转换 Boolean</p>
<ol>
<li><p>使用 Boolean()函数</p>
<ul>
<li>数字 ==&gt; 布尔: 除了<code>0</code>和<code>NaN</code>是<code>false</code>其余为<code>true</code></li>
<li>字符串 ==&gt;布尔: 除了空串是<code>false</code>其余为<code>true</code></li>
<li><code>null</code>和<code>undefined</code>都是<code>false</code></li>
<li>任何对象都为<code>true</code>包括空对象/空数组</li>
</ul>
</li>
<li><p>简便方法: <code>!!</code></p>
</li>
</ol>
</li>
</ul>
<h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p>运算符也叫操作符, 通过运算符可以对一个值或多个值进行运算, 并获取结果</p>
<p>比如<code>typeof</code>就是运算符, 用来获取一个值的类型</p>
<ul>
<li><p>算术运算符</p>
<ol>
<li><p><code>+</code>加法: 对非 Number 运算会先转换城 Number 再进行运算</p>
<blockquote>
<p>任何值和字符串相加都会转换成字符串再进行拼串</p>
<p>数字 + <code>NaN</code> = <code>NaN</code> / 数字 + <code>null</code> = 0</p>
</blockquote>
</li>
<li><p><code>-</code>:减法 <code>*</code>:乘法 <code>/</code>:除法 <code>%</code>:取模</p>
<blockquote>
<p>String 会转换为 Number 再进行计算</p>
</blockquote>
</li>
</ol>
</li>
<li><p>一元运算符</p>
<p><code>+</code>正号 <code>-</code>负号(取反)</p>
</li>
<li><p>自增 / 自减</p>
<ol>
<li><p><code>++</code>: 原变量会立刻在原来得基础上自增 1</p>
<ul>
<li><p>自增分两种<code>i++</code> / <code>++i</code></p>
<blockquote>
<p>无论哪种都会立即使 原变量 +1</p>
<p>不同的是表达式 <code>i++</code>显示原值 <code>++i</code>显示+值</p>
</blockquote>
</li>
<li><p>自减分两种<code>i--</code> / <code>--i</code></p>
<blockquote>
<p>无论哪种都会立即使 原变量 -1</p>
<p>不同的是表达式<code>i--</code>显示原值 <code>--i</code>显示-值</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ol>
<li><p><code>!</code>非: 布尔值取反</p>
</li>
<li><p><code>&amp;&amp;</code>与: 两边都满足</p>
<blockquote>
<p>如果第一个值为<code>false</code>则不会检查第二个值</p>
</blockquote>
</li>
<li><p><code>||</code>或: 两边只需要满足一边</p>
<blockquote>
<p>如果第一个值为<code>true</code>则不会检查第二个值</p>
<p><code>var a = a||0</code> 设置默认值</p>
</blockquote>
</li>
<li><p>非布尔值运算:</p>
<p><code></code>&amp;&amp;<code>: 优先返回</code>false`</p>
<p><code>||</code>: 优先返回<code>true</code></p>
</li>
</ol>
<h2 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h2><ol>
<li><p><code>=</code>赋值: 将等号右边的<strong>原始值</strong>或<strong>引用地址</strong>赋值给左边的变量</p>
</li>
<li><p><code>==</code>相等运算: 对于非数值情况 会先转换成数字 然后再比较</p>
<blockquote>
<p>任何值和<code>NaN</code>比较都是<code>false</code></p>
<p>如果符号两边都是字符串则不会转换数字, 直接比较<code>unicode编码</code></p>
<p><code>!=</code>: 不全等运算, 会转换成同一数据类型再比较</p>
</blockquote>
</li>
<li><p><code>===</code>全等: 先比较类型, 如果类型不同直接返回<code>false</code></p>
<blockquote>
<p><strong>注意</strong>: 比较时需要注意数据是字符串数字还是数值</p>
<p><code>!==</code>: 全不等, 如果数据类型相同直接返回 false</p>
</blockquote>
</li>
<li><p><code>+=</code>加等: <code>a += b</code> 等同于 <code>a = a + b</code></p>
</li>
</ol>
<h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>条件运算符也叫三元运算符</p>
<blockquote>
<p><code>条件表达式 ? 语句1 : 语句2</code></p>
</blockquote>
<ul>
<li>执行流程:<ol>
<li>条件运算符在执行时, 首先对条件表达式求值</li>
<li>如果为<code>true</code>执行<code>语句1</code>返回结果</li>
<li>如果为<code>false</code>执行<code>语句2</code>返回结果</li>
</ol>
</li>
</ul>
<p><code>,</code>运算符 可以分割多个语句, 一般可以在声明多个变量时使用</p>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><ul>
<li><p>流程控制语句分类</p>
<ol>
<li>条件判断语句</li>
<li>.条件分支语句</li>
<li>循环语句</li>
</ol>
</li>
<li><p><strong>条件判断语句</strong></p>
<ul>
<li><p>使用条件判断语句可以在执行某个语句前进行判断</p>
</li>
<li><p>如果条件成立才会执行语句, 条件不成立则不执行</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">	语句...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">	语句...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">	语句...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	语句...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>该语句从上到下依次对条件表达式求值判断</li>
<li>如果为<code>true</code>则执行当前语句</li>
<li>如果为<code>false</code>则继续向下判断</li>
<li>该语句中<strong>只有一个</strong>代码块会被执行</li>
<li>一旦代码块执行了则直接结束语句, 不会向下判断</li>
</ol>
</li>
<li><p>条件分支语句</p>
<blockquote>
<p>也叫 switch 语句</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (条件表达式) &#123;</span><br><span class="line">	<span class="keyword">case</span> 表达式:</span><br><span class="line">	语句...</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 表达式:</span><br><span class="line">	语句...</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	语句...</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在执行时会依次将<code>switch</code>的条件表达式的值和<code>case</code>的表达式值进行<strong>全等</strong>比较</li>
<li>如果结果为<code>true</code>则执行该<code>case</code>后面的语句</li>
<li>如果结果为<code>false</code>则继续向下比较</li>
<li>如果所有结果都为<code>false</code>则执行<code>default</code>后的语句</li>
</ol>
</li>
<li><p>循环语句</p>
<ul>
<li><p>while 循环</p>
<blockquote>
<p>通过循环语句可以反复的执行一段代码多次</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件表达式) &#123;</span><br><span class="line">	语句...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>while</code>语句在执行时先对条件表达式求值判断</p>
</li>
<li><p>如果结果为<code>true</code>则执行语句</p>
</li>
<li><p>执行完毕后再次回到判断</p>
</li>
<li><p>当结果为<code>false</code>则终止循环</p>
</li>
<li><p>可以用<code>break</code>来终止循环</p>
<blockquote>
<p>1.初始化一个变量<code>var i=0</code></p>
<p>2.在循环中设置一个条件表达式<code>i&lt;10</code></p>
<p>3.定义一个表达式更新<code>i++</code></p>
</blockquote>
</li>
</ol>
</li>
<li><p>do…while 循环</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	语句...</span><br><span class="line">&#125; <span class="keyword">while</span> (条件表达式);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>区别: <code>while</code>先判断后执行<code>do...while</code>先执行后判断, 至少执行一次</p>
</blockquote>
</li>
<li><p><strong>for 循环</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化表达式; 条件表达式; 更新表达式) &#123;</span><br><span class="line">	语句...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>初始化表达式</p>
</li>
<li><p>执行条件表达式判断</p>
<blockquote>
<p>每次执行会重新计算然后判断里面的值 所以为了追求性能 应将计算放到初始化表达式中去)</p>
</blockquote>
</li>
<li><p>如果为 true 执行语句</p>
</li>
<li><p>如果为 false 终止循环</p>
</li>
<li><p>更新表达式 回到第二部 再次判断 执行</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h2><ol>
<li><code>break</code>关键字可以用来<strong>退出整个</strong><code>switch</code>或循环</li>
<li><code>if</code>语句<strong>不能</strong>使用<code>break</code>和<code>continue</code></li>
<li><p><code>break</code>关键字会立即终止离他<strong>最近</strong>的那个循环语句</p>
</li>
<li><p>可以为循环语句创建一个<code>label</code>来标识当前的循环</p>
<blockquote>
<p>语法: <code>label名</code> <code>:</code> 循环语句</p>
<pre><code>`break`  `label名`;
</code></pre></blockquote>
</li>
<li><p><code>continue</code>关键字可以用来<strong>跳过当次</strong>循环, 只对<strong>最近</strong>循环起作用</p>
</li>
<li><p><code>continue</code>要写在代码语句之前才能起作用</p>
<blockquote>
<p>耗时测试 <code>console.time(&#39;txt&#39;)</code> + <code>console.timeEnd(&#39;txt&#39;)</code></p>
</blockquote>
</li>
</ol>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><blockquote>
<p>对象是一种复合的数据类型, 在对象中可以保存多个不同数据类型的属性</p>
</blockquote>
<ul>
<li><p>对象的分类</p>
<ol>
<li><p>内建对象: 由 ES 标准中定义的对象,在任何的 ES 的实现中都可以使用</p>
<blockquote>
<p>例如: Array Function Object …</p>
</blockquote>
</li>
<li><p>宿主对象: 由 JS 的运行坏境提供的对象, 目前来讲主要指由浏览器提供的对象</p>
<blockquote>
<p>例如: BOM 浏览器对象模型 DOM 文档对象模型</p>
</blockquote>
</li>
<li><p>自定义对象: 由开发人员自己创建的对象</p>
</li>
</ol>
</li>
<li><p>创建对象</p>
<ol>
<li><code>var obj = new Object()</code></li>
<li>使用 new 关键字调用的函数是构造函数</li>
<li>构造函数是专门用来创建实例对象的函数</li>
</ol>
</li>
<li><p>属性: 在对象中保存的值称为属性</p>
<ol>
<li><p>向对象中添加属性</p>
<blockquote>
<p>对象.属性名 = 属性值</p>
</blockquote>
</li>
<li><p>读取对象中的属性</p>
<blockquote>
<p>对象.属性名</p>
</blockquote>
</li>
<li><p>删除对象的属性</p>
<blockquote>
<p>delete 对象.属性名</p>
</blockquote>
</li>
</ol>
</li>
<li><p>属性名</p>
<p>读取变量属性名或者特殊属性名</p>
<blockquote>
<p>对象[属性名] = 属性值</p>
</blockquote>
</li>
<li><p>属性值</p>
<blockquote>
<p>JS 对象的属性值 可以是任意数据类型</p>
</blockquote>
<ol>
<li><p><code>in</code>运算符可以检查一个对象中是否含有指定属性(包括原型上的属性)</p>
<blockquote>
<p>只检查自身使用<code>hasOwnProperty</code></p>
</blockquote>
</li>
<li><p>“属性名” <code>in</code> 对象</p>
</li>
<li><p>有则返回<code>true</code>没有则返回<code>false</code></p>
</li>
</ol>
</li>
<li><p>引用数据类型</p>
<ol>
<li>基本数据类型保存在<strong>栈内存</strong>中,变量的值直接保存<strong>相互独立</strong></li>
<li>引用数据类型保存在<strong>堆内存</strong>中, 对象的值是保存的对象的**内存地址</li>
<li>如果两个保存的是同一个对象引用, 通过一个变量修改属性时另一个也会受到影响</li>
<li>引用数据类型比较值的时候它是比较的对象的内存地址</li>
</ol>
</li>
<li><p>对象字面量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	属性名: 属性值,</span><br><span class="line">	属性名: 属性值...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数也是一个对象, 用于提高相同代码(功能)可复用性</p>
<p>函数中可以封装一些功能 在需要时调用 可以执行这些功能</p>
<blockquote>
<p><code>fun</code>表示函数对象本身, <code>fun()</code>表示函数执行后的返回值</p>
<p>如果函数没有<code>return</code>返回值默认<code>undefiend</code></p>
</blockquote>
<ul>
<li><p>创建函数</p>
<ol>
<li><code>var fun = new Function()</code></li>
<li>可以将要封装的代码以字符串的形式传递给构造函数</li>
<li>封装的代码不会立即执行</li>
<li>函数中的代码会在函数被调用时执行</li>
<li>调用语法: <code>函数名()</code></li>
<li>当函数被调用时, 函数中封装的代码会按顺序依次执行</li>
</ol>
</li>
<li><p>函数声明: 一般使用这种方式来创建函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">形参<span class="number">1</span>, 形参<span class="number">2</span>, ...</span>) </span>&#123;</span><br><span class="line">	语句...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 函数名 = <span class="function"><span class="keyword">function</span>(<span class="params">形参<span class="number">1</span>, 形参<span class="number">2</span>, ...</span>) </span>&#123;</span><br><span class="line">	语句...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>形参(形式参数)</p>
<ol>
<li>多个形参用 , 分割</li>
<li>声明形参就相当于在函数内部声明了对应的变量, 但并不赋值</li>
</ol>
</li>
<li><p>实参(实际参数)</p>
<ol>
<li><p>在调用函数时在<code>()</code>中指定实参, 相当于把实参的值赋值给形参</p>
</li>
<li><p>调用函数时解析器不会检查实参的数据类型和数量</p>
<blockquote>
<p>有可能会接收到非法参数, 需要对参数的数据类型进行检查</p>
</blockquote>
</li>
<li><p>如果实参的数量少于形参,则没有对应实参的形参的值是 undefined</p>
</li>
<li><p>实参可以是任意数据类型,也可以是对象或者函数</p>
</li>
<li><p>当我们的参数过多时,可以将参数封装到一个对象中,然后通过对象传递</p>
</li>
</ol>
</li>
<li><p>函数返回值</p>
<ol>
<li>使用<code>return</code>来设置函数的返回值</li>
<li><code>return</code>后的值,将作为函数执行后的结果</li>
<li><code>return</code>返回值后结束整个函数, 之后的语句都不会执行</li>
<li>如果不写<code>return</code>或者<code>return</code>后没有值则返回<code>undefined</code></li>
<li>调用函数<code>函数名()</code>相当于使用函数的返回值, <code>函数名</code>相当于使用函数对象</li>
</ol>
</li>
<li><p>立即执行函数 (IIFE)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'这是一个匿名函数自调用'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<ol>
<li>整个函数加上括号表示一个整体代码才能正确识别</li>
<li>最后加一个<code>()</code>表示立即调用该函数</li>
<li>作用: 隐藏实现, 不会污染全局命名空间, 函数执行完后会立即销毁函数及里面的内容</li>
<li>JS 模块化的基础</li>
</ol>
</li>
<li><p>回调函数</p>
<blockquote>
<p>由开发者定义,但没有调用 (在满足某些条件后)最终执行了的函数 就是回调函数</p>
</blockquote>
<ol>
<li>DOM 事件回调函数</li>
<li>定时器回调函数</li>
<li>AJAX 请求回调函数</li>
<li>生命周期回调函数</li>
</ol>
</li>
<li><p>递归调用</p>
<ol>
<li>在函数内部自己调用自己就是递归调用</li>
<li>递归调用首先要设置递归条件和<code>retrun</code>条件</li>
<li>否则这个函数将成为一个死循环</li>
</ol>
</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li><p>方法</p>
<ol>
<li><p>对象的属性可以是任何数据类型, 也可以是函数</p>
</li>
<li><p>如果一个函数作为一个对象的属性保存, 那么我们称这个函数是这个对象的方法</p>
</li>
<li><p>调用函数就说调用对象的方法</p>
<blockquote>
<p>但是他们只是叫法上的区别, 本质没变</p>
</blockquote>
</li>
</ol>
</li>
<li><p>枚举对象中的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  obj[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>for ... in</code>语句对象中有几个属性, 循环就会执行几次</p>
<blockquote>
<p>包括原型上的属性和方法</p>
</blockquote>
</li>
<li><p>每次会把对象的属性名赋值给变量</p>
</li>
<li><p>提取对象信息: 因为属性名是赋值给了变量所以提取属性信息必须用 <code>obj[key]</code></p>
</li>
</ol>
</li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域用来隔离变量, 不同作用域下的同名变量不会冲突</p>
<p>作用域的范围是<strong>在编写代码时确定</strong>, 并非在函数执行时确定</p>
<blockquote>
<p>调用函数是直接在函数原来的作用域里执行, 并非将函数复制到调用的作用域里执行</p>
</blockquote>
<ul>
<li><p>全局作用域</p>
<ol>
<li>直接编写在<code>script</code>标签中的 JS 代码都在全局作用域中</li>
<li>全局作用域在页面打开时创建,页面关闭时销毁</li>
<li>在全局作用域中有一个全局对象<code>window</code>我们可以直接使用</li>
<li>它代表我们浏览器的窗口,由浏览器创建</li>
<li>我们创建的变量都会作为<code>window</code>对象的属性保存</li>
<li>我们创建的函数都会作为<code>window</code>对象的方法保存</li>
<li>全局作用域中的变量都是全局变量, 在页面任意部分都可以访问到</li>
</ol>
</li>
<li><p>函数作用域</p>
<ol>
<li><p>调用函数时函数作用域创建, 函数执行完毕后函数作用域销毁</p>
<blockquote>
<p>闭包时不会销毁</p>
</blockquote>
</li>
<li><p>每调用一次函数就会创建一个新的函数作用域 他们是相互独立的</p>
</li>
<li><p>在函数作用域中可以访问到全局作用域的变量</p>
</li>
<li><p>在全局作用域中无法访问到函数作用域的变量</p>
</li>
<li><p>当在函数作用域中操作一个变量时会先在自身作用域中寻找,如果没有则向上一级作用域中寻找</p>
</li>
<li><p>如果全局作用域中依然没有找到 则会报错<code>ReferenceError</code></p>
</li>
<li><p>在函数中想要访问全局中的同名变量可以借用<code>window</code>对象</p>
</li>
<li><p>函数作用域中, 函数也会声明提前</p>
</li>
<li><p>在函数中不使用<code>var</code>声明的变量 都是全局变量</p>
</li>
<li><p>定义形参就相当于在函数中声明了一个变量</p>
</li>
</ol>
</li>
</ul>
<h2 id="声明提前"><a href="#声明提前" class="headerlink" title="声明提前"></a>声明提前</h2><ul>
<li><p>浏览器加载</p>
<ol>
<li><p>浏览器在加载一个页面时,时按照自上向下的顺序加载的</p>
</li>
<li><p>读取到一行就运行一行, 需要注意代码顺序和 JS 代码的位置</p>
</li>
<li><p>全局里的所有<code>var</code>和<code>function ()</code>都会提升到顶部执行</p>
</li>
<li><p>如果声明时没有使用<code>var</code>关键字, 则不会被提前</p>
<blockquote>
<p>变量提前 &gt; 函数提前</p>
<p>函数表达式<code>var</code>只会提前声明变量, 函数不会提前所以不能在声明前调用函数</p>
</blockquote>
</li>
</ol>
</li>
<li><p>全局执行上下文</p>
<ol>
<li>在执行全局代码前将<code>window</code>确定为全局执行上下文对象</li>
<li>对全局数据进行预处理</li>
<li><code>var</code>定义的全局变量值设置为<code>undefined</code>并将其添加为<code>window</code>的属性</li>
<li><code>function</code>声明的全局函数赋值, 并将其添加为<code>window</code>的方法</li>
<li><code>this</code>指向<code>window</code></li>
<li>开始执行全局代码</li>
</ol>
</li>
<li><p>函数执行上下文</p>
<ol>
<li>每当调用函数时, 准备执行函数体前, 创建对应的函数执行上下文对象</li>
<li>将实参值赋值给形参, 并将其添加为执行上下文对象的属性</li>
<li><code>arguments</code>赋值实参列表, 并将其添加为执行上下文对象的属性</li>
<li><code>var</code>定义的局部变量值设置为<code>undefined</code>并将其添加为执行上下文对象的属性</li>
<li><code>function</code>声明的函数, 并将其添加为执行上下文对象的方法</li>
<li><code>this</code>指向调用函数的对象</li>
</ol>
</li>
<li><p>执行上下文栈</p>
<ol>
<li>栈:像一个”柱”状 容器, 先放进去的执行上下文对象在下面后进去的在上面</li>
<li>只能操作在最上面的上下文对象, 在上面的执行上下文对象先执行先销毁</li>
<li>全局执行上下文对象<code>window</code>永远在最下面</li>
</ol>
</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li><p>闭包 Closure</p>
<ol>
<li>当一个嵌套的<code>内部函数</code>引用了嵌套的<code>外部函数</code>的变量或函数时就会产生闭包</li>
<li>闭包产生在外部函数<strong>调用时</strong>且内部函数已定义, 跟内部函数是否调用无关</li>
<li>在没有变量引用闭包的函数时闭包销毁</li>
</ol>
</li>
<li><p>闭包的作用</p>
<ol>
<li><p>使外部函数的变量在函数执行完后,仍保存在内存中</p>
<blockquote>
<p>延长局部变量的生命周期</p>
</blockquote>
</li>
<li><p>在函数外面可以操作到函数内部的数据 (变量/函数)</p>
</li>
</ol>
</li>
<li><p>JS 模块</p>
<ol>
<li>JS 模块就是具有特定功能的 JS 文件</li>
<li>将所有的数据和功能都封装在一个函数内部(私有的)</li>
<li>只向外暴露<code>return</code>一个包含 n 个方法的对象或函数</li>
<li>模块的使用者就可以通过模块暴露的对象来调用方法实现对应功能</li>
</ol>
<blockquote>
<p>将数据或功能写在<code>IIFE</code>中, 为暴露对象添加属性或方法, 并将向外暴露的对象设置为<code>window</code>的属性</p>
</blockquote>
</li>
<li><p>闭包的缺点</p>
<ol>
<li><p>函数执行完毕后, 函数内部的局部变量没有释放, 占用内存</p>
</li>
<li><p>容易造成内存泄漏</p>
<blockquote>
<p>解决: 及时释放 (将不再使用的函数引用赋值<code>null</code>)</p>
</blockquote>
</li>
</ol>
<ul>
<li>内存溢出: 当程序运行需要的内存超过剩余内存时就会抛出内存溢出的错误</li>
<li>内存泄露: 占用的内存没有及时释放,积少成多后容易导致内存溢出</li>
<li>常见的内存泄漏:<ol>
<li>意外的全局变量</li>
<li>没有及时清理的计时器或回调函数</li>
<li>闭包</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>解析器在每次调用函数时都会传递一个隐含的参数<code>this</code></p>
<p><code>this</code>会指向调用函数的对象</p>
<p>根据函数调用方式的不同<code>this</code>会指向不同的对象</p>
<ol>
<li>以函数的形式调用<code>this</code>(或未指定调用对象)则指向<code>window</code></li>
<li>以方法的形式调用<code>this</code>则指向调用的对象</li>
<li>DOM 事件回调函数中的<code>this</code>一般指向 DOM 元素</li>
<li>其他回调函数中的<code>this</code>一般指向<code>window</code></li>
<li>当以构造函数调用时, <code>this</code>则是构造函数中新建的对象</li>
<li>以<code>call(调用对象,函数形参1,形参2,...)</code>和<code>apply(调用对象,形参数组)</code>方法调用时<code>this</code>是指定的那个对象</li>
</ol>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数是专门用来创建某种类型的对象的函数</p>
<p>构造函数就是一个普通的函数, 创建方式和普通函数没有区别</p>
<p>构造函数首字母大写</p>
<ul>
<li><p>构造函数和普通函数的区别是调用方式的不同</p>
<blockquote>
<p>普通函数是直接调用</p>
<p>构造函数需要使用<code>new</code>关键字来调用</p>
</blockquote>
</li>
<li><p>构造函数的执行流程</p>
<ol>
<li><p><code>new</code>立刻在堆内存创建一个新对象</p>
</li>
<li><p>将新建的对象设置为函数中的<code>this</code></p>
<blockquote>
<p>用 this 来选择新建的对象</p>
</blockquote>
</li>
<li><p>逐行执行函数中的代码</p>
</li>
<li><p>将新建对象返回</p>
</li>
</ol>
</li>
<li><p>类</p>
<ol>
<li><p>使用同一个构造函数创建的对象我们称为一类对象, 也将这个构造函数称为一个类</p>
</li>
<li><p>我们将通过一个构造函数创建的对象称为是该类的实例</p>
</li>
<li><p>使用<code>instanceof</code>可以检查一个对象是否是某一个类的实例</p>
</li>
<li><p>所有的对象都是<code>Object</code>的实例, 用<code>instanceof</code>检查返回<code>true</code></p>
<blockquote>
<p>Object.prototype 除外</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>我们所创建的每一个函数, 解析器都会向函数中添加一个属性<code>prototype</code><strong>显式原型</strong></p>
<p>这个属性对应着一个 Object 对象, 这个对象就是原型对象</p>
<blockquote>
<p>原型对象中有个<code>constructor</code>属性指向该对象的构造函数</p>
</blockquote>
<p>如果作为普通函数调用<code>prototype</code>没有任何作用</p>
<p>当函数以构造函数的形式调用时, 它所创建的实例对象中都会有一个隐含的属性</p>
<p>该属性指向该构造函数的原型对象, 我们可以通过<code>__proto__</code><strong>隐式原型</strong>来访问该属性</p>
<ul>
<li>原型链<ol>
<li>当我们访问对象的一个属性或方法时, 他会现在对象自身中寻找</li>
<li>如果有则直接使用, 如果没有则会去原型对象中寻找</li>
<li>原型对象也是对象,所以它也有原型</li>
<li>所以如果原型中没有找到, 则去原型的原型中寻找 (也就是 Object 对象的原型)</li>
<li><code>Object.prototype.__proto__</code>的值是<code>null</code>它是原型链的尽头</li>
</ol>
</li>
</ul>
<blockquote>
<p>使用<code>in</code>检查对象中是否含有某个属性时, 如果对象中没有, 原型中有也会返回<code>true</code></p>
<p>使用<code>对象.hasOwnProperty(&quot;属性名&quot;)</code>来检查对象自身中是否含有该属性</p>
</blockquote>
<blockquote>
<p>所有函数(主要是构造函数)都有显示原型</p>
<p>所有对象(包括函数, 数组)都有隐式原型</p>
<p>函数实例的隐式原型 <strong>等于</strong> 构造函数的显示原型</p>
</blockquote>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li><p>原型继承</p>
<ol>
<li>构造函数的实例对象自动拥有构造函数原型对象的属性和方法 (利用原型链继承)</li>
<li>当修改对象属性的常规值的时候就是修改属性名对应的值本身</li>
<li>对象重新赋值相当于修改变量名/属性名保存的引用地址</li>
</ol>
</li>
<li><p>原型链继承 (为了继承父类型的方法)</p>
<ol>
<li>定义父类型构造函数</li>
<li>给父类型的原型添加方法</li>
<li>定义子类型构造函数</li>
<li><strong>关键:</strong> 创建父类型的实例对象赋值给子类型的原型对象</li>
<li>将子类型原型的构造<code>constructor</code>属性修正为子类型函数</li>
<li>给子类型添加方法</li>
<li>创建子类型的实例 (可以调用父类型的方法)</li>
</ol>
</li>
<li><p>借用构造函数继承 (假借, 为了构建相同属性)</p>
<ol>
<li>定义父类型构造函数</li>
<li>定义子类型构造函数</li>
<li>在子类型构造函数中通过<code>Fun.call(this, a, b)</code>调用父类型构造函数</li>
</ol>
</li>
<li><p>组合继承</p>
<ol>
<li>利用原型链实现对父类型对象的方法继承</li>
<li>利用<code>call()</code>方法假借父类型构建函数初始化相同属性</li>
</ol>
</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组也是一个对象 (内建对象)</p>
<p>他和我们普通对象功能类似, 也是用来储存一些值的</p>
<p>不同的是普通对象是使用字符串作为属性名, 且无序</p>
<p>而数组是使用数字作为索引来操作元素, 有序</p>
<ul>
<li><p>索引: 0 开始的整数</p>
<blockquote>
<p>数组的储存性能要比普通对象好, 在开发中我们经常使用数组来储存一些数据</p>
</blockquote>
</li>
<li><p>添加/修改元素: 数组名[索引] = 值</p>
</li>
<li><p>获取数组长度:</p>
<blockquote>
<p>使用数组的<code>length</code>方法</p>
<p>语法: <code>数组.length</code></p>
<p>会获取到数组最大索引 +1</p>
</blockquote>
</li>
<li><p>设置数组长度:</p>
<blockquote>
<p>语法: <code>数组.length = 值</code></p>
<p>如果大于原长度, 多出的值会空出来</p>
<p>如果小于原长度, 多出的值会被删除</p>
</blockquote>
</li>
<li><p>向数组最后一个位置添加元素: <code>数组名[数组名.length] = 值</code></p>
</li>
<li><p>字面量创建数组: <code>var 数组名 = [值, 值, 值...]</code></p>
</li>
<li><p>使用构造函数创建数组: <code>var 数组名 = new Array(值, 值, 值...)</code></p>
<blockquote>
<p>使用这种方法如果只传一个整数值则表示创建一个长度为 n 的空数组</p>
</blockquote>
</li>
<li><p>数组方法</p>
<ul>
<li><p><code>push()</code></p>
<ol>
<li>该法方法可以向数组的<strong>末尾添加</strong>一个或多个元素, 并返回新数组的长度</li>
<li>将要添加的元素作为参数传递, 这样这些元素会自动添加到数组末尾</li>
<li>该方法会将数组的<strong>新长度</strong>作为返回值返回</li>
</ol>
</li>
<li><p><code>pop()</code></p>
<ol>
<li>该方法可以立即删除数组中的<strong>最后</strong>一个元素</li>
<li>该方法的返回值是<strong>删除的那个元素</strong></li>
</ol>
</li>
<li><p><code>unshift()</code></p>
<ol>
<li>向数组的<strong>开头添加</strong>一个或多个元素, 并返回新的长度</li>
<li>向最前面插入元素, 其他元素的<strong>索引会依次调整</strong></li>
</ol>
</li>
<li><p><code>shift()</code></p>
<ol>
<li>删除数组<strong>第一个</strong>元素, 并将删除的元素作为返回值返回</li>
</ol>
</li>
<li><p><code>slice()</code></p>
<ol>
<li>可以用来从数组中提取出指定元素</li>
<li>该方法<strong>不会影响原数组</strong>, 会将<strong>截取到的数组返回</strong></li>
<li>语法: <code>数组名.slice(参数1, 参数2)</code></li>
<li>参数:<ol>
<li>截取开始位置索引<strong>(包含)</strong></li>
<li>截取结束位置索引<strong>(不包含,省略则是到末尾)</strong></li>
</ol>
</li>
<li>参数可以传递负值,如果传递一个负数则从后往前计算 (-1 倒数第一个元素)</li>
</ol>
</li>
<li><p><code>splice()</code></p>
<ol>
<li>可以用来替换/删除/添加数组中的指定元素</li>
<li>使用<code>splice()</code>会<strong>影响原数组</strong></li>
<li>它会将指定元素从原数组中删除, 并将被<strong>删除的元素</strong>作为返回值返回</li>
<li>语法: <code>数组名.splice(参数1, 参数2, 参数3...)</code></li>
<li>参数:<ol>
<li>表示开始位置的索引<strong>(包含)</strong></li>
<li>表示删除元素的数量</li>
<li>可以传递一些新元素,这些元素会插入到开始位置索引的 前面</li>
</ol>
</li>
</ol>
</li>
<li><p><code>concat()</code></p>
<ol>
<li>可以拼接多个数组, 并将新的数组返回</li>
<li>该方法不会对原数组产生影响</li>
<li>语法: <code>var arr = arr1.concat(arr2,arr3...)</code></li>
</ol>
</li>
<li><p><code>join()</code></p>
<ol>
<li>该方法可以将数组转换成一个字符串</li>
<li>该方法不会对原数组产生影响, 而是将转换后的字符串作为结果返回</li>
<li>在<code>join()</code>中可以指定一个字符串作为参数, 这个字符串将会称为数组中元素的连接符(默认 ,)</li>
<li>语法: <code>var str = arr.join(&quot;连接符&quot;)</code></li>
</ol>
</li>
<li><p><code>reverse()</code> 该方法用来反转数组,该方法会直接修改原数组</p>
</li>
<li><p><code>sort()</code></p>
<ol>
<li>可以用来对数组元素按<code>unicode编码</code>进行排序, 它也<strong>直接修改原数组</strong></li>
<li>我们可以自己指定排序规则在<code>sort()</code>添加一个回调函数, 来指定排序规则</li>
<li>回调函数中需要定义两个形参</li>
<li>浏览器会分别使用数组中的元素作为实参去调用回调函数</li>
<li>使用那个元素调用不确定, 但可以肯定 数组中的<code>a</code>一定在<code>b</code>之前</li>
<li>浏览器会根据回调函数的返回值决定元素的顺序</li>
<li>返回值<strong>大于 0 元素交换位置</strong>, 小于 0 则不换位, 等于 0 认为两个元素相等依然不变</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b <span class="comment">//升序</span></span><br><span class="line">  <span class="keyword">return</span> b - a <span class="comment">//降序</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>filter()</code></p>
<ol>
<li><code>filter</code>使用数组中的每个元素去调用<code>callback</code>函数</li>
<li>如果<code>callback</code>返回<code>true</code>则将该元素添加到新数组里面</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArray = arr.filter(callback(element, index, arr))</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>forEach()</code></p>
<blockquote>
<p>IE 8 及以下不支持</p>
</blockquote>
<ol>
<li>方法遍历数组需要一个函数作为参数</li>
<li>数组中有几个元素则调用函数几次</li>
<li>每次执行浏览器会将遍历到的元素以实参形式传递进函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组名.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">元素值, 索引, 数组本身</span>) </span>&#123;</span><br><span class="line">	操作语句...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="函数的方法"><a href="#函数的方法" class="headerlink" title="函数的方法"></a>函数的方法</h2><ul>
<li><p><code>call()</code>和<code>apply()</code></p>
<ol>
<li>这两个方法都是函数对象的方法, 需要通过<strong>函数对象</strong>来调用</li>
<li>当对函数调用<code>call()</code>和<code>apply()</code>方法时都会执行函数</li>
<li>在调用<code>call()</code>和<code>apply()</code>时可以将一个对象指定为第一个参数</li>
<li>此时这个对象将会成为函数执行时的`this</li>
<li><code>call()</code>方法实参在对象之后依次传递</li>
<li><code>apply()</code>方法需要将实参封装到一个数组里</li>
</ol>
</li>
<li><p><code>arguments</code></p>
<ol>
<li><p>在调用函数时,浏览器每次都会传递进两个隐含的参数:</p>
<ul>
<li><p>函数的上下文对象<code>this</code></p>
</li>
<li><p>封装实参的对象<code>arguments</code></p>
</li>
</ul>
</li>
<li><p><code>arguments</code>是一个<strong>伪数组</strong>对象, 它也可以通过索引来操作数据, 也可以获取长度</p>
</li>
<li>在函数调用时我们所传递的实参都会在<code>arguments</code>中保存</li>
<li><code>arguments.length</code>可以用来获取传入实参的数量</li>
<li>我们即使不定义形参, 我们也可以通过<code>arguments[i]</code>来使用实参</li>
<li>它里面有一个属性叫<code>callee</code>这个属性对应一个函数对象, 就是当前这个函数本身</li>
</ol>
</li>
</ul>
<h2 id="时间对象"><a href="#时间对象" class="headerlink" title="时间对象"></a>时间对象</h2><ul>
<li><p>创建一个 Date 对象</p>
<ol>
<li>直接使用构造函数创建一个 Date 对象,则会封装当前执行代码的时间</li>
<li>语法: <code>var d = new Date()</code></li>
</ol>
</li>
<li><p>创建一个指定的时间对象</p>
<ol>
<li>需要在构造函数中传递一个表示时间的字符串作为参数</li>
<li>日期格式<code>&quot; 月份 / 日 / 年 时 : 分 : 秒 &quot;</code></li>
</ol>
</li>
<li><p>相关方法</p>
<ol>
<li><code>getDate()</code> 获取当前日期对象是几号</li>
<li><code>getDay()</code> 获取当前日期对象是周几 (0 表示周日)</li>
<li><code>getMonth()</code> 获取当前日期对象的月份 (返回值 0 - 11)</li>
<li><code>getFullYear()</code> 获取当前日期对象的年份</li>
<li><code>getTime()</code> 获取当前日期对象的时间戳<ol>
<li>时间戳是指格林威治标准时间到当前时间经过的毫秒数</li>
<li>计算机底层在保存时间使用的都是时间戳</li>
<li>获取当前代码执行时的时间戳 <code>var time = Date.now()</code></li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h2><p>Math 和其他对象不同, 它不是一个构造函数</p>
<p>它属于一个工具类不用创建对象, 它里面封装了数学运算相关的属性和方法</p>
<ol>
<li><p><code>Math.PI</code> 圆周率 (全大写表示常量)</p>
</li>
<li><p><code>Math.abs()</code> 求绝对值</p>
</li>
<li><p><code>Math.ceil()</code> 向上取整</p>
</li>
<li><p><code>Math.floor()</code> 向下取整</p>
</li>
<li><p><code>Math.round()</code> 四舍五入</p>
</li>
<li><p><code>Math.random()</code> 生成一个 0-1 之间的随机数</p>
<blockquote>
<p>Math.floor(Math.random()*10) 0-9 之间的整数</p>
</blockquote>
</li>
<li><p><code>Math.max()</code> 返回值是传入参数中的最大值</p>
</li>
<li><p><code>Math.min()</code> 返回值是传入参数中的最小值</p>
</li>
<li><p><code>Math.pow(x,y)</code> 返回 x 的 y 次幂</p>
</li>
<li><p><code>Math.sqrt()</code> 返回值是参数的开方</p>
</li>
</ol>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>在 JS 中为我们提供了三个包装类,通过这三个包装类可以将基本数据类型转换为对象</p>
<ol>
<li><code>String()</code> 可以将一个基本数据类型的字符串转换为 String 对象</li>
<li><code>Number()</code> 可以将一个基本数据类型的数字转换为 Number 对象</li>
<li><code>Boolean()</code> 可以将一个基本数据类型的布尔值转换为 Boolean 对象</li>
</ol>
<p>但是在实际应用中 我们不会使用基本数据类型的对象</p>
<p>如果使用会带来一些不可预期的结果</p>
<p>方法和属性只能添加给对象, 不能添加给基本数据类型</p>
<p>当我们对一些基本数据类型的值去调用属性或方法时</p>
<p>浏览器会临时使用包装类将其转换为对象, 然后去它的原型上寻找对应的方法</p>
<h2 id="字符串的方法"><a href="#字符串的方法" class="headerlink" title="字符串的方法"></a>字符串的方法</h2><blockquote>
<p>系统底层字符串是以字符数组形式保存的</p>
</blockquote>
<ul>
<li><p><code>length</code>属性 获取字符串长度 (属性不用加括号)</p>
</li>
<li><p><code>charCodeAt()</code> 获取指定位置字符的 Unicode 编码</p>
</li>
<li><p><code>concat()</code> 连接一个或多个字符串</p>
</li>
<li><p><code>indexOf(&quot;查找内容&quot;, 查找起始位置索引)</code></p>
<ol>
<li>检索一个字符串里是否有指定内容</li>
<li>如果字符串中含有该内容则返回该内容第一次出现的位置的索引</li>
<li>如果<strong>没有则返回 -1</strong></li>
</ol>
<blockquote>
<p><code>lastIndexOf()</code> 同上, 反向查找</p>
</blockquote>
</li>
<li><p><code>slice(包括起始位置,不包括结束位置)</code></p>
<blockquote>
<p>可以从字符串中截取指定内容, 负数表示倒数</p>
</blockquote>
</li>
<li><p><code>substr(包括起始位置,截取数量)</code></p>
<blockquote>
<p>截取字符串,该方法 ES 中没有定义,但是所有浏览器都支持</p>
</blockquote>
</li>
<li><p><code>split(分割字符串)</code></p>
<ol>
<li>根据分割字符串把一个字符串拆分成一个数组</li>
<li>如果传递一个空串 则将字符串中的每一个字符都拆分成一个元素</li>
</ol>
</li>
<li><p><code>toUpperCase()</code> 转换大写</p>
</li>
<li><p><code>toLowerCase()</code> 转换小写</p>
</li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式用于定义一些字符串的规则</p>
<p>计算机可以根据正则表达式 来检查一个字符串是否符合规则</p>
<p>或者将字符串中符合规则的内容提取出来</p>
<ul>
<li><p>创建正则表达式的对象</p>
<blockquote>
<p><code>var 变量名 = new RegExp(&quot;正则表达式&quot;,匹配模式)</code></p>
</blockquote>
</li>
<li><p><code>test()</code>用于检查一个字符串是否符合正则表达式规则</p>
<blockquote>
<p>符合返回<code>true</code> 不符合返回<code>false</code></p>
</blockquote>
</li>
<li><p>匹配模式</p>
<blockquote>
<p><code>i</code>忽略大小写 <code>g</code>全局匹配模式</p>
</blockquote>
</li>
<li><p>字面量创建正则表达式</p>
<blockquote>
<p><code>var 变量名 = /正则表达式/匹配模式</code></p>
<p>注意 // 里不能有空格</p>
</blockquote>
</li>
<li><p>正则表达式语法</p>
<ol>
<li><code>|</code> <code>[]</code> 或</li>
<li><code>[a-z]</code> 小写字母</li>
<li><code>[A-Z]</code> 大写字母</li>
<li><code>[A-z]</code> 任意字母</li>
<li><code>[^ ]</code> 除了括号以内的任意内容</li>
<li><code>[0-9]</code> 任意数字</li>
<li><code>^</code> 表示 x 开头</li>
<li><code>$</code> 表示 x 结尾</li>
<li><code>^$</code> 开始立即结束</li>
<li><code>.</code> 表示任意字符</li>
<li><code>\</code> 转义符 使用 \ 则需要写 \</li>
<li><code>\w</code> 任意 字母 数字 _ 相当于<code>[A-z_0-9]</code></li>
<li><code>\W</code> 除了字母 数字 _ 相当于<code>[^A-z_0-9]</code></li>
<li><code>\d</code> 任意数字 相当于<code>[0-9]</code></li>
<li><code>\D</code> 除了数字 相当于<code>[^0-9]</code></li>
<li><code>\s</code> 空格</li>
<li><code>\S</code> 除了空格</li>
<li><code>\b</code> 单词边界 (前后各加一个<code>\b</code>表示中间的内容是独立的单词)</li>
<li><code>\B</code> 除了单词边界</li>
</ol>
</li>
<li><p>量词 (注意不要加空格)</p>
<ol>
<li><code>{n}</code> 之前的第一个内容出现 n 次</li>
<li><code>{m,n}</code> 之前的内容出现 m 至 n 次 (n 不写表示无限制)</li>
<li><code>+</code> 至少一个 相当于<code>{1,}</code></li>
<li><code>*</code> 零个或多个 相当于<code>{0,}</code></li>
<li><code>?</code> 零个或一个 相当于<code>{0,1}</code></li>
</ol>
</li>
<li><p>相关方法</p>
<ol>
<li><p><code>split()</code> 可以将字符串拆分成一个数组 (默认全局匹配)</p>
</li>
<li><p><code>search()</code> 所搜字符串中是否含有指定内容</p>
<blockquote>
<p>不能全局匹配,只能查找第一个</p>
<p>如果所搜到指定内容返回第一次出现的位置, 没有索搜到则返回 -1</p>
</blockquote>
</li>
<li><p><code>match()</code> 根据正则表达式从一个字符串中将符合条件的内容提取出来</p>
<blockquote>
<p>默认情况下<code>match()</code>只会找到第一个符合要求的内容就会停止检索</p>
<p>我们可以设置正则表达式为<strong>全局匹配模式</strong>这样就会匹配到所有的内容</p>
<p><code>match()</code>会将匹配到的内容封装到一个<strong>数组</strong>中返回, 即使只匹配到一个结果</p>
</blockquote>
</li>
<li><p><code>replace(被替换内容,新的内容)</code> 将字符串中指定内容替换为新的内容</p>
<blockquote>
<p>默认只会替换第一个内容, 被替换内容可以使用正则表达式来匹配</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p><strong>D</strong> Document 网页</p>
<p><strong>O</strong> Object 标签转换为对象</p>
<p><strong>M</strong> Model 标签之间的关系模型</p>
<table>
<thead>
<tr>
<th>常用节点</th>
<th>nodeName</th>
<th>nodeType</th>
<th>nodeValue</th>
</tr>
</thead>
<tbody>
<tr>
<td>文档节点: 整个 HTML 文档</td>
<td>#document</td>
<td>9</td>
<td>null</td>
</tr>
<tr>
<td>元素节点: HTML 文档中的标签</td>
<td>标签名</td>
<td>1</td>
<td>null</td>
</tr>
<tr>
<td>属性节点: 标签的属性</td>
<td>属性名</td>
<td>2</td>
<td>属性值</td>
</tr>
<tr>
<td>文本节点: 标签的内容</td>
<td>#text</td>
<td>3</td>
<td>文本内容</td>
</tr>
</tbody>
</table>
<p>浏览器为我们提供 文档节点对象 这个对象是<code>window</code></p>
<p>可以在页面中直接使用, 文档节点代表整个网页<code>document</code></p>
<p><strong>事件</strong></p>
<ol>
<li><p>就是用户和浏览器之间的交互行为</p>
<blockquote>
<p>比如:点击按钮,移动鼠标,关闭窗口…</p>
</blockquote>
</li>
<li><p>事件响应函数最后 <code>return false</code> 可以取消元素默认行为</p>
</li>
<li><p><code>confirm(&quot;提示字符串&quot;)</code>可以弹出一个提示框, 根据用户操作返回一个布尔值</p>
</li>
<li><p><strong>注意:</strong> 事件的代码是在触发后执行(异步执行), 而其他代码是在加载时执行, 所以要特别注意事件里的变量</p>
</li>
</ol>
<p>为<code>window</code>绑定一个<code>onload</code>事件, 函数中的代码会在页面加载完成后执行</p>
<blockquote>
<p>这样可以确保我们代码执行时 DOM 对象已经加载完毕</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	语句...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过<code>document</code>调用, 获取元素节点<ol>
<li><code>getElementById()</code> 通过 ID 获取一个元素节点对象</li>
<li><code>getElementsByTagName()</code> 通过标签名获取一组元素节点对象</li>
<li><code>getElementsByName()</code> 通过 NAME 属性获取一组节点对象</li>
</ol>
</li>
<li>读取元素节点属性<ol>
<li>语法: <code>元素.属性名</code></li>
<li><code>class属性</code>需要用<code>className</code></li>
</ol>
</li>
<li>通过具体节点调用, 获取元素节点的子节点<ol>
<li><code>getElementsByTagName()</code> 返回当前节点的指定标签名后代节点</li>
<li><code>childNodes</code> 表示当前节点的所有子节点(包括空白文本节点)</li>
<li><code>children</code> 表示当前节点的所有子元素</li>
<li><code>firstChild</code> 表示当前节点的第一个子节点(包括空白文本节点)</li>
<li><code>firstElementChild</code> 表示当前节点的第一个子元素(不支持 IE8 及以下)</li>
<li><code>lastChild</code> 表示当前节点的最后一个子节点(包括空白文本节点)</li>
<li><code>lastElementChild</code> 表示当前节点的第一个子元素(不支持 IE8 及以下)</li>
</ol>
</li>
<li><p>通过具体节点调用, 获取父节点和兄弟节点</p>
<ol>
<li><code>parentNode</code> 表示当前节点的父节点 (父元素唯一)</li>
<li><code>previousSibling</code> 表示当前节点的前一个兄弟节点(包括空白文本节点)</li>
<li><code>previousElementSibling</code> 表示当前节点的前一个兄弟元素(不支持 IE8 及以下)</li>
<li><code>nextSibling</code> 表示当前节点的后一个兄弟节点(包括空白文本节点)</li>
<li><code>nextElementSibling</code> 表示当前节点的后一个兄弟元素(不支持 IE8 及以下)</li>
</ol>
</li>
<li><p>其他查询方法</p>
<ol>
<li><code>document.body</code> 表示 Body 标签</li>
<li><code>document.all</code> 页面中的所有标签<code>document.getElementsByTagName(&quot;*&quot;)</code></li>
<li><code>document.getElementsByClassName()</code> 根据 class 获取元素 (不支持 IE8 及以下)</li>
<li><code>document.querySelector(&quot;CSS选择器&quot;)</code> 根据 CSS 选择器来获取元素(它只会返回第一个结果)</li>
<li><code>document.querySelectorAll(&quot;CSS选择器&quot;)</code> 同上, 支持 IE8 及以上, 返回多个结果保存在数组里</li>
</ol>
</li>
<li><p>DOM 操作</p>
<ol>
<li><code>document.createElement(&#39;标签名&#39;)</code> 根据标签名创建一个相应的元素节点对象</li>
<li><code>document.createTextNode(&#39;文本内容&#39;)</code> 根据文本内容创建一个文本节点</li>
<li><code>父节点对象.appendChild(子节点对象)</code> 向父节点中添加一个子节点</li>
<li><code>父节点对象.insertBefore(新节点对象, 指定节点对象)</code> 在指定的子节点前添加新的节点</li>
<li><code>父节点对象.replaceChild(新节点对象, 指定节点对象)</code> 用新节点替换掉指定节点</li>
<li><code>父节点对象.removeChild(子节点对象)</code> 删除一个子节点</li>
<li><code>节点对象.innerHTML = &#39;内容&#39;</code> 给节点对象的 HTML 内容赋值 ( += 替换 少用)</li>
</ol>
</li>
<li><p>内联样式操作修改值</p>
<ol>
<li><p>通过 DOM 对象<code>style</code>属性设置或读取内联样式</p>
</li>
<li><p>语法: <code>DOM对象.style.样式名 = &quot;值&quot;</code></p>
<blockquote>
<p>数值注意要 + <code>px</code></p>
</blockquote>
</li>
<li><p>如果 CSS 样式名中含有 <code>-</code> 号需要将样式名修改为驼峰命名法</p>
</li>
</ol>
</li>
<li><p>获取元素当前显示的样式</p>
<ol>
<li><p>语法: <code>元素名.currentStyle.样式名</code></p>
<blockquote>
<p>可以用来读取当前元素正在显示的样式的值(只支持 IE,其他浏览器不支持)</p>
</blockquote>
</li>
<li><p>语法: <code>getComputedStyle(要获取样式的元素对象 , null)</code></p>
<blockquote>
<p>该方法可以将元素对象的所有样式封装到一个对象里返回(支持 IE9 及以上)</p>
</blockquote>
</li>
<li><p>通过以上两种方法获取到的样式都是<strong>只读属性</strong>修改需要用<strong>style 属性</strong>来修改</p>
</li>
</ol>
</li>
<li><p>其他样式属性操作(返回值不带 <code>px</code> 只读属性, 无法修改)</p>
<ol>
<li><p><code>clientWidth\clientHeight</code> 返回元素的可见宽度\高度 返回值(内容区+ padding)</p>
</li>
<li><p><code>offsetWidth\offsetHeight</code> 返回元素的整个宽度\高度 返回值(内容区 + padding + 边框)</p>
</li>
<li><p><code>offsetParent</code> 可以获取当前元素定位的父元素(标签<code>postion</code>属性 定位的父元素)</p>
</li>
<li><p><code>offsetLeft\offsetTop</code> 当前元素对于定位父元素的偏移量</p>
</li>
<li><p><code>scrollWidth\scrollHeight</code> 获取元素整个滚动区域的宽度\高度</p>
</li>
<li><p><code>scrollLeft\scrollTop</code> 滚动条 水平\垂直 滚动距离</p>
<blockquote>
<p><code>scrollHeight - scrollTop == clientHeight</code> 表示垂直滚动条滚动到底</p>
</blockquote>
</li>
</ol>
</li>
<li><p>自定义 getStyle() 方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStyle</span>(<span class="params">obj, stylename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.getComputedStyle) &#123;</span><br><span class="line">    <span class="keyword">return</span> getComputedStyle(obj, <span class="literal">null</span>)[stylename]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.currentStyle.stylename</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意 返回值当中有 <strong><code>px</code></strong> 用<code>parseInt()</code>来取值, 注意 IE 中没有默认参数则返回<code>auto</code>需要设置默认参数</p>
</blockquote>
</li>
</ul>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p><strong>B</strong> Browser 浏览器</p>
<p><strong>O</strong> Object 对象</p>
<p><strong>M</strong> Model 模型</p>
<p>BOM 可以使我们通过 JS 来操作浏览器, 它为我们提供了一组对象, 用来完成对浏览器的操作</p>
<ul>
<li><p>BOM 对象</p>
<ol>
<li><p><code>Window</code> 代表的是整个浏览器的窗口,同时 window 也是网页中的全局对象</p>
</li>
<li><p><code>Navigator</code> 代表的当前浏览器的信息,该对象可以用来识别不同的浏览器</p>
</li>
<li><p><code>Location</code> 代表当前浏览器的地址栏信息,通过它可以获取地址栏信息或者跳转页面</p>
</li>
<li><p><code>History</code> 代表浏览器的历史记录,可以通过该对象来操作浏览器的历史纪录</p>
<blockquote>
<p>由于隐私原因 ,该对象不能浏览到具体的历史纪录,只能操作浏览器 向前或者向后</p>
<p>而且该操作只对档次访问有效</p>
</blockquote>
</li>
<li><p><code>Screen</code> 代表用户的屏幕的信息,通过该对象可以获取到用户的显示器相关的信息</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>BOM 对象在浏览器中都是作为<code>window</code>对象的属性保存的, 可以通过<code>window</code>对象调用, 也可以直接使用</p>
</blockquote>
<ul>
<li><p>navigator</p>
<ol>
<li><p>由于历史原因<code>navigator</code>对象中的大部分属性都不能帮助我们识别浏览器了</p>
<blockquote>
<p>一般我们只会使用<code>navigator.userAgent</code>来判断浏览器的信息</p>
</blockquote>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="regexp">/firefox/i</span>.test(navigator.userAgent)) &#123;</span><br><span class="line">  firefox</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/chrome/i</span>.test(navigator.userAgent)) &#123;</span><br><span class="line">  chrome</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/msie/i</span>.test(navigator.userAgent)) &#123;</span><br><span class="line">  ie(Edge除外)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'ActiveXObject'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">  Edge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>location</p>
<blockquote>
<p>直接将 location 属性的值修改为 绝对路径或相对路径</p>
<p>可以使页面跳转到该地址 并生成相应的历史记录</p>
</blockquote>
<ol>
<li><code>location.reload()</code> 相当于刷新如果在方法中传递一个<code>true</code>作为参数, 则会强制清空缓存</li>
<li><code>location.replace()</code> 该方法传入一个地址, 跳转页面但是不会生成历史纪录</li>
<li><code>location.reload()</code> 相当于刷新 如果在方法中传递一个 true 作为参数,则会强制清空缓存</li>
<li><code>location.replace()</code> 该方法传入一个地址,跳转页面 但是不会生成历史纪录</li>
</ol>
</li>
</ol>
</li>
<li><p>history</p>
<ol>
<li><code>length</code> 可以获取到当前访问链接的数量</li>
<li><code>back()</code> 可以用来退回到上一个页面 作用和浏览器上的回退按钮一样</li>
<li><code>forward()</code> 可以跳转到下一个页面 作用和浏览器的前进按钮一样</li>
<li><code>go(整数)</code> 可以用来跳转到指定数目的页面,正数表示向前跳转 负数向后跳转</li>
</ol>
</li>
<li><p>screen 主要用于移动端</p>
</li>
<li><p><code>window</code>对象的方法</p>
<ol>
<li><p><code>setInterval(回调函数, 调用间隔 单位ms)</code></p>
<blockquote>
<p>定时调用, 可以设置一个函数每隔一段时间执行一次</p>
<p>这个方法有个返回值, 该数字 是定时器的唯一 标识</p>
</blockquote>
</li>
<li><p><code>clearInterval(定时器标识)</code></p>
<blockquote>
<p>可以接收任意参数, 用来关闭指定的定时器</p>
<p>同一元素开启定时器时, 需要先关闭当前元素的其他定时器</p>
<p>定时器和键盘操作配合起来可以实现连贯流畅的动态效果</p>
</blockquote>
</li>
<li><p><code>setTimeout(回调函数, 调用延时 单位ms)</code></p>
<blockquote>
<p>定时调用会执行多次, 延时调用只调用 1 次</p>
</blockquote>
</li>
<li><p><code>clearTimeout(timer)</code> 用来关闭延时调用</p>
</li>
</ol>
</li>
</ul>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><ul>
<li><p>事件对象</p>
<ol>
<li>当事件的响应函数被触发时,浏览器每次都会将一个事件对象作为实参传递进响应函数<code>event</code></li>
<li>在事件对象中封装了当前事件相关的一切信息(比如: 鼠标坐标 键盘操作 等等..)</li>
<li>IE 8 及以下 将事件对象 保存在<code>window.event</code>属性中, 用<code>event = event || window.event</code>来兼容</li>
</ol>
</li>
<li><p>事件对象的属性</p>
<ol>
<li><code>事件对象.clientX \ Y</code> 可以获取鼠标指针在当前可见窗口的横纵坐标</li>
<li><code>事件对象.pageX \ Y</code> 可以获取鼠标指针在整个页面中的横纵坐标(不支持 IE8 及以下)</li>
</ol>
</li>
<li><p>事件冒泡(Bubble)</p>
<blockquote>
<p>所谓的事件冒泡指的就是事件的向上传导</p>
<p>当后代元素上的事件被触发时, 其祖先元素上的相同事件也会被触发</p>
</blockquote>
</li>
<li><p>取消冒泡</p>
<ol>
<li>可以通过事件对象来取消冒泡</li>
<li>语法: <code>event.cancelBubble = true</code></li>
</ol>
</li>
<li><p>事件委派</p>
<p>当我们希望只绑定一次事件即可应用到多个元素上, 即使元素是后添加的</p>
<p>我们可以尝试将其<strong>绑定给元素的共有的祖先元素</strong></p>
<ol>
<li>将事件统一绑定给元素的共同的祖先元素</li>
<li>这样当后代元素上的事件触发时会一直冒泡到祖先元素</li>
<li>从而通过祖先元素的响应函数来处理事件这就是事件委派</li>
</ol>
<p>事件委派是利用了冒泡, 通过委派可以减少事件绑定次数, 提高程序性能</p>
</li>
<li><p>检测事件的触发对象</p>
<blockquote>
<p><code>event.target</code> 返回值是触发对象(可配合 if 语句使用)</p>
</blockquote>
</li>
<li><p>事件绑定</p>
<ul>
<li><p>DOM0:</p>
<p>对象.on 事件 = 响应函数`</p>
<blockquote>
<p>他只能为一个元素的一个事件绑定一个响应函数</p>
<p>不能绑定多个事件, 绑定多个相当于赋值后面的语句会覆盖掉前面的语句</p>
</blockquote>
</li>
<li><p>DOM2:</p>
<p>我们可以通过<code>addEventListener()</code>为元素添加事件监听器来绑定多个响应函数</p>
<blockquote>
<p>该语法支持 IE 9 及以上和其他浏览器, <code>this</code>指向调用的元素</p>
<p><code>元素对象.addEventListener(&quot;事件名称,不要on&quot;, 回调函数, 是否在捕获阶段触发一般false)</code></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>IE 8 及以下使用 <code>元素对象.attachEvent(&quot;事件名称&quot;, 回调函数)</code></p>
<p>该语法的执行顺序是: 后绑定的先执行, 该语法中的<code>this</code>指向<code>window</code></p>
</blockquote>
<p>自定义事件兼容函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">obj, evenStr, callBack</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.addEventListener) &#123;</span><br><span class="line">    <span class="comment">//现代浏览器</span></span><br><span class="line">    obj.addEventListener(evenStr, callBack, <span class="literal">false</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//IE8及以下, this指向window是因为回调函数是浏览器直接以函数形式调用</span></span><br><span class="line">    obj.attachEvent(<span class="string">'on'</span> + evenStr, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//我们将匿名函数包裹回调函数再传递给浏览器, 由自己控制函数调用</span></span><br><span class="line">      callBack.call(obj) <span class="comment">//当函数以call方法调用时 this指向指定对象;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件传播</p>
<blockquote>
<p>微软公司认为事件应该是由内向外传播, 先触发当前元素上的事件(事件在冒泡阶段执行)</p>
<p>网景公司认为事件应该是由外向内传播, 先触发祖先元素上的事件(事件在捕获阶段执行)</p>
</blockquote>
<blockquote>
<p>W3C 标准:</p>
<p>​ 1.捕获阶段</p>
<p>​ 在捕获阶段时,从最外层的祖先元素向目标元素进行事件捕获,默认此时不会触发事件</p>
<p>​ 2.目标阶段</p>
<p>​ 事件捕获到目标元素,捕获结束,开始执行目标元素上的事件</p>
<p>​ 3.冒泡阶段</p>
<p>​ 事件从目标元素开始向他的祖先元素上传递,依次触发祖先元素上的相同事件</p>
</blockquote>
</li>
<li><p>浏览器默认行为</p>
<ol>
<li><p>当我们拖拽网页中的内容时,浏览器默认回去搜索相关内容</p>
</li>
<li><p>此时会导致拖拽功能异常, 这个时浏览器的默认行为可以在事件函数中<code>return false</code>来取消</p>
<blockquote>
<p>IE 8 及以下无效</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><ol>
<li><p><code>onclick</code> 鼠标单击时触发</p>
</li>
<li><p><code>onmousemove</code> 该事件将会在鼠标再元素中移动时触发</p>
</li>
<li><code>mouseover</code> 不论鼠标指针穿过被选元素或其子元素都会触发</li>
<li><code>mouseenter</code> 只有在鼠标指针穿过<strong>被选元素时才会触发</strong></li>
<li><code>mouseout</code> 不论鼠标指针离开被选元素还是任何子元素都会触发</li>
<li><code>mouseleave</code> 只有在鼠标指针离开<strong>被选元素时才会触发</strong></li>
</ol>
<ul>
<li><p>强制捕获鼠标按下操作 (IE8 取消拖拽搜索)</p>
<ol>
<li><p><code>捕获鼠标操作的对象.setCapture()</code></p>
<blockquote>
<p>当调用<code>setCapture()</code>方法以后元素会将下一次所有的鼠标按下操作捕获到自身上来</p>
</blockquote>
</li>
<li><p><code>捕获鼠标操作的对象.releaseCapture()</code></p>
<blockquote>
<p>取消对象对鼠标按下操作的强制捕获</p>
</blockquote>
<p>以上 2 种方法 chrome 里会报错, 兼容方法: <code>对象.setCapture &amp;&amp; 对象.setCapture()</code></p>
<blockquote>
<p>&amp;&amp; 如果两边都为 true 则返回后面一个值</p>
</blockquote>
</li>
</ol>
</li>
<li><p>鼠标滚轮事件 <code>onmousewheel</code> 会在滚轮滚动时触发</p>
<blockquote>
<p>但火狐浏览器不支持该属性</p>
</blockquote>
<ol>
<li><p>在火狐中需要使用<code>DOMMouseScroll</code>来绑定滚动事件</p>
</li>
<li><p>注意该事件需要通过自定义事件绑定兼容函数 来绑定</p>
</li>
<li><p><code>event.wheelDelta</code>返回值是正值向上, 负值向下(多数浏览器)</p>
</li>
<li><p><code>event.detail</code>返回值是负值向上, 正值向下(火狐浏览器)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (event.wheelDelta &gt; <span class="number">0</span> || event.detail &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  向上滚动</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  向下滚动</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>当我们滚动滚轮时, 如果浏览器有滚动条, 滚动条会随之滚动</p>
</li>
<li><p>如果不需要可以用<code>return false</code>来取消</p>
</li>
<li><p>火狐使用<code>addEventListener()</code>方法来绑定的函数取消默认行为时<strong>不能</strong>使用<code>return false</code></p>
<blockquote>
<p>需要使用<code>event.preventDefault()</code>来取消默认行为</p>
<p>但是 IE8 不支持, 调用时需要检测是否具有该方法</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><ul>
<li><p><code>onkeydown</code> 按键被按下</p>
<blockquote>
<p>对于它来说如果按住不放 事件会连续触发</p>
</blockquote>
<blockquote>
<p>当 onkeydown 连续触发时 前两次间隔会长一点,之后间隔非常短)</p>
</blockquote>
</li>
<li><p><code>onkeyup</code> 按键被松开</p>
<blockquote>
<p>键盘事件一般都会绑定给可以获取到焦点的对象或者是<code>document</code></p>
</blockquote>
</li>
<li><p><code>onkeypress</code></p>
<blockquote>
<p>事件在所有浏览器中不能触发所有按键(例如：ALT, CTRL, SHIFT, ESC)</p>
</blockquote>
</li>
<li><p><code>oninput</code></p>
<blockquote>
<p>该事件在<code>&lt;input&gt;</code>或<code>&lt;textarea&gt;</code>元素的值发生改变时触发</p>
<p>我们可以通过<code>event.keyCode</code>来获取按键的<code>unicode编码</code></p>
</blockquote>
</li>
<li><p>除了<code>keyCode</code>事件对象中还提供了几个其他属性</p>
<ol>
<li><p><code>altKey</code></p>
</li>
<li><p><code>ctrlKey</code></p>
</li>
<li><p><code>shiftKey</code></p>
</li>
</ol>
<blockquote>
<p>这三个用来判断 相对的按键是否按下 按下返回 true 否则返回 false</p>
</blockquote>
<blockquote>
<p>在文本编辑框的键盘事件的响应函数中<code>return false</code>可以取消默认行为</p>
<p>按下的字母或数字不会打印到文本框上</p>
</blockquote>
</li>
</ul>
<h2 id="CSS-类"><a href="#CSS-类" class="headerlink" title="CSS 类"></a>CSS 类</h2><p>我们希望一行代码可以同时修改多个样式时, 可以通过修改元素的<code>class</code>属性来间接修改样式</p>
<p>我们只需要修改一次,即可同时修改多个样式, 浏览器只需要重新渲染一次性能更好并且结构和行为进一步分离</p>
<ul>
<li><p>自定义 class 函数</p>
<ol>
<li><p>检查元素中是否含有某个<code>className</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasClass</span>(<span class="params">obj, classname</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\b'</span> + classname + <span class="string">'\\b'</span>)</span><br><span class="line">  <span class="keyword">return</span> reg.test(obj.className)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>向一个元素中添加指定的<code>className</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addClass</span>(<span class="params">obj, classname</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!hasClass(obj, classname)) &#123;</span><br><span class="line">    obj.className += <span class="string">' '</span> + classname</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除元素中指定的<code>className</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeClass</span>(<span class="params">obj, classname</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\b'</span> + classname + <span class="string">'\\b'</span>)</span><br><span class="line">  obj.className = obj.className.replace(reg, <span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换一个类(有则删除,没有则添加)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleClass</span>(<span class="params">obj, classname</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hasClass(obj.classname)) &#123;</span><br><span class="line">    removeClass(obj, classname)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    addClass(obj, classname)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JS 中的对象只有自己认识, 其他语言都不认识</p>
<p><code>JSON</code>就是一个特殊格式的字符串, 这个字符串可以被任何语言所识别</p>
<p>并可以转换为任意语言中的对象,JSON 在开发中主要用来交互数据</p>
<p><code>JavaScript Object Notation</code> JS 对象表示法</p>
<blockquote>
<p>JSON 和 JS 对象的格式一样, 只不过 JSON 字符串中的”属性名”<strong>必须加双引号</strong></p>
</blockquote>
<ul>
<li><p>JSON 中允许的值</p>
<ol>
<li>字符串</li>
<li>数值</li>
<li>布尔值</li>
<li>null</li>
<li>普通对象</li>
<li>数组</li>
</ol>
<blockquote>
<p>不能储存函数</p>
</blockquote>
</li>
<li><p>JSON 分类:</p>
<ol>
<li>对象<code>{}</code></li>
<li>数组<code>[]</code></li>
</ol>
</li>
<li><p>将 JSON 字符串转换为 JS 对象</p>
<blockquote>
<p>在 JS 中为我们提供了一个工具类, 就叫 JSON</p>
<p>这个对象可以帮助我们将一个 JSON 对象转换为 JS 对象, 也可以将 JS 对象转换为 JSON</p>
</blockquote>
<ol>
<li><p>JSON ==&gt; JS <code>JSON.parse()</code></p>
</li>
<li><p>JS ==&gt; JSON <code>JSON.stringify()</code></p>
</li>
</ol>
</li>
<li><p><code>eval()</code></p>
<p>这个函数可以用来执行一段字符串形式的 JS 代码, 并将结果返回</p>
<p>如果<code>eval()</code>执行的字符串中含有<code>{}</code>他会将<code>{}</code>当成一个代码块</p>
<p>如果不希望将其当成代码块解析, 需要在字符串前后加一个<code>()</code></p>
<p><code>eval()</code>这个函数的功能很强大, 可以直接执行一个字符串中的 JS 代码</p>
<p>但是在开发中尽量不要使用, 因为它的执行性能差, 具有安全隐患</p>
<p>如果需要兼容 IE 7 及以下的 JSON 操作, 可以通过引入一个外部的 JS 文件来处理</p>
</li>
</ul>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><ul>
<li><p>浏览器内核</p>
<ol>
<li>Chrome Safari: <code>webkit</code></li>
<li>FireFox: <code>Gecko</code></li>
<li>IE: <code>Trident</code></li>
</ol>
</li>
<li><p>内核组成</p>
<ul>
<li><p>主线程</p>
<ol>
<li>js 引擎模块: 负责 js 程序的编译和运行</li>
<li>html/css 文档解析模块: 负责页面文本的解析</li>
<li>dom/css 模块: 负责 dom&amp;css 在内存中的相关处理</li>
<li>布局和渲染模块: 负责页面的布局和效果的绘制</li>
</ol>
</li>
<li><p>分线程</p>
<ol>
<li>定时器模块 : 负责定时器的管理</li>
<li>事件响应模块 : 负责事件的管理</li>
<li>网络请求模块 : 负责 ajax 请求</li>
</ol>
</li>
</ul>
</li>
<li><p>JS 代码分类</p>
<ol>
<li>初始化执行代码 (同步代码)</li>
<li>回调执行代码 (异步代码)</li>
</ol>
</li>
<li><p>JS 引擎执行代码的基本流程</p>
<ol>
<li><p>先执行初始化代码:包括一些特别的代码</p>
<ul>
<li>设定定时器</li>
<li>绑定监听</li>
<li>发送 ajax 请求</li>
</ul>
</li>
<li><p>后面在某一个时刻才会执行会调代码</p>
</li>
<li>回调函数里面的代码是异步执行的</li>
<li>JS 是单线程执行的, 初始代码依次执行完毕后再依次执行回调代码</li>
</ol>
</li>
<li><p><strong>事件循环</strong> (event loop)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   JS(浏览器主线程模块执行)</span><br><span class="line">  heap		    stack	 →→→	 WebAPIs(浏览器分线程模块执行)</span><br><span class="line">堆内存数据	   栈内存数据     →→→</span><br><span class="line">			                  DOM(事件响应)</span><br><span class="line"> 对象...	          初始化代码执行		  ajax(网络请求)</span><br><span class="line">				         setTimeout(定时器)</span><br><span class="line">       	            循环执行                 ↓↓↓</span><br><span class="line">event loop:	 callback queue ( 任务队列/消息队列/事件队列 ) 待执行回调队列依次执行</span><br></pre></td></tr></table></figure>
</li>
<li><p>Web Workers</p>
<p>HTML5 提供的一个 JS 多线程解决方案</p>
<p>我们可以将一些大计算量的代码交由 Web Worker 运行而不冻结用户界面</p>
<p>但是子线程完全受主线程控制且不得操作 DOM</p>
<p>所以这个新标准并没有改变 JS 单线程的本质</p>
</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>所谓的面向对象, 就是在编程的时候尽可能的去模拟真实的现实世界按照现实世界中的逻辑去处理一个问题, 分析问题中参与其中的有哪些实体, 这些实体应该有什么属性和方法，我们如何通过调用这些实体的属性和方法去解决问题</p>
<ul>
<li><strong>实体就是动作的支配者</strong> 没有实体, 就肯定没有动作发生</li>
</ul>
<ol>
<li>分析那些动作是由哪些实体发出的</li>
<li>定义这些实体，为其增加相应的属性和功能</li>
<li>让实体去执行相应的功能或动作</li>
</ol>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/自学笔记/" rel="tag"><i class="fa fa-tag"></i> 自学笔记</a>
          
            <a href="/tags/js/" rel="tag"><i class="fa fa-tag"></i> js</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/09/10/jQuery笔记/" rel="next" title="jQuery笔记">
                <i class="fa fa-chevron-left"></i> jQuery笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/09/15/Vue笔记/" rel="prev" title="Vue笔记">
                Vue笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
      
      <div class="my_post_copyright">
        <p><span>本文标题: </span><a href="/2018/09/12/JavaScript笔记/">JavaScript笔记</a></p>
        <p><span>文章作者: </span><a href="/" title="访问 无聊大作战 的个人博客">无聊大作战</a></p>
        <p><span>发布时间: </span>2018年09月12日 - 06:09</p>
        <p><span>最后更新: </span>2019年05月08日 - 11:05</p>
        <p><b>转载请注明出处，谢谢！</b></p>
      </div>
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            博主信息
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="无聊大作战">
            
              <p class="site-author-name" itemprop="name">无聊大作战</p>
              <p class="site-description motion-element" itemprop="description">半路出家，自学前端半年</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/Se7suna" target="_blank" title="GitHub" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://wpa.qq.com/msgrd?v=3&uin=381897638&site=qq&menu=yes" target="_blank" title="QQ" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-qq"></i>QQ</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaScript"><span class="nav-text">JavaScript</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JS-规范"><span class="nav-text">JS 规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HelloWorld"><span class="nav-text">HelloWorld</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字面量和变量"><span class="nav-text">字面量和变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据类型"><span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#强制类型转换"><span class="nav-text">强制类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算数运算符"><span class="nav-text">算数运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逻辑运算符"><span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#赋值运算"><span class="nav-text">赋值运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件运算符"><span class="nav-text">条件运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流程控制语句"><span class="nav-text">流程控制语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#break-和-continue"><span class="nav-text">break 和 continue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象"><span class="nav-text">对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-text">函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法"><span class="nav-text">方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作用域"><span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#声明提前"><span class="nav-text">声明提前</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包"><span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this"><span class="nav-text">this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数"><span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型"><span class="nav-text">原型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-text">继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的方法"><span class="nav-text">函数的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时间对象"><span class="nav-text">时间对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Math-对象"><span class="nav-text">Math 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包装类"><span class="nav-text">包装类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串的方法"><span class="nav-text">字符串的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正则表达式"><span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM"><span class="nav-text">DOM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BOM"><span class="nav-text">BOM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件对象"><span class="nav-text">事件对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#鼠标事件"><span class="nav-text">鼠标事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#键盘事件"><span class="nav-text">键盘事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS-类"><span class="nav-text">CSS 类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSON"><span class="nav-text">JSON</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Event-Loop"><span class="nav-text">Event Loop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象"><span class="nav-text">面向对象</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">无聊大作战</span>

  

  
</div>







<div class="powered-by">
<span id="busuanzi_container_site_uv">
  访客数 : <span id="busuanzi_value_site_uv"></span>  
</span>
<span id="busuanzi_container_page_pv">
    访问量 : <span id="busuanzi_value_page_pv"></span>
</span>
</div>
        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.1"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  

  

  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":100,"height":150},"mobile":{"show":false},"log":false});</script></body>
</html>
